SET SQL DIALECT 3;

SET NAMES UTF8;

SET CLIENTLIB 'D:\SUBD\Firebird\30X\fbclient.dll';

CREATE DATABASE 'localhost:A4ON_DB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 16384
DEFAULT CHARACTER SET UTF8 COLLATION UTF8;

CREATE DOMAIN D_ACCOUNT AS
VARCHAR(15);

CREATE DOMAIN D_ACCOUNT_NS AS
VARCHAR(15)
COLLATE NUMBERSORT;

CREATE DOMAIN D_BIGINT AS
BIGINT;

CREATE DOMAIN D_BLB_GZIP AS
BLOB SUB_TYPE -15 SEGMENT SIZE 100;

CREATE DOMAIN D_BLOB AS
BLOB SUB_TYPE 0 SEGMENT SIZE 80;

CREATE DOMAIN D_BLOB1K AS
BLOB SUB_TYPE 0 SEGMENT SIZE 1024;

CREATE DOMAIN D_BLOB_GZIP1K AS
BLOB SUB_TYPE -15 SEGMENT SIZE 1024;

CREATE DOMAIN D_BYTES AS
BIGINT;

CREATE DOMAIN D_CHAR1 AS
CHAR(1);

CREATE DOMAIN D_DATE AS
DATE;

CREATE DOMAIN D_DATETIME AS
TIMESTAMP;

CREATE DOMAIN D_DATE_NOW AS
DATE
DEFAULT CURRENT_DATE;

CREATE DOMAIN D_DAY_TARIF AS
NUMERIC(10,5);

CREATE DOMAIN D_DECODER AS
VARCHAR(20)
NOT NULL;

CREATE DOMAIN D_DESCRIPTION AS
VARCHAR(500);

CREATE DOMAIN D_DRE_INFO AS
VARCHAR(157);

CREATE DOMAIN D_EIT_EVENT AS
VARCHAR(4096);

CREATE DOMAIN D_FLAT AS
VARCHAR(100);

CREATE DOMAIN D_FLAT_NS AS
VARCHAR(100)
COLLATE NUMBERSORT;

CREATE DOMAIN D_GEOPOINT AS
NUMERIC(15,12);

CREATE DOMAIN D_HARDWARE AS
VARCHAR(14);

CREATE DOMAIN D_IBOOLEAN AS
SMALLINT
CHECK ((value is null) or (value in (0,1)));

CREATE DOMAIN D_ICHECK AS
SMALLINT
CHECK ((value is null) or (value in (-1, 0,1)));

CREATE DOMAIN D_INITIALS AS
VARCHAR(4);

CREATE DOMAIN D_INTEGER AS
INTEGER;

CREATE DOMAIN D_INT_IP AS
NUMERIC(10,0);

CREATE DOMAIN D_IP AS
VARCHAR(15);

CREATE DOMAIN D_IPV6 AS
VARCHAR(40);

CREATE DOMAIN D_MAC AS
VARCHAR(18);

CREATE DOMAIN D_MESSAGE AS
VARCHAR(1000);

CREATE DOMAIN D_N10 AS
NUMERIC(10,0);

CREATE DOMAIN D_N15_2 AS
NUMERIC(15,2);

CREATE DOMAIN D_N15_3 AS
NUMERIC(15,3);

CREATE DOMAIN D_N15_4 AS
NUMERIC(15,4);

CREATE DOMAIN D_N15_5 AS
NUMERIC(15,5);

CREATE DOMAIN D_N18 AS
NUMERIC(18,0);

CREATE DOMAIN D_NAME AS
VARCHAR(50)
NOT NULL;

CREATE DOMAIN D_NOTICE AS
VARCHAR(1000);

CREATE DOMAIN D_PATH AS
VARCHAR(5000);

CREATE DOMAIN D_PORT_NS AS
VARCHAR(12)
COLLATE NUMBERSORT;

CREATE DOMAIN D_SERVICE_NAME AS
VARCHAR(60);

CREATE DOMAIN D_SMALLINT AS
SMALLINT;

CREATE DOMAIN D_TIME AS
TIME;

CREATE DOMAIN D_TIMESTAMP AS
TIMESTAMP;

CREATE DOMAIN D_UID_NULL AS
INTEGER;

CREATE DOMAIN D_USER AS
VARCHAR(20);

CREATE DOMAIN D_VARBINARY16 AS
VARCHAR(16);

CREATE DOMAIN D_VARCH10_NS AS
VARCHAR(10)
COLLATE NUMBERSORT;

CREATE DOMAIN D_VARCH20_NS AS
VARCHAR(20)
COLLATE NUMBERSORT;

CREATE DOMAIN D_VARCH5_NS AS
VARCHAR(5)
COLLATE NUMBERSORT;

CREATE DOMAIN D_VARCHAR10 AS
VARCHAR(10);

CREATE DOMAIN D_VARCHAR100 AS
VARCHAR(100);

CREATE DOMAIN D_VARCHAR1000 AS
VARCHAR(1000);

CREATE DOMAIN D_VARCHAR150 AS
VARCHAR(150);

CREATE DOMAIN D_VARCHAR20 AS
VARCHAR(20);

CREATE DOMAIN D_VARCHAR2000 AS
VARCHAR(2000);

CREATE DOMAIN D_VARCHAR255 AS
VARCHAR(255);

CREATE DOMAIN D_VARCHAR30 AS
VARCHAR(30);

CREATE DOMAIN D_VARCHAR5 AS
VARCHAR(5);

CREATE DOMAIN D_VARCHAR50 AS
VARCHAR(50);

CREATE DOMAIN D_VARCHAR500 AS
VARCHAR(500);

CREATE DOMAIN D_VARCHAR6 AS
VARCHAR(6);

CREATE DOMAIN D_VARCHAR60 AS
VARCHAR(60);

CREATE DOMAIN INT_NULL AS
INTEGER;

CREATE DOMAIN T_YESNO AS
CHAR(1)
default 'n'
check((value is null) or (value in ('n','y')));

CREATE DOMAIN UID AS
INTEGER
NOT NULL;

CREATE GENERATOR GEN_ACCOUNT_NO START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_ACCOUNT_NO TO 82;

CREATE GENERATOR GEN_APPLIANCE_UID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_APPLIANCE_UID TO 7;

CREATE GENERATOR GEN_BLB START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_BLB TO 5;

CREATE GENERATOR GEN_CARD_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_CARD_ID TO 0;

CREATE GENERATOR GEN_CUSTOMER_UID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_CUSTOMER_UID TO 44;

CREATE GENERATOR GEN_DEVICES_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_DEVICES_ID TO 17;

CREATE GENERATOR GEN_DEVPORTS_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_DEVPORTS_ID TO 0;

CREATE GENERATOR GEN_DEVPROFILES_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_DEVPROFILES_ID TO 0;

CREATE GENERATOR GEN_DIGIT_SEQ START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_DIGIT_SEQ TO 1;

CREATE GENERATOR GEN_EPG START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_EPG TO 122657;

CREATE GENERATOR GEN_EQ_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_EQ_ID TO 611;

CREATE GENERATOR GEN_ISSUE START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_ISSUE TO 0;

CREATE GENERATOR GEN_JOURNAL START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_JOURNAL TO 355;

CREATE GENERATOR GEN_MAP_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_MAP_ID TO 0;

CREATE GENERATOR GEN_MAP_XY_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_MAP_XY_ID TO 0;

CREATE GENERATOR GEN_MODULE_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_MODULE_ID TO 0;

CREATE GENERATOR GEN_OPERATIONS_UID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_OPERATIONS_UID TO 51242;

CREATE GENERATOR GEN_ORDER_TP START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_ORDER_TP TO 8;

CREATE GENERATOR GEN_PAYMENT START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_PAYMENT TO 294;

CREATE GENERATOR GEN_QUEUE START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_QUEUE TO 4230;

CREATE GENERATOR GEN_REPORT_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_REPORT_ID TO 539;

CREATE GENERATOR GEN_REQUEST START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_REQUEST TO 174;

CREATE GENERATOR GEN_TASK START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_TASK TO 74;

CREATE GENERATOR GEN_UID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_UID TO 2052;

CREATE GENERATOR GEN_VPN_SESSIONS_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR GEN_VPN_SESSIONS_ID TO 0;

CREATE GENERATOR G_LOG_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR G_LOG_ID TO 530;

CREATE GENERATOR MAP_LOG_ID START WITH 0 INCREMENT BY 1;
SET GENERATOR MAP_LOG_ID TO 0;

CREATE EXCEPTION E_CANNOT_DELETE '#1 Can not delete.';

CREATE EXCEPTION E_DECODER_ERROR '#2 Decoder number incorrect.';

CREATE EXCEPTION E_INVALID_IP '#3 IP adres incorrect.';

CREATE EXCEPTION E_INVALID_MAC '#4 MAC adres incorrect.';

CREATE EXCEPTION E_MAT_QUANT_LESS '#8 Materials less then entered';

CREATE EXCEPTION E_NOT_EMPTY '#5 Value should not be empty.';

CREATE EXCEPTION E_STRICT_MODE '#7 Strict mode. Date operation before current date.';

CREATE EXCEPTION E_TARIF_EXISTS '#6 Tarif with same date exists';

CREATE OR ALTER PROCEDURE ADD_FLAT_TO_HOUSE (
    HOUSE_ID UID,
    FLAT_NO D_FLAT,
    PORCH_N D_VARCHAR10,
    FLOOR_N D_VARCHAR100)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_OR_MOVE_PAYMENT (
    PAYDOC D_INTEGER,
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT (
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_NOTICE,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACC_SUR (
    ACCOUNT_NO D_ACCOUNT,
    SURNAME D_VARCHAR100,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID TYPE OF UID,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_NOTICE,
    EXT_PAY_ID D_VARCHAR50,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACCOUNT (
    ACCOUNT_NO D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID TYPE OF UID,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV TYPE OF UID,
    NOTICE D_NOTICE,
    EXT_PAY_ID D_VARCHAR50,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACCOUNT_FINE (
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATE,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_VARCHAR255,
    EXT_PAY_ID D_VARCHAR50,
    FINE D_N15_2,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_EXT (
    PAY_DOC_ID TYPE OF D_INTEGER,
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_FINE (
    CUSTOMER_ID D_INTEGER,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATE,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_VARCHAR255,
    FINE D_N15_2,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_FROM_EXT_SYSTEMS (
    ACCOUNT_NO TYPE OF D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50,
    NOTICE D_NOTICE,
    PAY_TYPE_STR D_VARCHAR30 = 'CASH',
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_ACCOUNT (
    PAYSRC_CODE D_VARCHAR100,
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATETIME,
    NOTICE D_NOTICE = null,
    FINE_SUM D_N15_2 = null,
    PAYMENT_TYPE D_INTEGER = null,
    PAYMENT_SRV D_INTEGER = null,
    EXT_PAY_ID D_VARCHAR50 = null,
    TAG D_INTEGER = null,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_CUSTID (
    PAYSRC_CODE D_VARCHAR100,
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_DOG_FIO (
    PAYSRC_CODE D_VARCHAR100,
    CONTRACT D_VARCHAR20,
    FIO D_VARCHAR100,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2 = 1,
    P_DATE D_DATE = current_date,
    P_NOTICE D_NOTICE = null /* COLLATE UTF8 - default */,
    P_HISTORY TYPE OF UID = null,
    RECALC D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE_VAT (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_HISTORY TYPE OF UID,
    P_VATG_ID TYPE OF UID,
    RECALC D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE_WO_CALC (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_HISTORY TYPE OF UID,
    P_VATG_ID TYPE OF UID,
    RQ_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_STAT_IP (
    IP_BIN TYPE OF D_INT_IP,
    STAT_DATE TYPE OF D_TIMESTAMP,
    BYTES TYPE OF D_INTEGER,
    TRAFCLASS TYPE OF D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_SUBSCR_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    P_CONTRACT D_VARCHAR20,
    P_CONTRACT_DATE D_DATE,
    RECALC D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ADD_SUBSCR_SERVICE_VAT (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    P_CONTRACT D_VARCHAR20,
    P_CONTRACT_DATE D_DATE,
    P_VATG_ID TYPE OF UID,
    RECALC D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_BALANCE (
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    B_MONTH D_DATE,
    B_DESCRIPTION D_VARCHAR500,
    B_SUM D_N15_2,
    SUM_TYPE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_SERVICES (
    CUSTOMER_ID TYPE OF UID,
    FOR_DATE D_DATE = current_date,
    SHOW_OLD D_IBOOLEAN = 0)
RETURNS (
    SERVICE_ID TYPE OF UID,
    STATE D_INTEGER,
    STATE_DATE D_DATE,
    CAN_ON D_INTEGER,
    CAN_OFF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_SERVICES_NEW (
    CUSTOMER_ID TYPE OF UID,
    FOR_DATE D_DATE = current_date,
    SHOW_OLD D_IBOOLEAN = 0)
RETURNS (
    SERVICE_ID TYPE OF UID,
    STATE D_INTEGER,
    STATE_DATE D_DATE,
    CAN_ON D_INTEGER,
    CAN_OFF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_GET_NEW_ACCOUNT (
    HOUSE_ID TYPE OF UID = null,
    FLAT D_FLAT = null,
    SRV_ID TYPE OF UID = null)
RETURNS (
    ACCOUNT_NO D_ACCOUNT)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_GET_SERVICES (
    P_CUSTOMER_ID TYPE OF UID,
    P_TYPE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_REMAIN_DAYS (
    CUSTOMER_ID UID,
    FOR_DATE D_DATE = null)
RETURNS (
    REMAIN_DAYS D_INTEGER,
    SUM_ALL_TARIFS D_N15_2,
    SUM_DAY_TARIFS D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_REQUEST_CLOSE (
    AREQUEST_ID UID,
    ARESULT D_INTEGER,
    ADEFECT D_NOTICE,
    AEXEC_TIME D_DATETIME = localtimestamp)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE API_REQUEST_JOIN (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_REQUEST_REFUSE (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_REQUEST_TAKE (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user /* COLLATE UTF8 - default */)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_DISCOUNT (
    CUSTOMER_ID UID,
    FACTOR_VALUE D_N15_4,
    DATE_FROM D_DATE_NOW = current_date,
    DATE_TO D_DATE_NOW = '2100-01-01',
    SERV_ID UID = -1,
    SRV_TYPE UID = -1,
    NOTICE D_NOTICE = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_LAN (
    CUSTOMER_ID UID,
    MAC D_MAC,
    IP D_IP = null /* COLLATE UTF8 - default */,
    EQ_ID D_UID_NULL = null,
    PORT D_INTEGER = null,
    VLAN_ID D_UID_NULL = null,
    NOTICE D_NOTICE = null /* COLLATE UTF8 - default */,
    IPV6 D_IPV6 = null /* COLLATE UTF8 - default */,
    IP_ADD D_IP = null /* COLLATE UTF8 - default */,
    TAG D_INTEGER = null,
    TAG_STR D_VARCHAR50 = null /* COLLATE UTF8 - default */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_SERVICE (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    SET_ON D_INTEGER = 1,
    SET_DATE D_DATE = current_date,
    SRV_ON_OFF TYPE OF UID = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE API_SET_PREPAY (
    CUSTOMER_ID INTEGER,
    PREPAY_SUM NUMERIC(15,2))
RETURNS (
    MSG VARCHAR(255),
    CODE SMALLINT)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE API_SET_SWITCH_QUEUE (
    CUSTOMER_ID TYPE OF UID,
    LINK_ID TYPE OF UID)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ATRIBUTES_LINE (
    CUST_ID TYPE OF UID)
RETURNS (
    A_LINE D_VARCHAR500)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ATTRIBUTE_CHECK_UNIQ (
    TYPE_ID INTEGER /* TYPE OF COLUMN ATTRIBUTE.TYPE_ID */,
    OBJECT_ID INTEGER /* TYPE OF COLUMN ATTRIBUTE.OBJECT_ID */,
    AID INTEGER /* TYPE OF COLUMN ATTRIBUTE.AID */,
    AVALUE VARCHAR(100) /* TYPE OF COLUMN ATTRIBUTE.AVALUE */)
RETURNS (
    RESULT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ATTRIBUTES_IUD (
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR50,
    O_DESCRIPTION D_NOTICE,
    O_DIMENSION D_VARCHAR50,
    O_DELETED D_INTEGER,
    O_CHARFIELD D_VARCHAR1000,
    O_CHECK D_VARCHAR255,
    P_ACTION D_INTEGER,
    O_TYPE D_INTEGER,
    O_NUMERICFIELD D_INTEGER = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE AUTO_OFF_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERV_ID TYPE OF UID,
    P_DATE D_DATE,
    P_ACTSERVICE D_INTEGER,
    P_NOTICE D_NOTICE)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE AUTO_ON_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERV_ID TYPE OF UID,
    P_DATE D_DATE,
    P_ACTSERVICE D_INTEGER,
    P_NOTICE D_NOTICE)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE BCISSUECH_ID (
    BI_ID INTEGER /* TYPE OF COLUMN BCI_CHANNELS.BI_ID */,
    CH_ID INTEGER /* TYPE OF COLUMN BCI_CHANNELS.CH_ID */,
    P_ACTION D_INTEGER = 0)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE BONUS_ADD_AFTER_PAYMENT (
    P_CUSTOMER_ID UID,
    P_PAYMENT_ID UID,
    P_PAY_SUM D_N15_2)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE BONUS_RATE_INS (
    ID UID,
    BT_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    UNITS_FROM NUMERIC(15,2),
    UNITS_TO NUMERIC(15,2),
    RATE NUMERIC(15,2),
    NOTICE VARCHAR(1000))
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE BONUS_RATE_UPD (
    ID UID,
    BT_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    UNITS_FROM NUMERIC(15,2),
    UNITS_TO NUMERIC(15,2),
    RATE NUMERIC(15,2),
    NOTICE VARCHAR(1000))
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_DAY_INC_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_DAY_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_DAY_TARIF (
    P_MONTH D_DATE,
    P_CALC_TYPE D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_DISCOUNT (
    FOR_MONTH TYPE OF D_DATE)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_DISCOUNT_AFTER_PAY (
    VCUSTOMER_ID TYPE OF UID,
    VPAY_SUM TYPE OF D_N15_2,
    VPAY_DATE TYPE OF D_DATE)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_FIXED_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_KOEF_TARIF (
    P_CUSTOMER_ID UID,
    P_SERV_ID D_INTEGER,
    P_MONTH D_DATE,
    P_IS_J D_INTEGER = 0,
    P_SRVTYPE D_INTEGER = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_MONTH_DAY_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_MONTH_FIX_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_MONTH_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_PERS_TARIF (
    P_CUSTOMER_ID UID,
    P_SERV_ID D_INTEGER,
    P_MONTH D_DATE,
    P_IS_J D_INTEGER = 0)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALC_SINGLE_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CALCULATE_FINE (
    CUSTOMER_ID TYPE OF UID,
    DATE_PAYMENT D_DATE = null,
    FINE_PERCENT D_N15_2 = null,
    FINE_MONTH D_INTEGER = null,
    FINE_DAY D_INTEGER = null)
RETURNS (
    SERVICE_ID TYPE OF UID,
    DOLG_SUM D_N15_2,
    DOLG_DATE D_DATE,
    FINE_SUM D_N15_2,
    FINE_DAYS D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CALCULATE_SRV_TYPE_0 (
    ACUSTOMER TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CAN_USER_VIEW_ADDRESS (
    HOUSE_ID D_UID_NULL = null,
    STREET_ID D_UID_NULL = null,
    USER_NAME D_VARCHAR30 = current_user)
RETURNS (
    CAN_VIEW D_IBOOLEAN)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CANCEL_CONTRACT (
    PCUSTOMER_ID TYPE OF UID,
    PCANCEL_DATE D_DATE,
    POFF_SRV_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CANCEL_LAST_SUBSCRIBE_ACTION (
    SUBSCR_SERV_ID TYPE OF UID)
RETURNS (
    RESULT TYPE OF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CARDS_PREPAY_ACTIVATE (
    CARD_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE D_DATE)
RETURNS (
    PAYMENT_ID TYPE OF UID)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CARDS_PREPAY_GENERATE (
    CP_COUNT D_INTEGER,
    CP_NOMINAL D_N15_2,
    CP_SERIAL D_INTEGER,
    CP_EXP_DATE D_DATE)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHANGE_AUTOBLOCK_OFF (
    CUSTOMER_ID TYPE OF UID,
    SERVICE_ID TYPE OF UID,
    OFF_SERVICE TYPE OF UID,
    UNITS D_N15_2)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHANGE_CH_TO_CH (
    FROM_CH D_UID_NULL,
    TO_CH D_UID_NULL,
    ANALOG D_IBOOLEAN = null,
    DVB D_IBOOLEAN = null,
    IPTV D_IBOOLEAN = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHANGE_TO_POSITIVE (
    CUSTOMER_ID UID,
    OLD_DEBT D_N15_2 = null,
    NEW_DEBT D_N15_2 = null,
    HOUSE_ID D_UID_NULL = null,
    FLAT D_FLAT = null /* COLLATE UTF8 - default */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHANNELS_DEL (
    CH_ID INTEGER /* TYPE OF COLUMN CHANNELS.CH_ID */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHANNELS_FOR_ALL_CUSTOMER (
    CHECK_DATE D_DATE)
RETURNS (
    CUSTOMER_ID TYPE OF UID,
    DECODER_ID TYPE OF UID,
    CHANNEL_ID TYPE OF UID,
    DECODER_N TYPE OF D_DECODER,
    CHANNEL_STATE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CHANNELS_FOR_CUSTOMER (
    CUSTOMER_ID TYPE OF UID,
    CHECK_DATE D_DATE)
RETURNS (
    C_CHANNEL D_INTEGER,
    C_CHANNEL_ON D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CHECK_FOR_UNBLOCK (
    CUSTOMER_ID UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CHECK_IN_BLOCK (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    FOR_DATE D_DATE)
RETURNS (
    IN_BLOCK D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CHECK_IN_OFF (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    FOR_DATE D_DATE)
RETURNS (
    SRV_OFF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CHECK_SRV_ACTIVE (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL,
    FOR_DATE D_DATE = current_date)
RETURNS (
    SRV_ON D_INTEGER,
    DATE_ON D_DATE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CHECKCONTRACT (
    CONTRACT TYPE OF D_VARCHAR20)
RETURNS (
    CORRECT TYPE OF D_IBOOLEAN)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CLOSE_DAY_PROC (
    P_MONTH D_DATE = null,
    P_CUSTOMER_ID TYPE OF UID = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CLOSE_MATERIAL_DOC (
    DOC_ID UID)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CLOSE_MONTH_PROC (
    P_MONTH D_DATE,
    P_CUSTOMER_ID TYPE OF UID = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CLOSE_PERIOD_PROC (
    P_START_MONTH D_DATE,
    P_END_MONTH D_DATE,
    P_CUSTOMER_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CURRENCY_TO_STR (
    VAL D_N15_2,
    SHOWCURRENCY D_INTEGER)
RETURNS (
    CURR_STR D_VARCHAR1000)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CUSTOMER_BALANCE (
    P_CUSTOMER_ID TYPE OF UID,
    FROM_DATE D_DATE = null)
RETURNS (
    RCUSTOMER_ID TYPE OF UID,
    RMONTH D_DATE,
    FDESCRIPTION D_VARCHAR500,
    PDESCRIPTION D_VARCHAR500,
    FSUMMA D_N15_2,
    PSUMMA D_N15_2,
    SUM_TYPE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE CUSTOMER_CONTACTS_IU (
    CUSTOMER_ID INTEGER,
    CC_VALUE VARCHAR(255),
    CC_TYPE SMALLINT = 0,
    CC_NOTICE VARCHAR(1000) = null /* COLLATE UTF8 - default */,
    CC_NOTIFY SMALLINT = 1,
    CC_OLD VARCHAR(255) = null /* COLLATE UTF8 - default */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CUSTOMER_DEBT_ADD (
    P_CUSTOMER_ID UID,
    P_SUM D_N15_2)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CUSTOMER_SERVICES_STATE (
    P_CUSTOMER_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE CUSTOMERS_SERVICES_STATE
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DAY_TARIF_FOR_SRV (
    BEGIN_MONTH D_DATE,
    FOR_SERVICE TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DECL_OF_NUM (
    NUM INTEGER,
    TITLE0 VARCHAR(100) = null,
    TITLE1 VARCHAR(100) = null,
    TITLE2 VARCHAR(100) = null)
RETURNS (
    RESULT VARCHAR(100))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE DELETE_CUSTOMER (
    CID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DELETE_CUSTOMER_DECODER (
    DEC_ID UID,
    DECODER_STATE D_INTEGER,
    STB_STATE D_INTEGER = null,
    NOTICE D_NOTICE = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DELETE_MONTH_PROC (
    P_MONTH D_DATE)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DELETE_NODE (
    ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DELETE_OBJECT (
    OID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DELETE_SUBSCR_SERVICE (
    P_SUBSCR_SERV_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DIGITAL_EVENT (
    DTV_ACTION TYPE OF D_INTEGER,
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DIGITAL_EVENT_ADD (
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DIGITAL_EVENT_DECODER (
    HARDWARE_ID TYPE OF D_DECODER,
    NEW_SRV_ID TYPE OF UID,
    OLD_SRV_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DIGITAL_EVENT_DEL (
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DISCOUNT_IU (
    DISCOUNT_ID INTEGER /* TYPE OF COLUMN DISCOUNT_FACTOR.DISCOUNT_ID */,
    CUSTOMER_ID INTEGER /* TYPE OF COLUMN DISCOUNT_FACTOR.CUSTOMER_ID */,
    DATE_FROM DATE /* TYPE OF COLUMN DISCOUNT_FACTOR.DATE_FROM */,
    DATE_TO DATE /* TYPE OF COLUMN DISCOUNT_FACTOR.DATE_TO */,
    FACTOR_VALUE NUMERIC(15,4) /* TYPE OF COLUMN DISCOUNT_FACTOR.FACTOR_VALUE */,
    SERV_ID INTEGER /* TYPE OF COLUMN DISCOUNT_FACTOR.SERV_ID */,
    SRV_TYPE INTEGER /* TYPE OF COLUMN DISCOUNT_FACTOR.SRV_TYPE */,
    NOTICE VARCHAR(1000) /* TYPE OF COLUMN DISCOUNT_FACTOR.NOTICE */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE DUBLICATE_REQUEST (
    FROM_REQUEST D_INTEGER,
    FOR_CUSTOMER D_INTEGER,
    FOR_NODE D_INTEGER = 0)
RETURNS (
    REQUEST_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE EPG_ADD (
    CH_ID TYPE OF UID,
    TITLE TYPE OF D_VARCHAR255,
    UTC_START TYPE OF D_TIMESTAMP,
    UTC_STOP TYPE OF D_TIMESTAMP,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE EPG_ADD_BY_SC (
    SOURCE_ID TYPE OF UID,
    EPG_CODE TYPE OF D_VARCHAR100,
    TITLE TYPE OF D_VARCHAR255,
    UTC_START TYPE OF D_TIMESTAMP,
    UTC_STOP TYPE OF D_TIMESTAMP,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE EQUIPMENT_UPD (
    EQ_ID TYPE OF UID,
    EQ_N TYPE OF D_DECODER,
    EQ_TYPE TYPE OF D_INTEGER,
    EQ_STATE TYPE OF D_INTEGER,
    EQ_MAN TYPE OF D_INTEGER,
    NOTICE TYPE OF D_NOTICE,
    TEXT_ENCODE TYPE OF D_VARCHAR5)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE EXPLODE (
    SEPARATOR D_CHAR1,
    A_VALUE D_VARCHAR1000)
RETURNS (
    STR D_VARCHAR1000)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE EXPLODE_NO_EMPTY (
    SEPARATOR D_CHAR1,
    A_VALUE D_VARCHAR2000)
RETURNS (
    STR D_VARCHAR2000)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE EXTRACT_ALL_DIGITS (
    A_VALUE D_VARCHAR255)
RETURNS (
    DIGITS D_VARCHAR255)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE EXTRACT_NUMBER (
    A_VALUE D_VARCHAR255)
RETURNS (
    RESULT D_VARCHAR255)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE FIX_PORT_CONNECT
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE FORMAT_DATE (
    A_DATE DATE = current_date,
    FORMAT VARCHAR(1000) = null,
    LONG_DAY_NAMES VARCHAR(100) = null,
    SHORT_DAY_NAMES VARCHAR(50) = null,
    LONG_MONTH_NAMES VARCHAR(200) = null,
    SHORT_MONTH_NAMES VARCHAR(200) = null)
RETURNS (
    RESULT VARCHAR(1000))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE FORMAT_MAC (
    AMAC D_MAC)
RETURNS (
    MAC D_MAC)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE FREELANEQUIPMENT (
    CUSTOMER_ID TYPE OF UID,
    UNIT_ID D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE FULL_RECALC_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_FROM_DATE D_DATE = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE GEN_PASSWORD (
    MIN_LENGTH SMALLINT = 8,
    MAX_LENGTH SMALLINT = 10)
RETURNS (
    PWD VARCHAR(100))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_ACTIVE_DAYS (
    CUSTOMER_ID UID,
    FROM_DATE D_DATE,
    TO_DATE D_DATE,
    SERVICE_ID D_UID_NULL,
    BUSINESS_ID D_UID_NULL = null)
RETURNS (
    DAYS_ON D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_ALL_REPORTS
RETURNS (
    ID_REPORT D_INTEGER,
    ID_PARENT D_INTEGER,
    REPORT_NAME D_VARCHAR500,
    NO_VISIBLE D_IBOOLEAN,
    LVL D_INTEGER,
    IS_FILE D_IBOOLEAN,
    PATH D_PATH,
    FULL_PATH D_PATH)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_CONNECTED_DAYS (
    P_CUSTOMER_ID D_UID_NULL,
    P_SERVICE_ID D_UID_NULL,
    P_FROM D_DATE,
    P_TO D_DATE)
RETURNS (
    DAYS D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_CUSTOMER_CHANNELS (
    CHECK_DATE D_DATE,
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    DECODER_ID TYPE OF UID,
    CHANNEL_ID TYPE OF UID,
    DECODER_N TYPE OF D_DECODER,
    CHANNEL_STATE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_CUSTOMER_CODE (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    CUST_CODE TYPE OF D_VARCHAR20)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_CUSTOMER_CURRENT_SRV (
    CUSTOMER_ID TYPE OF UID,
    BUSINESS_TP TYPE OF UID = null)
RETURNS (
    SERVICE_ID TYPE OF UID,
    NAME TYPE OF D_VARCHAR60,
    STATE_SGN D_INTEGER,
    STATE_SRV TYPE OF UID,
    STATE_DATE D_DATE,
    BUSINESS_TYPE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_DAYS_TOTAL (
    CUSTOMER_ID UID,
    ACTIVE_ONLY D_INTEGER = 0)
RETURNS (
    TOTAL_START D_DATE,
    TOTAL_DAYS D_INTEGER,
    ACTIVE_START D_DATE,
    ACTIVE_DAYS D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_DEBT_START_DATE (
    ACCOUNT D_ACCOUNT)
RETURNS (
    DEBT_DATE D_DATE,
    DEBT D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_DEBT_START_DATE_CID (
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    DEBT_DATE D_DATE,
    DEBT D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_DISTANCE (
    LAT1 DOUBLE PRECISION,
    LOG1 DOUBLE PRECISION,
    LAT2 DOUBLE PRECISION,
    LOG2 DOUBLE PRECISION)
RETURNS (
    DISTANCE_METER DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_EPG (
    STREAM_ID TYPE OF UID,
    DATE_FROM TYPE OF D_TIMESTAMP,
    DATE_TO TYPE OF D_TIMESTAMP,
    OTHERSTREAM TYPE OF D_INTEGER,
    DESC_FORMAT D_VARCHAR50 = null /* COLLATE UTF8 - default */)
RETURNS (
    TSID TYPE OF D_INTEGER,
    ONID TYPE OF D_INTEGER,
    SID TYPE OF D_INTEGER,
    CH_ID TYPE OF UID,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    TITLE TYPE OF D_VARCHAR255,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255,
    LANG TYPE OF D_VARCHAR5,
    ISACTUAL TYPE OF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_EPG_APART (
    STREAM_ID TYPE OF UID,
    DATE_FROM TYPE OF D_TIMESTAMP,
    DATE_TO TYPE OF D_TIMESTAMP,
    OTHERSTREAM TYPE OF D_INTEGER)
RETURNS (
    TSID TYPE OF D_INTEGER,
    ONID TYPE OF D_INTEGER,
    SID TYPE OF D_INTEGER,
    CH_ID TYPE OF UID,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    TITLE TYPE OF D_VARCHAR255,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255,
    LANG TYPE OF D_VARCHAR5,
    ISACTUAL TYPE OF D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FLOOR (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    FLOOR_N TYPE OF D_VARCHAR10)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FREE_INET_IP (
    SRV_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FREE_INET_IP_CUSTOMER (
    CUSTOMER_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FREE_IP (
    IP_MASK D_IP = null)
RETURNS (
    IP TYPE OF D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FREE_VLAN_IP (
    VLAN_ID TYPE OF D_INT_IP)
RETURNS (
    IP TYPE OF D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FULLNAME_ALLREPORTS (
    SEPARATOR VARCHAR(10))
RETURNS (
    ID_REPORT INTEGER,
    FULL_NAME VARCHAR(5000))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_FULLNAME_REPORT (
    ID_REPORT INTEGER,
    SEPARATOR VARCHAR(10))
RETURNS (
    FULL_NAME VARCHAR(5000))
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_MAT_FOR_NODE (
    NODE_ID UID)
RETURNS (
    M_ID UID,
    NAME D_VARCHAR255,
    M_TYPE D_UID_NULL,
    NEED_CNT D_N15_2,
    IS_UNIT D_IBOOLEAN)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_MAT_FOR_REQUEST (
    IRQ_ID D_UID_NULL,
    IMG_ID D_UID_NULL = null,
    IMT_ID D_UID_NULL = null)
RETURNS (
    RM_ID D_UID_NULL,
    M_ID UID,
    NAME D_VARCHAR100,
    DIMENSION D_VARCHAR10,
    COST D_N15_2,
    WH_NAME D_VARCHAR100,
    WH_ID UID,
    RM_QUANT D_N15_5,
    NOT_CALC D_IBOOLEAN,
    MR_QUANT D_N15_5,
    M_NUMBER D_N15_5,
    RQ_ID D_UID_NULL)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_MAT_GIVE_OUT (
    FOR_RQ D_INTEGER,
    MG_ID D_INTEGER = -1,
    RQ_OWNER D_IBOOLEAN = 0)
RETURNS (
    RM_ID D_INTEGER,
    M_ID D_INTEGER,
    NAME D_DESCRIPTION,
    DIMENSION D_VARCHAR10,
    O_NAME D_DESCRIPTION,
    WH_ID D_INTEGER,
    RM_QUANT D_N15_5,
    NOT_CALC D_INTEGER,
    MR_QUANT D_N15_5,
    RM_COST D_N15_2,
    M_NUMBER D_VARCHAR20,
    QUANT_TOTAL D_N15_5,
    QUANT_IN_REQUEST D_N15_5,
    RQ_ID D_INTEGER,
    RM_NOTICE D_NOTICE,
    DESCRIPTION D_NOTICE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_MAX_INET_IP (
    SRV_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_MODULES_FOR_MENU
RETURNS (
    ID_MODULE D_INTEGER,
    NAME D_VARCHAR500,
    LANG D_INTEGER,
    NOTICE D_NOTICE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_NODE_FLAT_LVL (
    NODE_ID INTEGER)
RETURNS (
    HOUSE_ID INTEGER,
    LVL INTEGER,
    FLAT_NO D_FLAT_NS,
    PORCH_N D_FLAT_NS,
    FLOOR_N D_FLAT_NS,
    SRV_LIST VARCHAR(400),
    CST_LIST VARCHAR(400),
    STREET_NAME VARCHAR(250),
    HOUSE_NO VARCHAR(80),
    NOTICE D_NOTICE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_PAY_DOC (
    PAYSOURCE_ID D_INTEGER,
    PAY_DATE D_DATE,
    PAY_DOC_NO D_VARCHAR255)
RETURNS (
    PAY_DOC_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_PORCH (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    PORCH_N TYPE OF D_VARCHAR10)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_REPORT_ID (
    FULL_NAME VARCHAR(5000),
    SEPARATOR CHAR(1))
RETURNS (
    ID_REPORT INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_REQUEST_BUSY_DAYS (
    HOUSE_ID TYPE OF UID,
    FROM_DATE D_DATE,
    TO_DATE D_DATE,
    TEMPLATE_ID D_INTEGER)
RETURNS (
    BUSY_DAY D_DATE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_REQUEST_FREEDAY (
    HOUSE_ID TYPE OF UID,
    TEMPLATE_ID D_INTEGER)
RETURNS (
    FREE_DAY D_DATE)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_SERVICES_FOR_IP (
    IP D_IP)
RETURNS (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    STATE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_SERVICES_TO_SWITCH (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_STATISTICS (
    S_DATE D_DATE,
    E_DATE D_DATE)
RETURNS (
    SERVICE_ID UID,
    CUSTOMER_ID UID,
    S_ON D_INTEGER,
    S_BLOCK D_INTEGER,
    P_NEW D_INTEGER,
    P_RETURN D_INTEGER,
    P_SWITCH D_INTEGER,
    P_OFF D_INTEGER,
    P_OFFSWITCH D_INTEGER,
    E_ON D_INTEGER,
    E_BLOCK D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GET_TARIF_SUM_CUSTOMER_SRV (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL = null,
    FOR_DAY D_DATE = null)
RETURNS (
    M_TARIF D_N15_4)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GETSERVICES (
    P_CUSTOMER_ID TYPE OF UID,
    P_TYPE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE GETSERVICESTOSWITCH (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE HOUSE_IUD (
    OPERATION D_CHAR1,
    HOUSE_ID TYPE OF UID = null,
    STREET_ID TYPE OF UID = null,
    HOUSE_NO TYPE OF D_VARCHAR10 = null,
    Q_FLAT TYPE OF D_INTEGER = null,
    SUBAREA_ID TYPE OF D_UID_NULL = null,
    CHAIRMAN TYPE OF D_VARCHAR50 = null,
    CHAIRMAN_PHONE TYPE OF D_VARCHAR20 = null,
    NOTICE TYPE OF D_NOTICE = null,
    HOUSE_BLB TYPE OF D_UID_NULL = null,
    ORG_ID TYPE OF D_UID_NULL = null,
    POST_INDEX TYPE OF D_VARCHAR6 = null,
    HEADEND_ID TYPE OF D_UID_NULL = null,
    HOUSE_CODE TYPE OF D_VARCHAR6 = null,
    EXIST_TV TYPE OF D_IBOOLEAN = null,
    EXIST_LAN TYPE OF D_IBOOLEAN = null,
    EXIST_DTV TYPE OF D_IBOOLEAN = null,
    WG_ID TYPE OF D_UID_NULL = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE HOUSE_MAP (
    A_HOUSE_ID TYPE OF UID)
RETURNS (
    PORCH_ID TYPE OF UID,
    FLOOR_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PORCH_N TYPE OF D_VARCHAR10,
    FLOOR_N TYPE OF D_VARCHAR10,
    FLAT_N TYPE OF D_FLAT)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE INDICES_REACTIVATE
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE INDICES_REBUILD_SELECTIVITY
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE INDICES_SWITCH (
    ENABLE_FLAG D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE INT2IP (
    INT_IP D_N10)
RETURNS (
    STR_IP D_IP)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE INTTOHEX (
    INPUTNUMBER D_BIGINT)
RETURNS (
    OUTPUTNUMBER D_VARCHAR10)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE IP2INT (
    AIP D_IP)
RETURNS (
    INT_IP D_N10)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MAT_MOVE_DETAILS (
    M_ID TYPE OF UID,
    WH_ID TYPE OF UID,
    SDATE D_DATE,
    EDATE D_DATE)
RETURNS (
    MOVE_DAY D_DATE,
    Q_WH_IN D_N15_5,
    Q_WH_OUT D_N15_5,
    Q_REQ_OUT D_N15_5,
    Q_REQ_IN D_N15_5,
    REQ_OUT D_VARCHAR1000,
    REQ_IN D_VARCHAR1000,
    NOTICE D_VARCHAR255,
    KEEP D_N15_5)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MATERIAL_DOCS_DELETE (
    DOC_ID INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE MATERIAL_REMAIN_RECALC (
    M_ID TYPE OF UID,
    FOR_WH TYPE OF UID = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE MD5 (
    SOURCE BLOB SUB_TYPE 1 SEGMENT SIZE 80)
RETURNS (
    RES CHAR(32) CHARACTER SET OCTETS)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MD5_F (
    A BIGINT,
    B BIGINT,
    C BIGINT,
    D BIGINT,
    K INTEGER,
    S INTEGER,
    T BIGINT,
    P INTEGER,
    V CHAR(64) CHARACTER SET OCTETS)
RETURNS (
    RES BIGINT)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MD5_INTTOCHAR4 (
    V BIGINT)
RETURNS (
    RES CHAR(4) CHARACTER SET OCTETS)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MD5_INTTOHEX (
    V BIGINT)
RETURNS (
    RES CHAR(8) CHARACTER SET OCTETS)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MESSAGE_FOR_CUSTOMER (
    CUSTOMER_ID INT_NULL,
    MES_TYPE D_VARCHAR10,
    MES_HEAD D_VARCHAR255,
    MES_TEXT D_MESSAGE,
    MES_PRIOR D_INTEGER,
    EXT_ID D_VARCHAR50,
    MES_RESULT D_INTEGER = 0)
RETURNS (
    MES_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_ACCOUNT (
    P_ACCOUNT D_ACCOUNT,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_BILL_ACCOUNT (
    P_ACCOUNT D_INTEGER,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_CUSTOMER_ID (
    P_CUSTOMER_ID TYPE OF UID,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE OBJECTS_IUD (
    P_ACTION D_INTEGER,
    O_TYPE D_INTEGER,
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR500 = null,
    O_DESCRIPTION D_NOTICE = null,
    O_DIMENSION D_VARCHAR50 = null,
    O_DELETED D_INTEGER = 0,
    O_CHARFIELD D_VARCHAR1000 = null,
    O_NUMERICFIELD D_N15_3 = null,
    O_DATEFILED D_DATE = null,
    O_DATEEND D_DATE = null,
    O_CHECK D_VARCHAR255 = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ONOFF_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SUBSCR_SERV_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1,
    ADD_SGL D_IBOOLEAN = 1)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE ONOFF_SERVICE_BY_ID (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1,
    ADD_SGL D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE ONOFF_SERVICE_FOR_GROUP (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE OPEN_MATERIAL_DOC (
    DOC_ID UID)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE PAYMENT_ADD_FROM_EXT_SYSTEMS (
    ACCOUNT_NO TYPE OF D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50,
    NOTICE D_NOTICE,
    PAY_TYPE_STR D_VARCHAR30 = 'CASH',
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    IS_DELETED D_IBOOLEAN)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE PAYMENT_DEL_FROM_EXT_SYSTEMS (
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50)
RETURNS (
    RESULT_CODE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE PAYMENT_EXT_STATE (
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DATETIME D_DATETIME,
    IS_DELETED D_IBOOLEAN)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE PAYMENT_INSERT (
    PAYMENT_ID TYPE OF UID,
    PAY_DOC_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE TYPE OF D_DATE,
    PAY_SUM TYPE OF D_N15_2,
    FINE_SUM TYPE OF D_N15_2,
    PAYMENT_TYPE TYPE OF D_UID_NULL,
    NOTICE TYPE OF D_NOTICE,
    PAYMENT_SRV TYPE OF D_UID_NULL,
    EXT_PAY_ID TYPE OF D_VARCHAR50,
    TAG TYPE OF D_INTEGER,
    PAY_DATETIME TYPE OF D_DATETIME,
    NEED_CHECK TYPE OF D_IBOOLEAN,
    CMSN D_N15_2 = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE PAYMENT_SPLIT_INSERT (
    PAY_DOC_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE TYPE OF D_DATE,
    PAY_SUM TYPE OF D_N15_2,
    NOTICE TYPE OF D_NOTICE,
    EXT_PAY_ID TYPE OF D_VARCHAR50,
    FINE_SUM TYPE OF D_N15_2,
    CMSN D_N15_2 = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE PAYMENTTYPE_IUD (
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR50,
    O_DESCRIPTION D_NOTICE,
    P_ACTION D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE PREPAYEXPIRE (
    DAYS D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE QUEUE_SWITCH (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID,
    SWITCH_SRV TYPE OF UID = null,
    UNITS D_N15_2 = 1,
    SWITCH_DATE D_DATE = current_date,
    NOTICE D_NOTICE = null)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE QUEUE_SWITCH_CANCEL (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID = null)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE QUEUE_SWITCH_HANDLE (
    FOR_CUSTOMER_ID TYPE OF UID = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE RECALCCUSTOMERDEBT (
    P_CUSTOMER_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_ADD (
    RQ_TYPE UID,
    RQ_CUSTOMER D_UID_NULL,
    RQ_CONTENT D_NOTICE,
    RQ_NOTICE D_NOTICE,
    RQ_PLAN_DATE D_DATE_NOW,
    RQ_TIME_FROM D_TIME,
    RQ_TIME_TO D_TIME,
    HOUSE_ID UID,
    FLAT_NO D_FLAT,
    PORCH_N D_VARCHAR10,
    FLOOR_N D_VARCHAR10,
    PHONE D_VARCHAR50,
    RQTL_ID D_UID_NULL,
    DOOR_CODE D_VARCHAR20,
    ADD_INFO D_VARCHAR255,
    O_TYPE D_INTEGER = 0)
RETURNS (
    RQ_ID UID)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE REQUEST_ADD_EXECUTORS (
    RQ_ID TYPE OF UID,
    W_ID TYPE OF UID,
    SELECTED D_INTEGER,
    NOTICE D_NOTICE,
    P_ACTION D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_CLOSE_AS (
    RQ_ID TYPE OF UID,
    AS_RQ_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_CLOSE_PROCESS (
    RQ_ID UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_CLOSE_ROLLBACK (
    RQ_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_MATERIALS_IUD (
    RM_ID TYPE OF UID,
    RQ_ID TYPE OF UID,
    M_ID TYPE OF UID,
    RM_QUANT D_N15_5,
    WH_ID TYPE OF UID,
    RM_COST D_N15_2,
    RM_NOTICE D_NOTICE,
    NOT_CALC D_IBOOLEAN,
    P_ACTION D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_MATERIALS_RETURN_IUD (
    ID TYPE OF UID,
    RQ_ID TYPE OF UID,
    M_ID TYPE OF UID,
    QUANT D_N15_5,
    WH_ID TYPE OF UID,
    NOTICE D_NOTICE,
    P_ACTION D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_RECREATE (
    FROM_REQUEST D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_SEND_SMS (
    REQUEST_ID TYPE OF UID,
    SMS D_VARCHAR1000)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUEST_WORKS_IUD (
    RQ_ID UID,
    W_ID UID,
    W_QUANT D_N15_5,
    W_TIME D_N15_3,
    W_COST D_N15_3,
    NOTICE D_DESCRIPTION,
    P_ACTION D_SMALLINT)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUESTGIVE (
    P_REQUEST TYPE OF UID,
    P_DATE D_DATETIME,
    WORKGROUP D_UID_NULL,
    WORKERS D_VARCHAR1000,
    AGIVEAS D_INTEGER = 0)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE REQUESTMOVE (
    P_REQUEST TYPE OF UID,
    P_DATE D_DATETIME)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SELECTONOFFSERVICE (
    ACUSTOMER_ID TYPE OF UID,
    ASERVICE_ID TYPE OF UID,
    ASUBSCR_SERV_ID TYPE OF UID,
    AOFF D_INTEGER)
RETURNS (
    ID TYPE OF UID,
    NAME TYPE OF D_SERVICE_NAME,
    DESCRIPTION D_VARCHAR1000,
    SERVICE_TYPE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE SELECTPAYDOC (
    FORFORM VARCHAR(10) = null)
RETURNS (
    PAY_DOC_ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE SELECTSWITCHSERVICE (
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID)
RETURNS (
    ID TYPE OF UID,
    NAME TYPE OF D_NAME,
    DESCRIPTION D_VARCHAR100,
    SERVICE_TYPE D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE SERVICES_D (
    SERVICE_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SERVICES_IU (
    SERVICE_ID UID,
    SRV_TYPE_ID UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    CALC_TYPE D_INTEGER,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5,
    SHOW_SERVICE D_INTEGER,
    EXPENSE_TYPE D_INTEGER,
    EXTRA D_INTEGER,
    EXTERNAL_ID D_VARCHAR100,
    INET_SRV D_IBOOLEAN,
    IP_BEGIN D_IP,
    IP_END D_IP,
    BUSINESS_TYPE D_INTEGER,
    AUTOOFF D_IBOOLEAN,
    POSITIVE_ONLY D_IBOOLEAN,
    PRIORITY D_INTEGER,
    ONLY_ONE D_IBOOLEAN,
    NOTE D_DESCRIPTION = '',
    TAG D_INTEGER = null,
    TAG_STR D_VARCHAR255 = '',
    OPENLY D_IBOOLEAN = 0,
    UNBL_METH D_INTEGER = 0)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SET_DISTRIB_REPORT (
    DISTRIB_ID D_INTEGER,
    PERIOD D_DATE,
    START_CNT D_INTEGER,
    END_CNT D_INTEGER,
    START_SUM D_N15_2,
    END_SUM D_N15_2,
    V_NUM D_N15_2,
    V_DATE D_DATE,
    V_TEXT D_VARCHAR255,
    NOTICE D_VARCHAR50,
    CONTRACT_ID D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SET_DISTRIB_REPORT_AS_PERIOD (
    PERIOD D_DATE,
    DISTRIB_ID D_INTEGER = null,
    CONTRACT_ID D_INTEGER = null)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SET_FLAT_PF (
    HOUSE_ID INTEGER /* TYPE OF COLUMN HOUSEFLATS.HOUSE_ID */,
    FLAT_NO VARCHAR(100) /* TYPE OF COLUMN HOUSEFLATS.FLAT_NO */,
    PORCH_N VARCHAR(10) /* TYPE OF COLUMN HOUSEFLATS.PORCH_N */,
    FLOOR_N VARCHAR(10) /* TYPE OF COLUMN HOUSEFLATS.FLOOR_N */)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SET_PREPAY (
    CUSTOMER_ID UID,
    PREPAY_SUM D_N15_2)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SET_SETTINGS (
    ANAME D_VARCHAR50,
    AVALUE D_VARCHAR1000)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE SPLIT_STR_TO_ROWS (
    IDS D_VARCHAR1000)
RETURNS (
    ID D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE SWITCH_CANCEL (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE SWITCH_SERVICE (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID,
    SWITCH_SRV TYPE OF UID,
    UNITS D_N15_2,
    SWITCH_DATE D_DATE,
    NOTICE D_NOTICE)
RETURNS (
    RESULT D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER PROCEDURE TARIF_IUD (
    P_TARIF_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_DATE_FROM D_DATE,
    P_DATE_TO D_DATE,
    P_TARIF_SUM D_N15_2,
    P_TARIF_JUR D_N15_2,
    P_ACTION D_INTEGER)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE UPDATE_SERVICES_TREE (
    CUSTOMER_ID TYPE OF UID,
    SERVICE_ID TYPE OF UID)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE UPDATECUSTOMERDEBT4PAY (
    P_CUSTOMER_ID UID,
    P_SUM D_N15_2)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE WORKER_IUD (
    OPERATION D_INTEGER,
    WORKER_ID D_INTEGER,
    SURNAME D_VARCHAR30,
    FIRSTNAME D_VARCHAR30,
    MIDLENAME D_VARCHAR30,
    PHONE_NO D_VARCHAR30,
    NOTICE D_NOTICE,
    WORKING D_SMALLINT,
    IBNAME D_VARCHAR30,
    LOCKEDOUT D_INTEGER,
    ALL_AREAS D_SMALLINT)
AS
BEGIN
  EXIT;
END;





CREATE OR ALTER PROCEDURE YEARWEEK (
    D D_DATE)
RETURNS (
    WEEK_NO D_INTEGER)
AS
BEGIN
  SUSPEND;
END;





CREATE OR ALTER FUNCTION DISTANCE (
    LNG1 D_GEOPOINT,
    LAT1 D_GEOPOINT,
    LNG2 D_GEOPOINT,
    LAT2 D_GEOPOINT)
RETURNS D_INTEGER DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION GET_JSON_VALUE (
    JSON D_PATH,
    PARAM D_VARCHAR50)
RETURNS D_VARCHAR255 DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION GET_SRV_TARIF_FOR_CUSTOMER (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL,
    FOR_DAY D_DATE = null,
    JUR D_INTEGER = null)
RETURNS D_N15_4
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION INET_ATON (
    AIP D_IP)
RETURNS D_N10 DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION INET_NTOA (
    INT_IP D_N10)
RETURNS D_IP DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION MONTH_FIRST_DAY (
    MON_DAY DATE)
RETURNS DATE DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION MONTH_LAST_DAY (
    MON_DAY D_DATE)
RETURNS D_DATE DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;





CREATE OR ALTER FUNCTION ONLY_DIGITS (
    A_VALUE D_VARCHAR255)
RETURNS D_VARCHAR255 DETERMINISTIC
AS
BEGIN
  RETURN NULL;
END;







CREATE TABLE ALL_USED_IP (
    IP      D_IP,
    IP_BIN  D_INT_IP,
    IP_IN   D_VARCHAR50,
    NOTICE  D_NOTICE
);

CREATE TABLE APPLIANCE (
    ID        UID,
    A_TYPE    D_UID_NULL,
    OWN_ID    UID,
    OWN_TYPE  UID DEFAULT 0,
    NAME      D_VARCHAR100,
    NOTICE    D_NOTICE,
    M_ID      D_UID_NULL,
    MAC       D_MAC,
    SN        D_VARCHAR50,
    COST      D_N15_2,
    PROPERTY  D_INTEGER,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE AREA (
    AREA_ID    UID NOT NULL,
    AREA_NAME  D_VARCHAR30,
    NOTICE     D_NOTICE,
    AREA_CODE  D_VARCHAR5
);

CREATE TABLE ATTRIBUTE (
    TYPE_ID    UID NOT NULL,
    OBJECT_ID  UID NOT NULL,
    AID        UID NOT NULL,
    AVALUE     D_VARCHAR100,
    NOTICE     D_NOTICE,
    ADELETED   D_IBOOLEAN,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_DATETIME,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_DATETIME,
    OVALUE     D_VARCHAR100
);

CREATE TABLE BCI_CHANNELS (
    BI_ID   UID,
    CH_ID   UID,
    NOTICE  D_NOTICE
);

CREATE TABLE BCISSUE (
    BI_ID         UID,
    BI_TYPE       UID,
    ISSUE         D_NOTICE,
    DTV           D_IBOOLEAN,
    ATV           D_IBOOLEAN,
    IPTV          D_IBOOLEAN,
    OTT           D_IBOOLEAN,
    SOLUTION      D_INTEGER,
    RESULT_TEXT   D_NOTICE,
    RESULT_ON     D_DATETIME,
    ALTER_CONFIG  D_IBOOLEAN,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME
);

CREATE TABLE BILLING (
    CUSTOMER_ID   UID NOT NULL,
    LOGIN         D_VARCHAR50,
    SECRET        D_VARCHAR100,
    IP_INET       D_IP,
    IP_INET_BIN   D_INT_IP,
    ACCOUNT_ID    D_INTEGER,
    ACCOUNT_NAME  D_VARCHAR50,
    UNIT_ID       D_INTEGER,
    UNIT_NAME     D_VARCHAR50,
    PLAN_ID       D_INTEGER,
    PLAN_NAME     D_VARCHAR50,
    NOTICE        D_NOTICE,
    BLOCKED       D_SMALLINT,
    BLNG_ID       UID NOT NULL,
    SECRET_WEB    D_VARCHAR50,
    VPN           D_IBOOLEAN DEFAULT 0
);

CREATE TABLE BLB_GZIP (
    BLB_ID    UID NOT NULL,
    BL_NAME   D_VARCHAR255,
    NOTICE    D_VARCHAR50,
    BLB_BODY  D_BLOB_GZIP1K
);

CREATE TABLE BLOB_TBL (
    BL_ID     UID NOT NULL,
    BL_TYPE   D_UID_NULL,
    OWNER_ID  D_UID_NULL,
    BL_NAME   D_VARCHAR255,
    NOTICE    D_VARCHAR50,
    BL_BODY   D_BLOB1K
);

CREATE TABLE BONUS_RATE (
    ID          UID NOT NULL,
    BT_ID       UID,
    DATE_FROM   D_DATE NOT NULL,
    DATE_TO     D_DATE,
    UNITS_FROM  D_N15_2,
    UNITS_TO    D_N15_2,
    RATE        D_N15_2,
    NOTICE      D_NOTICE,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME
);

CREATE TABLE CARDS_PREPAY (
    CARD_ID          UID NOT NULL,
    CARD_SERIAL      D_UID_NULL,
    CARD_NUMBER      D_VARCHAR20 NOT NULL,
    CARD_NOMINAL     D_INTEGER default 0 NOT NULL,
    CARD_PIN         D_VARCHAR20,
    EXPIRATION_DATE  D_DATE NOT NULL,
    CARD_STATE       D_SMALLINT default 0 NOT NULL,
    ADDED_BY         D_VARCHAR50,
    ADDED_ON         D_DATE_NOW DEFAULT localtimestamp NOT NULL,
    PAYMENT_ID       D_UID_NULL,
    NOTICE           D_NOTICE
);

CREATE TABLE CARDS_SERIALS (
    CS_ID         UID NOT NULL,
    CS_SERIAL     D_VARCHAR10 NOT NULL,
    CS_SOURCE_ID  D_UID_NULL,
    CS_NOTICE     D_NOTICE
);

CREATE TABLE CHANGELOG (
    LOG_ID        UID NOT NULL,
    LOG_GROUP     D_VARCHAR50,
    OBJECT_TYPE   D_SMALLINT,
    OBJECT_ID     UID,
    PARAM         D_VARCHAR100,
    VALUE_BEFORE  D_VARCHAR1000,
    VALUE_AFTER   D_VARCHAR1000,
    WHO_CHANGE    D_VARCHAR50,
    WHEN_CHANGE   D_DATETIME
);

CREATE TABLE CHANNEL_SRC (
    CS_ID     UID,
    NAME      D_NAME,
    NOTICE    D_NOTICE,
    DEG       D_VARCHAR50,
    URL       D_VARCHAR255,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE CHANNEL_SRC_PARAM (
    CS_ID      UID NOT NULL,
    CH_ID      UID NOT NULL,
    NOTICE     D_NOTICE,
    FREQ       D_VARCHAR50,
    SYMRATE    D_VARCHAR50,
    IP         D_VARCHAR50,
    V_CODEC    D_UID_NULL,
    S_CRYPT    D_UID_NULL,
    CS_SYSTEM  D_UID_NULL,
    CARD_ID    D_UID_NULL,
    ON_ANALOG  D_IBOOLEAN,
    ON_DVB     D_IBOOLEAN,
    ON_IPTV    D_IBOOLEAN,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_DATETIME,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_DATETIME,
    NID        D_INTEGER,
    ONID       D_INTEGER,
    TSID       D_INTEGER,
    SID        D_INTEGER,
    VPID       D_INTEGER,
    APID       D_INTEGER,
    A2PID      D_INTEGER
);

CREATE TABLE CHANNELS (
    CH_ID            UID,
    CH_NUMBER        D_INTEGER,
    CH_NAME          D_NAME,
    CH_NOTICE        D_NOTICE,
    CH_PAID_TO       D_DATE,
    CH_FREQ          D_N15_3 DEFAULT 0,
    CH_CODED         D_IBOOLEAN DEFAULT 0,
    CH_TRUNK         D_INTEGER,
    CH_TRUNK_NUMBER  D_INTEGER,
    CH_CONTACT       D_VARCHAR100,
    DEFINITION       D_VARCHAR5,
    LANG             D_VARCHAR5 DEFAULT 'RUS',
    DVBGENRES        D_VARCHAR255,
    MINAGE           D_INTEGER,
    ACCESS_ID        D_INTEGER,
    ADDED_BY         D_VARCHAR50,
    ADDED_ON         D_DATETIME,
    EDIT_BY          D_VARCHAR50,
    EDIT_ON          D_DATETIME,
    CONTRACT_ID      D_UID_NULL,
    CH_LIC           D_VARCHAR255,
    CH_CERT          D_VARCHAR255,
    CH_THEME         D_VARCHAR50,
    CH_ICON          D_BLOB1K
);

CREATE TABLE CHANNELS_IN_SERVCE (
    SRV_ID  UID NOT NULL,
    CH_ID   UID NOT NULL,
    ON_OFF  D_IBOOLEAN NOT NULL
);

CREATE TABLE CLIENT_FILES (
    FILE_NAME  D_VARCHAR1000,
    FILE_MD5   D_VARCHAR20,
    FILE_BODY  D_BLOB1K
);

CREATE TABLE COMPANY (
    C_CODE         D_VARCHAR20 NOT NULL,
    C_ORDER        D_SMALLINT,
    C_NAME         D_VARCHAR50 NOT NULL,
    C_VALUE        D_VARCHAR255,
    C_TYPE         D_VARCHAR10,
    C_DESCRIPTION  D_VARCHAR100
);

CREATE TABLE CONNECT_LOG (
    CONNECT_DATE     D_TIMESTAMP DEFAULT LOCALTIMESTAMP,
    CONNECT_USER     D_VARCHAR255 DEFAULT CURRENT_USER,
    CONNECT_ADDRESS  D_VARCHAR255,
    CONNECT_EXE      D_VARCHAR255
);

CREATE TABLE CUSTLETTER (
    CUSTLETTERID    UID NOT NULL,
    CUSTOMER_ID     UID,
    LETTERTYPEID    UID,
    CUSTLETTERDATE  D_DATE_NOW,
    ADDED_BY        D_VARCHAR50,
    ADDED_ON        D_DATETIME,
    EDIT_BY         D_VARCHAR50,
    EDIT_ON         D_DATETIME
);

CREATE TABLE CUSTOMER (
    CUSTOMER_ID            UID NOT NULL,
    CUST_CODE              D_VARCHAR20,
    HOUSE_ID               UID,
    ACCOUNT_NO             D_ACCOUNT_NS NOT NULL,
    DOGOVOR_NO             D_VARCHAR50,
    SURNAME                D_VARCHAR100,
    FIRSTNAME              D_VARCHAR50,
    MIDLENAME              D_VARCHAR50,
    INITIALS               D_VARCHAR10,
    CONTRACT_DATE          D_DATE_NOW,
    ACTIVIZ_DATE           D_DATE,
    PHONE_NO               D_VARCHAR50,
    NOTICE                 D_NOTICE,
    VALID_TO               D_DATE,
    CUST_STATE             D_INTEGER DEFAULT 0 NOT NULL,
    CUST_STATE_DESCR       D_VARCHAR500,
    CUST_PROP              D_VARCHAR500,
    CUST_PROP_DESCR        D_VARCHAR10,
    FLAT_NO                D_FLAT_NS,
    DEBT_SUM               D_N15_2 DEFAULT 0 NOT NULL,
    PASSPORT_NUMBER        D_VARCHAR50,
    PASSPORT_REGISTRATION  D_VARCHAR255,
    PERSONAL_N             D_VARCHAR50,
    MANAGER_ID             D_UID_NULL,
    JURIDICAL              D_IBOOLEAN DEFAULT 0,
    JUR_INN                D_VARCHAR100,
    JUR_DIRECTOR           D_VARCHAR100,
    JUR_BUH                D_VARCHAR100,
    CGIS                   D_INTEGER DEFAULT 0,
    MOBILE_PHONE           D_VARCHAR50,
    HIS_COLOR              D_VARCHAR10,
    INVISIBLE              D_IBOOLEAN DEFAULT 0,
    EMAIL                  D_VARCHAR50,
    TIME_ON_MINUS          D_TIMESTAMP,
    BIRTHDAY               D_DATE,
    ADRES_REGISTR          D_VARCHAR255,
    ORG_ID                 D_UID_NULL,
    VATG_ID                D_UID_NULL,
    FLAT_DIGIT             D_INTEGER,
    TAP                    D_INTEGER,
    PREPAY                 D_N15_2 DEFAULT 0,
    PREPAY_TIME            D_DATETIME,
    SECRET                 D_VARCHAR255,
    ADDED_BY               D_VARCHAR50,
    ADDED_ON               D_DATETIME,
    EDIT_BY                D_VARCHAR50,
    EDIT_ON                D_DATETIME,
    HAND_CONTROL           D_IBOOLEAN,
    BANK                   D_VARCHAR500,
    BANK_ACCOUNT           D_VARCHAR30,
    EXTERNAL_ID            D_VARCHAR20,
    PASSPORT_VALID         D_ICHECK,
    CONTRACT_BASIS         D_VARCHAR255,
    BANK_ID                D_UID_NULL
);

CREATE TABLE CUSTOMER_ACCOUNTS (
    CA_ID         UID,
    CUSTOMER_ID   UID,
    CA_DATE_FROM  D_DATE,
    CA_DATE_TO    D_DATE,
    CD_NOTICE     D_NOTICE
);

CREATE TABLE CUSTOMER_ATTRIBUTES (
    CA_ID        UID,
    CUSTOMER_ID  UID NOT NULL,
    O_ID         UID NOT NULL,
    CA_VALUE     D_VARCHAR100 NOT NULL,
    NOTICE       D_NOTICE,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME,
    RQ_ID        D_UID_NULL
);

CREATE TABLE CUSTOMER_BONUSES (
    ID             UID,
    CUSTOMER_ID    UID NOT NULL,
    CUSTOMER_DEBT  D_N15_2,
    BONUS_DATE     D_DATE,
    BT_ID          UID NOT NULL,
    UNITS          D_N15_2,
    BONUS          D_N15_2 NOT NULL,
    NOTICE         D_NOTICE,
    EXT_ID         D_UID_NULL,
    ADDED_BY       D_VARCHAR50,
    ADDED_ON       D_DATETIME,
    EDIT_BY        D_VARCHAR50,
    EDIT_ON        D_DATETIME
);

CREATE TABLE CUSTOMER_CHANNELS (
    CH_ID       UID NOT NULL,
    DATE_ON     D_DATE,
    DATE_OFF    D_DATE,
    NOTICE      D_NOTICE,
    DECODER_ID  UID NOT NULL,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME
);

CREATE TABLE CUSTOMER_CONTACTS (
    CUSTOMER_ID     UID NOT NULL,
    CC_VALUE        D_VARCHAR255 NOT NULL,
    CC_TYPE         D_INTEGER DEFAULT 0,
    CC_NOTIFY       D_IBOOLEAN DEFAULT 0,
    CC_NOTICE       D_NOTICE,
    CC_VAL_REVERSE  D_VARCHAR255,
    ADDED_BY        D_VARCHAR50,
    ADDED_ON        D_DATETIME,
    EDIT_BY         D_VARCHAR50,
    EDIT_ON         D_DATETIME
);

CREATE TABLE CUSTOMER_DECODERS (
    DEC_ID       UID NOT NULL,
    CUSTOMER_ID  UID,
    DECODER_N    D_DECODER NOT NULL,
    STB_N        D_VARCHAR50,
    TV_MODEL     D_VARCHAR50,
    TV_SOFT      D_VARCHAR50,
    PAIRING      D_IBOOLEAN,
    NOTICE       D_NOTICE,
    LAST_UPDATE  D_DATETIME,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE CUSTOMER_EQUIPMENT (
    CE_ID        UID NOT NULL,
    CUSTOMER_ID  UID,
    EQUIP_N      D_DECODER NOT NULL,
    SALE         D_IBOOLEAN,
    NOTICE       D_NOTICE,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE CUSTOMER_FILES (
    CF_ID        UID,
    CUSTOMER_ID  UID,
    NAME         D_VARCHAR255,
    CF_TYPE      UID DEFAULT 0 NOT NULL,
    DATE_FROM    D_DATE,
    DATE_TO      D_DATE,
    FILENAME     D_VARCHAR255,
    NOTICE       D_NOTICE,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME,
    ACT          D_IBOOLEAN DEFAULT 0,
    ANOTICE      D_NOTICE,
    CONTENT      D_BLOB1K
);

CREATE GLOBAL TEMPORARY TABLE DAYS_TARIF (
    SERV_ID    UID,
    T_DAY      D_DATE NOT NULL,
    TARIF      D_DAY_TARIF DEFAULT 0,
    TARIF_JUR  D_DAY_TARIF
) ON COMMIT DELETE ROWS;

CREATE TABLE DECODER_PACKETS (
    DECODER_N   D_DECODER NOT NULL,
    SERVICE_ID  UID NOT NULL,
    NOTICE      D_NOTICE,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME
);

CREATE TABLE DEVICES (
    ID           UID NOT NULL,
    "TYPE"       D_VARCHAR50,
    SUBTYPE      D_VARCHAR50,
    LOGIN        D_VARCHAR50,
    "PASSWORD"   D_VARCHAR50,
    SSID         D_VARCHAR50,
    PSK          D_VARCHAR50,
    IP           D_IP,
    COMMUNITY    D_VARCHAR50,
    OBJECT       D_BIGINT,
    NAME         D_VARCHAR100,
    FIRMNAME     D_VARCHAR50,
    COLORSCHEME  D_VARCHAR50,
    NODE1        D_INTEGER,
    NODE2        D_INTEGER,
    NUMPORTS     D_SMALLINT DEFAULT 0,
    BANDLEPORTS  D_INTEGER DEFAULT 0,
    MACADDRESS   D_MAC,
    NOTE         D_VARCHAR500,
    MODIFIED     D_TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE DEVPORTS (
    ID        UID NOT NULL,
    DEVICE    UID NOT NULL,
    NUMBER    D_SMALLINT,
    NODE      UID NOT NULL,
    LINK      D_INTEGER,
    LINK1     D_INTEGER,
    SNMP_ID   D_SMALLINT,
    NAME      D_VARCHAR30,
    PORTTYPE  D_VARCHAR20,
    MODULE    D_VARCHAR30,
    COLOR     D_VARCHAR30,
    COLOROPT  D_VARCHAR30 DEFAULT 'solid',
    BANDLE    D_VARCHAR30,
    NOTE      D_VARCHAR500,
    DIVIDE    D_N15_2,
    MODIFIED  D_TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE DEVPROFILES (
    ID         UID NOT NULL,
    NAME       D_VARCHAR150,
    PORT       D_SMALLINT,
    RUCOLOR    D_VARCHAR50,
    COLOR      D_VARCHAR50,
    "OPTION"   D_VARCHAR30,
    HTMLCOLOR  D_VARCHAR30
);

CREATE TABLE DISCOUNT_FACTOR (
    DISCOUNT_ID   UID,
    CUSTOMER_ID   UID,
    DATE_FROM     D_DATE_NOW NOT NULL,
    DATE_TO       D_DATE_NOW NOT NULL,
    FACTOR_VALUE  D_N15_4 NOT NULL,
    SERV_ID       UID DEFAULT -1,
    SRV_TYPE      UID DEFAULT -1,
    NOTICE        D_NOTICE,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME
);

CREATE TABLE DISTRIB_CARDS (
    DISTRIBUTOR_ID  UID,
    CARD            D_VARCHAR50,
    NOTICE          D_VARCHAR500
);

CREATE TABLE DISTRIB_CONTRACT_CH (
    CONTRACT_ID  UID,
    CH_ID        UID,
    COST         D_N15_2,
    CUST_COUNT   D_INTEGER,
    DTV          D_IBOOLEAN,
    ATV          D_IBOOLEAN,
    IPTV         D_IBOOLEAN,
    OTT          D_IBOOLEAN,
    NOTICE       D_VARCHAR500
);

CREATE TABLE DISTRIB_CONTRACT_REPORTS (
    CONTRACT_ID  UID,
    PERIOD       D_DATE NOT NULL,
    START_CNT    D_INTEGER,
    END_CNT      D_INTEGER,
    START_SUM    D_N15_2,
    END_SUM      D_N15_2,
    V_NUM        D_N15_2,
    V_DATE       D_DATE,
    V_TEXT       D_VARCHAR255,
    NOTICE       D_VARCHAR50
);

CREATE TABLE DISTRIB_CONTRACT_REPORTS_CH (
    CONTRACT_ID  UID,
    PERIOD       D_DATE NOT NULL,
    CH_ID        UID,
    START_CNT    D_INTEGER,
    END_CNT      D_INTEGER,
    START_SUM    D_N15_2,
    END_SUM      D_N15_2,
    NOTICE       D_VARCHAR50
);

CREATE TABLE DISTRIB_CONTRACTS (
    ID              UID,
    DISTRIBUTOR_ID  UID,
    C_NUMBER        D_VARCHAR50,
    C_DATE          D_DATE,
    C_DATE_BEFORE   D_DATE,
    REPORT_FRMT     D_VARCHAR10,
    DELIVERY        D_INTEGER,
    FINTERMS        D_N15_2,
    MINTERMS        D_INTEGER,
    REPORT_ID       D_UID_NULL,
    CTYPE           D_VARCHAR20,
    NOTICE          D_VARCHAR500
);

CREATE TABLE DISTRIBUTOR (
    ID        UID,
    NAME      D_VARCHAR100,
    ADDRESS   D_DESCRIPTION,
    JADDRESS  D_DESCRIPTION,
    EMAIL     D_VARCHAR100,
    PHONES    D_VARCHAR100,
    NOTICE    D_DESCRIPTION
);

CREATE TABLE DVB_NETWORK (
    DVBN_ID      UID,
    NAME         D_VARCHAR20,
    NOTICE       D_NOTICE,
    ONID         D_INTEGER,
    NID          D_INTEGER,
    PIDS         D_VARCHAR100,
    DESCRIPTORS  D_VARCHAR500,
    TIMEOFFSET   D_INTEGER,
    LANG         D_VARCHAR5,
    COUNTRY      D_VARCHAR5,
    EPG_UPDATED  D_DATETIME,
    AOSTRM       D_INTEGER
);

CREATE TABLE DVB_STREAM_CHANNELS (
    DVBS_ID  UID,
    CH_ID    UID,
    SID      D_INTEGER,
    LCN      D_INTEGER,
    NOTICE   D_NOTICE,
    TSID     D_INTEGER,
    VPID     D_INTEGER,
    APID     D_INTEGER,
    A2PID    D_INTEGER,
    BITRATE  D_N15_2,
    CONID    D_INTEGER,
    CNID     D_INTEGER
);

CREATE TABLE DVB_STREAMS (
    DVBN_ID      UID,
    DVBS_ID      UID,
    NAME         D_VARCHAR20,
    ES_IP        D_IP,
    ES_PORT      D_INTEGER,
    BITRATE      D_N15_2,
    NOTICE       D_NOTICE,
    TSID         D_INTEGER,
    QAM          D_INTEGER,
    FREQ         D_INTEGER,
    EPG_UPDATED  D_DATETIME,
    ONID         D_INTEGER,
    AOSTRM       D_IBOOLEAN
);

CREATE TABLE EPG (
    EPG_ID       D_UID_NULL,
    CH_ID        UID,
    EPG_DATE     D_DATE,
    UTC_DATE     D_DATE,
    DATE_START   D_TIMESTAMP NOT NULL,
    DATE_STOP    D_TIMESTAMP,
    UTC_START    D_TIMESTAMP,
    UTC_STOP     D_TIMESTAMP,
    DURATION     D_INTEGER,
    TITLE        D_VARCHAR255,
    DESCRIPTION  D_EIT_EVENT,
    GENRES       D_VARCHAR255,
    DVBGENRES    D_VARCHAR255,
    MINAGE       D_INTEGER default 0,
    CREATE_YEAR  D_VARCHAR255,
    ACTORS       D_VARCHAR255,
    DIRECTED     D_VARCHAR255,
    COUNTRY      D_VARCHAR255
);

CREATE TABLE EPG_AD (
    ID              UID,
    START_TIME      D_DATETIME,
    STOP_TIME       D_DATETIME,
    AD_TITLE        D_VARCHAR100,
    AD_DESCRIPTION  D_VARCHAR1000,
    ALL_CHAN        D_IBOOLEAN DEFAULT 0,
    FOR_EMPTY       D_IBOOLEAN
);

CREATE TABLE EPG_AD_CHANNELS (
    EA_ID  UID,
    CH_ID  UID
);

CREATE TABLE EPG_GENRE (
    GENRE_ID     UID,
    GENRE        D_VARCHAR255,
    SUBGENRE     D_VARCHAR1000,
    DVB_ID       D_VARCHAR5,
    DVBGENRE     D_VARCHAR255,
    DVBSUBGENRE  D_VARCHAR1000
);

CREATE TABLE EPG_LOCAL (
    CH_ID        UID,
    DATE_START   D_TIMESTAMP NOT NULL,
    EPG_DATE     D_DATE,
    TITLE        D_VARCHAR255,
    DURATION     D_INTEGER,
    DATE_STOP    D_TIMESTAMP,
    DESCRIPTION  D_EIT_EVENT,
    GENRES       D_VARCHAR255,
    DVBGENRES    D_VARCHAR255,
    MINAGE       D_INTEGER default 0,
    CREATE_YEAR  D_VARCHAR10,
    ACTORS       D_VARCHAR255,
    DIRECTED     D_VARCHAR255,
    COUNTRY      D_VARCHAR255,
    UTC_DATE     D_DATE,
    UTC_START    D_TIMESTAMP,
    UTC_STOP     D_TIMESTAMP
);

CREATE TABLE EPG_MAPPING (
    EPG_ID    UID,
    CH_ID     UID,
    EPG_CODE  D_VARCHAR100
);

CREATE TABLE EPG_MAPPING_GENRE (
    EPG_ID        UID,
    GENRE_ID      UID,
    SOURCE_GENRE  D_VARCHAR255
);

CREATE TABLE EPG_SOURCES (
    ID           UID,
    NAME         D_VARCHAR100,
    URL          D_VARCHAR255,
    NOTICE       D_NOTICE,
    TIME_SHIFT   D_INTEGER DEFAULT 0,
    PARSEAS      D_VARCHAR20,
    URLLOGIN     D_VARCHAR50,
    URLPASSWORD  D_VARCHAR50,
    LOCAL_TZONE  D_IBOOLEAN,
    LOCAL_FILE   D_VARCHAR500,
    HAND_ONLY    D_IBOOLEAN
);

CREATE TABLE EQUIPMENT (
    EID               UID NOT NULL,
    HOUSE_ID          D_UID_NULL,
    NAME              D_NAME,
    IP                D_IP,
    MAC               D_MAC,
    NOTICE            D_NOTICE,
    EQ_TYPE           D_INTEGER DEFAULT 0,
    PORCH_N           D_VARCHAR10,
    FLOOR_N           D_VARCHAR10,
    MASK              D_IP,
    VLAN_ID           D_UID_NULL,
    IP_BIN            D_INT_IP,
    PLACE             D_VARCHAR50,
    EQ_GROUP          D_UID_NULL,
    E_ADMIN           D_VARCHAR20,
    E_PASS            D_VARCHAR20,
    LAST_UPDATE       D_DATETIME,
    SERIAL_N          D_VARCHAR100,
    PARENT_ID         D_UID_NULL,
    PARENT_PORT       D_PORT_NS,
    ADDED_BY          D_VARCHAR50,
    ADDED_ON          D_DATETIME,
    EDIT_BY           D_VARCHAR50,
    EDIT_ON           D_DATETIME,
    EQ_LINE           D_SMALLINT,
    SIGNAL_IN         D_N15_5,
    SIGNAL_OUT        D_N15_5,
    EQ_ACTIVE         D_IBOOLEAN,
    EQ_DELIVERY_DATE  D_DATE,
    EQ_DELIVERY_COST  D_N15_2,
    EQ_REGNUBER       D_VARCHAR10,
    IPV6              D_IPV6,
    NODE_ID           D_UID_NULL
);

CREATE TABLE EQUIPMENT_ATTRIBUTES (
    EA_ID     UID NOT NULL,
    EID       UID,
    O_ID      UID,
    CA_VALUE  D_VARCHAR100,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE EQUIPMENT_CMD_GRP (
    EC_ID     UID NOT NULL,
    EG_ID     UID DEFAULT -1 NOT NULL,
    NAME      D_VARCHAR100,
    COMMAND   D_VARCHAR1000,
    NOTICE    D_NOTICE,
    CMD_TYPE  D_INTEGER,
    IN_GUI    D_IBOOLEAN DEFAULT 0,
    EOL_CHRS  D_VARCHAR6 DEFAULT '\r\n',
    URL       D_VARCHAR255,
    AUT_USER  D_VARCHAR50,
    AUT_PSWD  D_VARCHAR50
);

CREATE TABLE EQUIPMENT_COVERAGE (
    EID       UID NOT NULL,
    HOUSE_ID  UID NOT NULL,
    NOTICE    D_NOTICE
);

CREATE TABLE EQUIPMENT_DVB (
    EQ_ID        UID,
    EQ_TYPE      D_INTEGER DEFAULT 0 NOT NULL,
    EQ_N         D_DECODER NOT NULL,
    EQ_STATE     D_INTEGER,
    EQ_MAN       D_INTEGER,
    NOTICE       D_NOTICE,
    TEXT_ENCODE  D_VARCHAR5,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME
);

CREATE TABLE EQUIPMENT_HISTORY (
    EQ_N         D_DECODER,
    CUSTOMER_ID  D_UID_NULL,
    EQ_STATE     D_INTEGER,
    OLD_STATE    D_INTEGER,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE EQUIPMENT_LOG (
    EQ_ID     UID NOT NULL,
    LOG_DATE  D_DATETIME,
    LINE_N    D_INTEGER,
    LINE      D_VARCHAR1000,
    INT1      D_INTEGER,
    INT2      D_INTEGER,
    STR1      D_VARCHAR255,
    STR2      D_VARCHAR255
);

CREATE TABLE EVENT_DETAIL (
    CUSTOMER_ID  UID,
    EVENT_ID     UID,
    E_DATE       D_DATE,
    E_YEAR       D_INTEGER,
    E_MONTH      D_SMALLINT,
    E_DAY        D_SMALLINT,
    E_COUNT      D_BYTES,
    E_MONEY      D_N15_2,
    EXT_ID       D_VARCHAR50
);

CREATE TABLE EXPORTTYPES (
    NAME           D_NAME NOT NULL,
    FILE_FORMAT    D_INTEGER,
    FILE_CODEPAGE  D_INTEGER,
    FILE_DIR       D_NOTICE,
    NOTICE         D_NOTICE,
    FILENAME       D_VARCHAR100,
    FILE_HEAD      D_NOTICE,
    FILE_BODY      D_NOTICE,
    FILE_FOOTER    D_NOTICE,
    SEPARATOR      D_CHAR1 DEFAULT '.'
);

CREATE TABLE FREQPLAN (
    FQ_ID     UID,
    WAVE      D_VARCHAR5,
    NAME      D_NAME,
    LOW_FQ    D_N15_2,
    HIGH_FQ   D_N15_2,
    VIDEO     D_N15_2,
    SOUND     D_N15_2,
    DTV       D_N15_2,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE GPS_LOG (
    WORKER    D_VARCHAR30,
    GPS_TIME  D_DATETIME,
    LAT       D_GEOPOINT,
    LON       D_GEOPOINT
);

CREATE TABLE HEADEND (
    HE_ID      UID NOT NULL,
    HE_NAME    D_VARCHAR50 NOT NULL,
    HOUSE_ID   UID,
    HE_PLACE   D_VARCHAR20,
    HE_TYPE    D_UID_NULL,
    NOTICE     D_NOTICE,
    PARENT_ID  D_UID_NULL
);

CREATE TABLE HEADEND_CHANNELS (
    CH_ID      UID NOT NULL,
    HE_ID      UID NOT NULL,
    CH_FREQ    D_N15_3,
    CH_NUMBER  D_INTEGER
);

CREATE TABLE HOUSE (
    HOUSE_ID        UID NOT NULL,
    STREET_ID       UID NOT NULL,
    HOUSE_NO        D_VARCH20_NS,
    Q_FLAT          D_INTEGER,
    SUBAREA_ID      D_UID_NULL,
    CHAIRMAN        D_VARCHAR50,
    CHAIRMAN_PHONE  D_VARCHAR20,
    NOTICE          D_NOTICE,
    HOUSE_BLB       D_UID_NULL,
    ORG_ID          D_UID_NULL,
    POST_INDEX      D_VARCHAR6,
    MAP_FLATS       D_INTEGER,
    MAP_WIDTH       D_INTEGER,
    MAP_HEIGHT      D_INTEGER,
    HEADEND_ID      D_UID_NULL,
    HOUSE_CODE      D_VARCHAR6,
    EXIST_TV        D_IBOOLEAN DEFAULT 1,
    EXIST_LAN       D_IBOOLEAN DEFAULT 1,
    EXIST_DTV       D_IBOOLEAN DEFAULT 1,
    WG_ID           D_UID_NULL,
    IN_DATE         D_DATE,
    REPAIR_DATE     D_DATE,
    LATITUDE        D_GEOPOINT,
    LONGITUDE       D_GEOPOINT,
    TAG             D_INTEGER,
    ADDED_BY        D_VARCHAR50,
    ADDED_ON        D_DATETIME,
    EDIT_BY         D_VARCHAR50,
    EDIT_ON         D_DATETIME
);

CREATE TABLE HOUSE_CIRCUIT (
    HC_ID     UID NOT NULL,
    HOUSE_ID  UID,
    NAME      D_NAME,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME,
    PNG       D_BLOB1K,
    CIRCUIT   D_BLOB1K
);

CREATE TABLE HOUSEFLATS (
    HOUSE_ID    UID NOT NULL,
    FLAT_NO     D_FLAT_NS,
    PORCH_N     D_VARCH10_NS,
    FLOOR_N     D_VARCH10_NS,
    NOTICE      D_NOTICE,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME,
    FLAT_DIGIT  D_INTEGER,
    NAME        D_VARCHAR100,
    PHONE       D_VARCHAR30,
    STATE       D_VARCHAR1000,
    MOBILE      D_VARCHAR30
);

CREATE TABLE HOUSEFLOOR (
    FLOOR_ID   UID NOT NULL,
    PORCH_ID   UID,
    FLOOR_N    D_VARCH10_NS,
    FLAT_FROM  D_FLAT_NS,
    FLAT_TO    D_FLAT_NS,
    NOTICE     D_NOTICE,
    FLATS      D_VARCHAR1000
);

CREATE TABLE HOUSEPORCH (
    PORCH_ID   UID NOT NULL,
    HOUSE_ID   UID,
    PORCH_N    D_VARCH10_NS,
    FLOORS     D_SMALLINT DEFAULT 1,
    GARRET     D_IBOOLEAN DEFAULT 1,
    CELLAR     D_IBOOLEAN DEFAULT 1,
    FLAT_FROM  D_FLAT_NS,
    FLAT_TO    D_FLAT_NS,
    NOTICE     D_NOTICE
);

CREATE TABLE HOUSES_ATTRIBUTES (
    HA_ID     UID,
    HOUSE_ID  UID NOT NULL,
    O_ID      UID NOT NULL,
    HA_VALUE  D_VARCHAR100 NOT NULL,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE HOUSEWORKS (
    HW_ID       UID NOT NULL,
    HOUSE_ID    UID,
    DATE_PPR    D_DATE_NOW NOT NULL,
    WORKER_PPR  D_INTEGER,
    NOTICE      D_NOTICE
);

CREATE TABLE INVENTORY (
    OWNER       UID NOT NULL,
    OWNER_TYPE  UID NOT NULL,
    M_ID        UID,
    SERIAL      D_VARCHAR50 NOT NULL,
    OWNERSHIP   D_UID_NULL,
    QUANT       D_N15_5,
    NOTICE      D_NOTICE,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME
);

CREATE TABLE IPTV_GROUP (
    IG_ID     UID,
    NAME      D_VARCHAR20,
    CODE      D_VARCHAR20,
    URL       D_VARCHAR255,
    DISABLED  D_IBOOLEAN DEFAULT 0,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE IPTV_GROUP_ATTRIBUTES (
    IGA_ID    UID,
    IG_ID     UID,
    O_ID      UID,
    CA_VALUE  D_VARCHAR100,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE IPTV_GROUP_CHANNELS (
    IG_ID     UID,
    CH_ID     UID,
    LCN       D_INTEGER,
    CODE      D_VARCHAR20,
    URL       D_VARCHAR255,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE JOURNAL (
    J_ID      UID,
    J_DATE    D_DATETIME,
    J_NOTICE  D_VARCHAR1000,
    J_WHOM    D_VARCHAR10,
    J_TYPE    D_VARCHAR100
);

CREATE TABLE LETTERTYPE (
    LETTERTYPEID     UID,
    LETTERTYPEDESCR  D_VARCHAR30,
    FILENAME         D_VARCHAR500,
    RECORDINDB       D_IBOOLEAN,
    FOR_FORM         D_SMALLINT DEFAULT 0,
    SAVE_PDF         D_IBOOLEAN
);

CREATE TABLE MAP (
    ID         UID NOT NULL,
    MODIFIED   D_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    NAME       D_VARCHAR100,
    O_TYPE     D_VARCHAR50,
    SUBTYPE    D_VARCHAR50,
    RAYON      D_SMALLINT,
    ADDRESS    D_VARCHAR100,
    GTYPE      D_VARCHAR50,
    "LENGTH"   D_N15_5 DEFAULT 0.00000,
    HOSTNAME   D_VARCHAR100,
    SERVICE    D_VARCHAR100,
    MRTG       D_VARCHAR100,
    CONNECTED  D_N10,
    NOTE       D_VARCHAR500
);

CREATE TABLE MAP_LOG (
    UNIQUE_ID    UID,
    ACT_DATE     D_DATETIME,
    ACT_USER     D_VARCHAR500,
    ACT_ADMIN    D_VARCHAR500,
    ACT_UID      INTEGER,
    ACT_ACTION   D_VARCHAR500,
    ACT_CONTENT  D_VARCHAR500
);

CREATE TABLE MAP_XY (
    ID        UID NOT NULL,
    OBJECT    UID NOT NULL,
    SLICE     D_INTEGER DEFAULT 0,
    NUM       D_INTEGER DEFAULT 0,
    X         D_GEOPOINT NOT NULL,
    Y         D_GEOPOINT NOT NULL,
    MODIFIED  D_TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE MATERIAL_DOCS (
    DOC_ID      UID NOT NULL,
    DOC_N       D_VARCHAR50,
    DOC_DATE    D_DATE,
    DT_ID       UID,
    NOTICE      D_NOTICE,
    WH_ID       D_UID_NULL,
    DOC_CLOSED  D_INTEGER DEFAULT 0,
    EXT_ID      D_VARCHAR20,
    FROM_WH     D_UID_NULL,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME,
    SHIPPER     D_UID_NULL
);

CREATE TABLE MATERIAL_UNIT (
    SERIAL      D_VARCHAR50 NOT NULL,
    M_ID        UID,
    OWNER       D_UID_NULL,
    OWNER_TYPE  D_UID_NULL,
    STATE       D_UID_NULL,
    NOTICE      D_NOTICE,
    MAC         D_MAC,
    DOC_INCOME  D_UID_NULL,
    COST        D_N15_2,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME,
    S_VERSION   D_VARCHAR50
);

CREATE TABLE MATERIALS (
    M_ID             UID NOT NULL,
    NAME             D_VARCHAR100,
    DIMENSION        D_VARCHAR10,
    DESCRIPTION      D_NOTICE,
    DELETED          D_IBOOLEAN DEFAULT 0,
    MG_ID            D_UID_NULL,
    M_NUMBER         D_VARCHAR20,
    ROUND_TO         D_INTEGER,
    COST             D_N15_2,
    BEST_COST        D_N15_2,
    BEST_SHIPPER_ID  D_UID_NULL,
    DEMENSION        D_VARCHAR10,
    IS_UNIT          D_IBOOLEAN DEFAULT 0,
    IS_DIGIT         D_IBOOLEAN DEFAULT 0,
    IS_NET           D_IBOOLEAN DEFAULT 0,
    ADDED_BY         D_VARCHAR50,
    ADDED_ON         D_DATETIME,
    EDIT_BY          D_VARCHAR50,
    EDIT_ON          D_DATETIME,
    M_TYPE           D_UID_NULL
);

CREATE TABLE MATERIALS_GROUP (
    MG_ID      UID NOT NULL,
    MG_NAME    D_VARCHAR50,
    PARENT_ID  D_UID_NULL,
    MG_NOTICE  D_NOTICE
);

CREATE TABLE MATERIALS_IN_DOC (
    ID            UID,
    DOC_ID        UID,
    M_ID          UID,
    M_QUANT       D_N15_5,
    M_COST        D_N15_2,
    M_NOTICE      D_NOTICE,
    SHIPPER_COST  D_N15_3,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME,
    B_QUANT       D_N15_5,
    TTN           D_INTEGER
);

CREATE TABLE MATERIALS_IN_DOC_UNIT (
    DOC_ID    UID,
    M_ID      UID,
    SERIAL    D_VARCHAR50 NOT NULL,
    M_NOTICE  D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE MATERIALS_REMAIN (
    M_ID       UID,
    WH_ID      UID,
    MR_QUANT   D_N15_5,
    MR_COST    D_N15_2,
    INVENTORY  D_DATE
);

CREATE TABLE MESSAGE_TPL (
    MT_ID     UID,
    MT_NAME   D_VARCHAR20,
    MES_HEAD  D_VARCHAR20,
    MES_TEXT  D_MESSAGE,
    MES_TYPE  D_VARCHAR10,
    NOTICE    D_NOTICE
);

CREATE TABLE MESSAGES (
    MES_ID         UID,
    CUSTOMER_ID    INT_NULL,
    MES_TYPE       D_VARCHAR10 DEFAULT 'SMS',
    RECIVER        D_VARCHAR255,
    MES_HEAD       D_VARCHAR255,
    MES_TEXT       D_MESSAGE,
    MES_RESULT     D_INTEGER DEFAULT 0,
    SEND_DATE      D_DATETIME,
    ADDED_ON       D_DATETIME,
    ADDED_BY       D_VARCHAR50,
    MES_PRIOR      D_INTEGER DEFAULT 0,
    EXT_ID         D_VARCHAR50,
    TPL_ID         D_UID_NULL,
    INFO_PERIOD    D_INTEGER,
    INFO_INTERVAL  D_INTEGER,
    TAG            D_VARCHAR255
);

CREATE TABLE MODULES (
    ID_MODULE  UID NOT NULL,
    ID_PARENT  D_UID_NULL,
    NAME       D_VARCHAR255,
    NOTICE     D_NOTICE,
    LANG       D_INTEGER,
    IN_MENU    D_IBOOLEAN DEFAULT 1,
    MODULE     D_BLOB1K
);

CREATE TABLE MONTH_NAME (
    MID    D_INTEGER,
    MNAME  D_VARCHAR20,
    RNAME  D_VARCHAR20
);

CREATE TABLE MONTHLY_FEE (
    MONTH_ID     D_DATE NOT NULL,
    CUSTOMER_ID  UID,
    SERVICE_ID   UID,
    UNITS        D_N15_2,
    FEE          D_N15_2,
    VAT_TAX      D_N15_2 DEFAULT 0,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE MONTHLY_FREEZE (
    MONTH_ID      D_DATE NOT NULL,
    CUSTOMER_ID   UID,
    SERVICE_ID    UID,
    UNITS         D_N15_2,
    FEE           D_N15_2,
    EXPENSE_TYPE  D_SMALLINT DEFAULT 0 NOT NULL,
    VAT_TAX       D_N15_2 DEFAULT 0,
    ADDED_ON      D_DATE,
    TAG_INT       D_INTEGER,
    TAG_STR       D_VARCHAR10
);

CREATE TABLE NODE_FILES (
    NF_ID      UID,
    NODE_ID    UID,
    NAME       D_VARCHAR255,
    NF_TYPE    UID DEFAULT 0 NOT NULL,
    DATE_FROM  D_DATE,
    DATE_TO    D_DATE,
    FILENAME   D_VARCHAR255,
    NOTICE     D_NOTICE,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_DATETIME,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_DATETIME,
    CONTENT    D_BLOB1K
);

CREATE TABLE NODE_FLATS (
    NODE_ID   UID NOT NULL,
    HOUSE_ID  UID NOT NULL,
    FLAT_NO   D_FLAT_NS,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE NODE_LAYOUT (
    NODE_ID  UID,
    M_TYPE   UID,
    DEV_CNT  D_N15_2,
    NOTICE   D_NOTICE
);

CREATE TABLE NODES (
    NODE_ID    UID NOT NULL,
    HOUSE_ID   UID NOT NULL,
    TYPE_ID    D_INTEGER,
    NAME       D_VARCHAR50,
    NOTICE     D_VARCHAR500,
    LAT        D_GEOPOINT,
    LON        D_GEOPOINT,
    FLOOR_N    D_VARCHAR10,
    PORCH_N    D_VARCHAR10,
    PLACE      D_VARCHAR50,
    PARENT_ID  D_UID_NULL,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_DATETIME,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_DATETIME
);

CREATE TABLE NODES_ATTRIBUTES (
    NA_ID     UID,
    NODE_ID   UID NOT NULL,
    O_ID      UID NOT NULL,
    NA_VALUE  D_VARCHAR100 NOT NULL,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE NPS (
    NPS_DATE     D_DATE NOT NULL,
    CUSTOMER_ID  UID,
    RATING       D_SMALLINT NOT NULL,
    NOTICE       D_NOTICE,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE OBJECTS (
    O_ID            UID NOT NULL,
    O_TYPE          UID NOT NULL,
    O_NAME          D_DESCRIPTION NOT NULL,
    O_DESCRIPTION   D_DESCRIPTION,
    O_DELETED       D_INTEGER DEFAULT 0,
    O_DIMENSION     D_VARCHAR50,
    O_CHARFIELD     D_VARCHAR1000,
    O_NUMERICFIELD  D_N15_3,
    O_DATEFILED     D_DATE,
    O_DATEEND       D_DATE,
    O_CHECK         D_VARCHAR255,
    ADDED_BY        D_VARCHAR50,
    ADDED_ON        D_DATETIME,
    EDIT_BY         D_VARCHAR50,
    EDIT_ON         D_DATETIME
);

CREATE TABLE OBJECTS_COVERAGE (
    OC_ID     UID,
    OC_TYPE   UID,
    O_ID      UID,
    HOUSE_ID  UID,
    NOTICE    D_NOTICE
);

CREATE TABLE OBJECTS_TYPE (
    OT_ID           UID NOT NULL,
    OT_NAME         D_NAME NOT NULL,
    OT_DESCRIPTION  D_DESCRIPTION
);

CREATE TABLE OPERATION_LOG (
    OPER_TIME     D_DATETIME,
    OPERATION     D_INTEGER,
    OPER_WHAT     D_VARCHAR50,
    OPER_WHO      D_VARCHAR50,
    OPER_NOTE     D_NOTICE,
    FROM_ADDRESS  D_VARCHAR255
);

CREATE TABLE ORDERS_TP (
    OTP_ID        UID,
    OTTP_TYPE     D_UID_NULL,
    OTP_NUMBER    D_VARCHAR50,
    OTP_DATE      D_DATE,
    FIO           D_VARCHAR255,
    ADRESS        D_VARCHAR500,
    PASSPORT      D_VARCHAR500,
    PHONE         D_VARCHAR50,
    NOTICE        D_NOTICE,
    QUANT         D_N15_2,
    PRICE         D_N15_2,
    AMOUNT        D_N15_2,
    PAY_DATE      D_TIMESTAMP,
    CUSTOMER_ID   D_UID_NULL,
    DATE_FROM     D_DATE,
    DATE_TO       D_DATE,
    ADDONS        D_VARCHAR1000,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME,
    CANCEL_TIME   D_TIMESTAMP,
    CANCEL_RESON  D_VARCHAR255
);

CREATE TABLE ORGANIZATION (
    ORG_ID            UID NOT NULL,
    ORG_NAME          D_VARCHAR255,
    DIRECTOR          D_VARCHAR50,
    BUHGALTER         D_VARCHAR50,
    ADRES             D_VARCHAR100,
    PHONE             D_VARCHAR50,
    EMAIL             D_VARCHAR50,
    NOTICE            D_NOTICE,
    ORG_BANK          D_UID_NULL,
    ORG_ACCOUNT       D_VARCHAR100,
    ORG_UNN           D_VARCHAR100,
    ORG_CODE          D_VARCHAR30,
    ORG_CONTRACT      D_VARCHAR50,
    VATG_ID           D_UID_NULL,
    CONTRACT_DATE     D_DATE,
    POST_ADRES        D_VARCHAR100,
    CONTRACT_DATE_TO  D_DATE,
    CODE              D_VARCHAR50
);

CREATE TABLE OTHER_FEE (
    FEE_DATE     D_DATE NOT NULL,
    CUSTOMER_ID  UID,
    FEE_NAME     D_VARCHAR1000,
    UNITS        D_N15_2,
    FEE          D_N15_2,
    VAT_TAX      D_N15_2 DEFAULT 0,
    FEE_TYPE     UID,
    IN_REQUEST   D_INTEGER,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE PAY_DOC (
    PAY_DOC_ID    UID NOT NULL,
    PAYSOURCE_ID  UID,
    PAY_DOC_NO    D_NAME NOT NULL,
    PAY_DOC_DATE  D_DATE_NOW NOT NULL,
    PAY_DOC_SUM   D_N15_2 NOT NULL,
    NOTICE        D_NOTICE,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME
);

CREATE TABLE PAY_ERRORS (
    PE_ID       UID NOT NULL,
    PAY_DOC_ID  D_UID_NULL,
    PAY_DATE    D_DATETIME,
    PAY_SUM     D_N15_2,
    LINE        D_NOTICE,
    ERROR_TEXT  D_NOTICE
);

CREATE TABLE PAYMENT (
    PAYMENT_ID    UID NOT NULL,
    PAY_DOC_ID    UID,
    CUSTOMER_ID   UID,
    PAY_DATE      D_DATE NOT NULL,
    PAY_DATETIME  D_DATETIME,
    PAY_SUM       D_N15_2 NOT NULL,
    FINE_SUM      D_N15_2 DEFAULT 0,
    NOTICE        D_NOTICE,
    PAYMENT_SRV   D_UID_NULL,
    PAYMENT_TYPE  D_UID_NULL DEFAULT 0,
    EXT_PAY_ID    D_VARCHAR50,
    TAG           D_INTEGER,
    TAG_STR       D_VARCHAR20,
    NEED_CHECK    D_IBOOLEAN DEFAULT 0,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME,
    PAY_TYPE_STR  D_VARCHAR30,
    FISCAL        D_SMALLINT DEFAULT 0,
    CMSN          D_N15_2
);

CREATE TABLE PAYMENT_DELETED (
    PAYMENT_ID    UID,
    PAY_DOC_ID    UID,
    CUSTOMER_ID   UID,
    PAY_DATE      D_DATE NOT NULL,
    PAY_SUM       D_N15_2 NOT NULL,
    FINE_SUM      D_N15_2 DEFAULT 0,
    NOTICE        D_NOTICE,
    PAYMENT_SRV   D_UID_NULL,
    EXT_PAY_ID    D_VARCHAR50,
    DELETED_BY    D_VARCHAR50,
    DELETED_ON    D_DATETIME,
    TAG           D_INTEGER,
    PAY_DATETIME  D_DATETIME,
    WHOM          D_VARCHAR30,
    FISCAL        D_SMALLINT
);

CREATE TABLE PAYMENT_HOLD (
    PAYMENT_ID    UID NOT NULL,
    CUSTOMER_ID   UID,
    PAY_DATETIME  D_DATETIME,
    PAY_SUM       D_N15_2 NOT NULL,
    NOTICE        D_NOTICE,
    PAY_STATE     D_VARCHAR20,
    EXT_ID        D_VARCHAR50,
    TAG_STR       D_VARCHAR100,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME
);

CREATE TABLE PAYSOURCE (
    PAYSOURCE_ID     UID,
    PAYSOURCE_DESCR  D_VARCHAR50,
    LEAK_PRC         D_N15_3 NOT NULL,
    TAX_PRC          D_N15_3 NOT NULL,
    CODE             D_VARCHAR10,
    FOR_FORM         D_VARCHAR50
);

CREATE GLOBAL TEMPORARY TABLE PERS_TARIF_TMP (
    SERV_ID  UID,
    T_DAY    D_DATE NOT NULL,
    TARIF    D_DAY_TARIF DEFAULT 0
) ON COMMIT DELETE ROWS;

CREATE TABLE PERSONAL_TARIF (
    TARIF_ID     UID NOT NULL,
    SERVICE_ID   UID,
    CUSTOMER_ID  UID,
    DATE_FROM    D_DATE NOT NULL,
    DATE_TO      D_DATE NOT NULL,
    TARIF_SUM    D_N15_2 NOT NULL,
    NOTICE       D_NOTICE,
    ADD_METHOD   D_SMALLINT,
    ADDED_BY     D_VARCHAR20,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_TIMESTAMP
);

CREATE TABLE PORT (
    EID       UID,
    PORT      D_PORT_NS NOT NULL,
    NOTICE    D_NOTICE,
    P_TYPE    D_UID_NULL,
    P_STATE   D_UID_NULL,
    CON       D_UID_NULL,
    CON_ID    D_UID_NULL,
    CON_PORT  D_PORT_NS,
    SPEED     D_INTEGER,
    VLAN_ID   D_UID_NULL,
    WID       D_UID_NULL,
    WLABEL    D_VARCHAR50,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE PREPAY_DETAIL (
    PPD_ID       UID NOT NULL,
    CUSTOMER_ID  UID,
    PPD_DATE     D_DATETIME NOT NULL,
    PPD_SUM      D_N15_2 NOT NULL,
    DEBT_SAVE    D_N15_2 DEFAULT 0,
    WHO_ADD      D_VARCHAR20,
    NOTICE       D_NOTICE,
    NEED_CHECK   D_SMALLINT
);

CREATE TABLE PROFILES (
    PROFILE       D_VARCHAR255 NOT NULL,
    PROFTYPE      D_INTEGER,
    FILETYPE      D_INTEGER,
    FILEEXT       D_VARCHAR20,
    FILEDIR       D_VARCHAR255,
    PAYMENTSRC    D_INTEGER,
    CODEPAGE      D_INTEGER,
    ARCHDIR       D_VARCHAR255,
    KOPEYKI       D_IBOOLEAN,
    DECIMALSPRT   D_VARCHAR5,
    HEADSUMLINE   D_INTEGER,
    HEADSUMCOL    D_INTEGER,
    HEADSPRT      D_VARCHAR20,
    HEADREMCH     D_VARCHAR20,
    HEADNUMLINE   D_INTEGER,
    HEADNUMCOL    D_INTEGER,
    HEADERTO      D_INTEGER,
    HEADERFROM    D_INTEGER,
    HEADEREXIST   D_IBOOLEAN,
    HEADDATELINE  D_INTEGER,
    HEADDATEFMT   D_VARCHAR20,
    HEADDATECOL   D_INTEGER,
    DATAFROM      D_INTEGER,
    DATATO        D_INTEGER,
    DATASPRT      D_VARCHAR20,
    DATAREMZERO   D_IBOOLEAN,
    DATAREMCH     D_VARCHAR20,
    ACCOUNT       D_VARCHAR30,
    FIO           D_VARCHAR30,
    ADRES         D_VARCHAR30,
    HOUSE         D_VARCHAR30,
    KORP          D_VARCHAR30,
    FLAT          D_VARCHAR30,
    DATADATE      D_VARCHAR30,
    DATEFMT       D_VARCHAR20,
    DATASUM       D_VARCHAR30,
    EXTID         D_VARCHAR30,
    NOTICE        D_VARCHAR30,
    NOTICE1       D_VARCHAR30
);

CREATE TABLE QRATING (
    QR_DATE    D_DATE NOT NULL,
    QR_TYPE    D_VARCHAR50,
    OBJECT_ID  UID,
    RATING     D_SMALLINT NOT NULL,
    NOTICE     D_NOTICE,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_DATETIME,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_DATETIME
);

CREATE TABLE QUEUE_SWITCH_SRV (
    CUSTOMER_ID  UID,
    SRV_FROM     UID,
    SWITCH_DATE  D_DATE NOT NULL,
    SRV_TO       UID,
    SRV_ACT      D_UID_NULL,
    COMPLETED    D_INTEGER DEFAULT 0
);

CREATE TABLE RATES (
    RDATE  D_DATE,
    CUR    D_VARCHAR5,
    USD    D_N15_4,
    EUR    D_N15_4
);

CREATE TABLE RECOURSE (
    RC_ID        UID NOT NULL,
    RC_TYPE      UID,
    CUSTOMER_ID  D_UID_NULL,
    HOUSE_ID     D_UID_NULL,
    FLAT_NO      D_FLAT,
    NOTICE       D_NOTICE,
    RQ_ID        D_UID_NULL,
    CONTACT      D_VARCHAR50,
    TAG          D_VARCHAR255,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE RECOURSE_TEMPLATES (
    RT_ID         UID,
    TYPE_ID       UID,
    NAME          D_VARCHAR100,
    NOTICE        D_VARCHAR255,
    NEED_REQUEST  D_IBOOLEAN,
    DELETED       D_IBOOLEAN
);

CREATE TABLE REMINDER (
    REM_USER    D_VARCHAR10 NOT NULL,
    REM_DATE    D_DATETIME NOT NULL,
    REM_NOTICE  D_VARCHAR500
);

CREATE TABLE REPORTS (
    ID_REPORT    UID NOT NULL,
    ID_PARENT    D_INTEGER,
    REPORT_NAME  D_VARCHAR500,
    NO_VISIBLE   D_IBOOLEAN,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME,
    REPORT_BODY  D_BLOB_GZIP1K
);

CREATE TABLE REQUEST (
    RQ_ID         UID NOT NULL,
    RQ_TYPE       UID,
    RQ_CUSTOMER   D_UID_NULL,
    RQ_CONTENT    D_NOTICE,
    RQ_DEFECT     D_NOTICE,
    RQ_COMPLETED  D_TIMESTAMP,
    RQ_NOTICE     D_NOTICE,
    RQ_PLAN_DATE  D_DATE_NOW,
    RQ_TIME_FROM  D_TIME,
    RQ_TIME_TO    D_TIME,
    HOUSE_ID      UID,
    FLAT_NO       D_FLAT,
    PORCH_N       D_VARCHAR10,
    FLOOR_N       D_VARCHAR10,
    PHONE         D_VARCHAR50,
    RQ_EXEC_TIME  D_DATETIME,
    GIVE_BY       D_VARCHAR50,
    GIVE_METHOD   D_INTEGER DEFAULT 0,
    REQ_RESULT    D_INTEGER DEFAULT 0,
    RQTL_ID       D_UID_NULL,
    DOOR_CODE     D_VARCHAR20,
    CAUSE_ID      D_UID_NULL,
    RESULT_ID     D_UID_NULL,
    RECEIPT       D_VARCHAR10,
    EXTEXECUTOR   D_VARCHAR100,
    ADD_INFO      D_VARCHAR255,
    TAG           D_INTEGER,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME,
    NODE_ID       D_UID_NULL,
    PARENT_RQ     D_UID_NULL
);

CREATE TABLE REQUEST_EXECUTORS (
    RQ_ID    UID NOT NULL,
    EXEC_ID  UID NOT NULL,
    NOTICE   D_NOTICE
);

CREATE TABLE REQUEST_MATERIALS (
    RM_ID      UID NOT NULL,
    RQ_ID      UID,
    M_ID       UID,
    WH_ID      UID,
    RM_QUANT   D_N15_5,
    RM_COST    D_N15_2,
    NOT_CALC   D_IBOOLEAN,
    RM_NOTICE  D_NOTICE,
    ADDED_BY   D_VARCHAR50,
    ADDED_ON   D_TIMESTAMP,
    EDIT_BY    D_VARCHAR50,
    EDIT_ON    D_TIMESTAMP
);

CREATE TABLE REQUEST_MATERIALS_RETURN (
    ID        UID NOT NULL,
    RQ_ID     UID,
    M_ID      UID,
    WH_ID     UID,
    QUANT     D_N15_5,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_TIMESTAMP,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_TIMESTAMP
);

CREATE TABLE REQUEST_MSG (
    ID        UID NOT NULL,
    RQ_ID     UID NOT NULL,
    ADDED_ON  D_TIMESTAMP,
    ADDED_BY  D_VARCHAR20,
    TEXT      D_VARCHAR500,
    DELETED   D_IBOOLEAN
);

CREATE TABLE REQUEST_PHOTOS (
    ID        UID,
    RQ_ID     UID NOT NULL,
    NOTICE    D_VARCHAR255,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME,
    HOUSE_ID  UID,
    JPG       D_BLOB1K
);

CREATE TABLE REQUEST_RESULTS (
    RR_ID     UID NOT NULL,
    RT_ID     UID,
    NAME      D_VARCHAR100 NOT NULL,
    FINISHED  D_IBOOLEAN DEFAULT 0,
    NOTICE    D_NOTICE,
    DELETED   D_IBOOLEAN DEFAULT 0
);

CREATE TABLE REQUEST_TEMPLATES (
    RQTL_ID        UID NOT NULL,
    RQ_TYPE        UID,
    RQ_CONTENT     D_NOTICE,
    RQ_SOLUTION    D_VARCHAR1000,
    RQ_MAXTIME     D_INTEGER,
    RQ_COLOR       D_VARCHAR10,
    ANALYSE_ID     D_UID_NULL,
    ADD_WORK       D_UID_NULL,
    RQ_ONOFF       D_INTEGER,
    RQ_SRV         D_UID_NULL,
    RQ_SRVONOFF    D_UID_NULL,
    DELETED        D_IBOOLEAN DEFAULT 0,
    ADD_FIELD      D_VARCHAR2000,
    NEED_PHOTO     D_IBOOLEAN,
    NEED_NODE_RQ   D_IBOOLEAN,
    RECREATE_DAYS  D_INTEGER,
    RECREATE_TYPE  D_UID_NULL,
    SMS_CREATE     D_VARCHAR255,
    SMS_CLOSE      D_VARCHAR255,
    ADDED_BY       D_VARCHAR50,
    ADDED_ON       D_DATETIME,
    EDIT_BY        D_VARCHAR50,
    EDIT_ON        D_DATETIME
);

CREATE TABLE REQUEST_TYPES (
    RT_ID          UID NOT NULL,
    RT_NAME        D_VARCHAR50,
    RT_TYPE        D_INTEGER,
    RT_NOTICE      D_NOTICE,
    RT_PRINTFORM   D_VARCHAR255,
    RT_DELETED     D_IBOOLEAN DEFAULT 0,
    RT_COLOR       D_VARCHAR10,
    RT_DEFAULT     D_IBOOLEAN DEFAULT 0,
    CAUSE_NEED     D_IBOOLEAN DEFAULT 0,
    RT_HC_NEED     D_IBOOLEAN,
    RECREATE_DAYS  D_INTEGER,
    RECREATE_TYPE  D_UID_NULL,
    ADDED_BY       D_VARCHAR50,
    ADDED_ON       D_DATETIME,
    EDIT_BY        D_VARCHAR50,
    EDIT_ON        D_DATETIME
);

CREATE TABLE REQUEST_WORKS (
    RQ_ID     UID NOT NULL,
    W_ID      UID NOT NULL,
    W_TIME    D_N15_3,
    W_QUANT   D_N15_5,
    W_COST    D_N15_2,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_TIMESTAMP,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_TIMESTAMP
);

CREATE TABLE SERVICES (
    SERVICE_ID     UID NOT NULL,
    SRV_TYPE_ID    UID,
    SHIFT_MONTHS   D_INTEGER DEFAULT 0,
    NAME           D_SERVICE_NAME,
    SHORTNAME      D_VARCH10_NS,
    DESCRIPTION    D_VARCHAR1000,
    DIMENSION      D_VARCHAR5,
    EXTRA          D_INTEGER,
    EXTERNAL_ID    D_VARCHAR100,
    INET_SRV       D_IBOOLEAN DEFAULT 0,
    IP_BEGIN       D_IP,
    IP_END         D_IP,
    IP_BEGIN_BIN   D_INT_IP,
    IP_END_BIN     D_INT_IP,
    BUSINESS_TYPE  D_INTEGER DEFAULT 0,
    CALC_TYPE      D_UID_NULL DEFAULT 0,
    USAGE          D_INTEGER DEFAULT 0,
    AUTOOFF        D_IBOOLEAN DEFAULT 0,
    EXPENSE_TYPE   D_INTEGER DEFAULT 0 NOT NULL,
    POSITIVE_ONLY  D_IBOOLEAN DEFAULT 0,
    PRIORITY       D_INTEGER,
    ONLY_ONE       D_IBOOLEAN,
    ADDED_BY       D_VARCHAR50,
    ADDED_ON       D_DATETIME,
    EDIT_BY        D_VARCHAR50,
    EDIT_ON        D_DATETIME,
    NOTE           D_DESCRIPTION,
    TAG            D_INTEGER,
    TAG_STR        D_VARCHAR255,
    OPENLY         D_IBOOLEAN DEFAULT 0,
    UNBL_METH      D_INTEGER
);

CREATE TABLE SERVICES_ATTRIBUTES (
    SA_ID       UID,
    SERVICE_ID  UID NOT NULL,
    O_ID        UID NOT NULL,
    SA_VALUE    D_VARCHAR100 NOT NULL,
    NOTICE      D_NOTICE,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME
);

CREATE TABLE SERVICES_CMPLX (
    SERVICE_ID  UID,
    NAME        D_VARCHAR50,
    "PERCENT"   D_N15_4,
    DATE_FROM   D_DATE,
    DATE_TO     D_DATE,
    NOTICE      D_VARCHAR255,
    ADDED_BY    D_VARCHAR50,
    ADDED_ON    D_DATETIME,
    EDIT_BY     D_VARCHAR50,
    EDIT_ON     D_DATETIME
);

CREATE TABLE SERVICES_LINKS (
    LINK_ID      D_UID_NULL,
    LINK_TYPE    D_UID_NULL,
    PARENT       D_UID_NULL,
    CHILD        D_UID_NULL,
    ADD_SRV      D_UID_NULL,
    SWITCH_TIME  D_INTEGER,
    DESCRIPTION  D_VARCHAR100
);

CREATE TABLE SERVICES_TYPE (
    SRV_TYPE_ID  UID,
    NAME         D_VARCHAR20,
    DESCRIPTION  D_VARCHAR100
);

CREATE TABLE SETTINGS (
    VAR_NAME     D_NAME NOT NULL,
    VAR_VALUE    D_VARCHAR1000,
    VAR_TYPE     D_VARCHAR10,
    VAR_CAPTION  D_VARCHAR50,
    VAR_NOTICE   D_NOTICE,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE SINGLE_SERV (
    SINGLE_SERVICE_ID  UID NOT NULL,
    CUSTOMER_ID        UID,
    SERVICE_ID         UID,
    SERV_DATE          D_DATE_NOW NOT NULL,
    UNITS              D_N15_2 DEFAULT 1,
    NOTICE             D_NOTICE,
    HISTORY_ID         D_UID_NULL DEFAULT -1,
    PAID               D_SMALLINT DEFAULT 0,
    ADDED_BY           D_VARCHAR50,
    ADDED_ON           D_DATETIME,
    VATG_ID            D_UID_NULL,
    RQ_ID              D_UID_NULL,
    TAG                D_INTEGER
);

CREATE TABLE STAT_IP (
    IP_BIN     D_INT_IP,
    TC_ID      D_INTEGER DEFAULT 0,
    STAT_DATE  D_DATETIME,
    BYTES      D_BIGINT,
    GRP_LVL    D_CHAR1
);

CREATE TABLE STREET (
    STREET_ID     UID NOT NULL,
    STREET_CODE   D_VARCH5_NS NOT NULL,
    STREET_SHORT  D_VARCHAR5 NOT NULL,
    STREET_NAME   D_VARCHAR50,
    AREA_ID       D_UID_NULL,
    NOTICE        D_NOTICE,
    ADDED_BY      D_VARCHAR50,
    ADDED_ON      D_DATETIME,
    EDIT_BY       D_VARCHAR50,
    EDIT_ON       D_DATETIME
);

CREATE TABLE STREET_TYPE (
    STRTYPE_SHORT  D_VARCHAR6 NOT NULL,
    STRTYPE_CODE   D_INTEGER NOT NULL,
    STRTYPE_NAME   D_VARCHAR50
);

CREATE TABLE SUBAREA (
    SUBAREA_ID    UID NOT NULL,
    AREA_ID       UID,
    SUBAREA_NAME  D_VARCHAR30,
    NOTICE        D_NOTICE,
    LON           D_GEOPOINT,
    LAT           D_GEOPOINT,
    ZOOM          D_SMALLINT
);

CREATE TABLE SUBDIVISIONS (
    ID         UID,
    NAME       D_NAME,
    NOTICE     D_NOTICE,
    ID_PARENT  D_UID_NULL,
    ADRES      D_VARCHAR100,
    BOSS       D_VARCHAR50
);

CREATE TABLE SUBSCR_HIST (
    SUBSCR_HIST_ID    UID NOT NULL,
    CUSTOMER_ID       UID,
    SERV_ID           UID,
    SUBSCR_SERV_ID    UID,
    DATE_FROM         D_DATE_NOW NOT NULL,
    DATE_TO           D_DATE DEFAULT '2100-01-01' NOT NULL,
    ACT_SERV_ID       D_UID_NULL,
    DISACT_SERV_ID    D_UID_NULL,
    ACT_WORKER_ID     D_UID_NULL,
    DISACT_WORKER_ID  D_UID_NULL,
    ADDED_BY          D_VARCHAR50,
    ADDED_ON          D_DATETIME,
    CLOSED_BY         D_VARCHAR50,
    CLOSED_ON         D_DATETIME
);

CREATE TABLE SUBSCR_SERV (
    SUBSCR_SERV_ID   UID NOT NULL,
    CUSTOMER_ID      UID,
    SERV_ID          UID,
    STATE_SGN        D_INTEGER NOT NULL,
    STATE_DATE       D_DATE,
    STATE_SRV        D_UID_NULL,
    NOTICE           D_NOTICE,
    STATE_CHANGE_BY  D_VARCHAR50,
    STATE_CHANGE_ON  D_DATETIME,
    CONTRACT         D_VARCHAR20,
    CONTRACT_DATE    D_DATE,
    VATG_ID          D_UID_NULL
);

CREATE TABLE SYS$GROUP (
    ID           UID NOT NULL,
    GROUP_NAME   D_VARCHAR20 NOT NULL,
    LOCKEDOUT    D_IBOOLEAN DEFAULT 0,
    NOTICE       D_NOTICE,
    ALL_REPORTS  D_IBOOLEAN,
    ALL_MODULES  D_IBOOLEAN,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE SYS$GROUP_RIGHTS (
    ID           D_UID_NULL,
    GROUP_ID     D_UID_NULL,
    RIGHTS_TYPE  D_INTEGER,
    RIGHT_ID     D_UID_NULL,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_DATETIME
);

CREATE TABLE SYS$RIGHTS (
    ID        UID NOT NULL,
    RIGHTS    D_VARCHAR50 NOT NULL,
    CATEGORY  D_VARCHAR20,
    NOTICE    D_NOTICE
);

CREATE TABLE SYS$USER (
    ID            UID NOT NULL,
    IBNAME        D_VARCHAR30 NOT NULL,
    LOCKEDOUT     D_IBOOLEAN DEFAULT 0,
    ALL_AREAS     D_IBOOLEAN,
    LAST_LOGGED   D_TIMESTAMP,
    PSWD_CHANGED  D_TIMESTAMP
);

CREATE TABLE SYS$USER_AREAS (
    ID       UID,
    USER_ID  UID,
    AREA_ID  UID
);

CREATE TABLE SYS$USER_GROUPS (
    ID        UID,
    USER_ID   UID,
    GROUP_ID  UID
);

CREATE TABLE SYS$USER_WH (
    USER_ID   UID,
    WH_ID     UID,
    CAN_VIEW  D_IBOOLEAN,
    CAN_EDIT  D_IBOOLEAN,
    NOTICE    D_NOTICE
);

CREATE TABLE TARIF (
    TARIF_ID       UID NOT NULL,
    SERVICE_ID     UID,
    DATE_FROM      D_DATE NOT NULL,
    DATE_TO        D_DATE DEFAULT '2100-01-01' NOT NULL,
    TARIF_SUM      D_N15_2 NOT NULL,
    TARIF_SUM_JUR  D_N15_2,
    EDIT_BY        D_VARCHAR100,
    EDIT_ON        D_DATETIME
);

CREATE TABLE TASKLIST (
    ID         UID,
    TITLE      D_VARCHAR100,
    NOTICE     D_VARCHAR500,
    PLAN_DATE  D_DATETIME,
    EXEC_DATE  D_DATETIME,
    COLOR      D_VARCHAR10,
    DELETED    D_IBOOLEAN,
    ADDED_BY   D_VARCHAR20,
    ADDED_ON   D_DATETIME,
    EDIT_ON    D_DATETIME,
    EDIT_BY    D_VARCHAR20
);

CREATE TABLE TASKMSG (
    ID        UID NOT NULL,
    TASK_ID   UID NOT NULL,
    ADDED_ON  D_TIMESTAMP,
    ADDED_BY  D_VARCHAR20,
    TEXT      D_VARCHAR500,
    OBJ_TYPE  D_VARCHAR5,
    OBJ_ID    D_VARCHAR100,
    DELETED   D_IBOOLEAN
);

CREATE TABLE TASKUSER (
    TASK_ID  UID,
    FORUSER  D_VARCHAR20
);

CREATE GLOBAL TEMPORARY TABLE TMP_COL (
    C_DATE  D_DATE,
    C_STR   D_VARCHAR255,
    C_INT   D_INTEGER,
    C_NUM   D_N15_2
) ON COMMIT DELETE ROWS;

CREATE TABLE TQUEUE (
    ID                    UID NOT NULL,
    CLASS_ID              D_INTEGER,
    HARDWARE_ID           D_DECODER,
    STATUS                D_INTEGER DEFAULT 0,
    DATEADDED             D_DATETIME DEFAULT LOCALTIMESTAMP,
    TRANSACTIONNUM        D_BIGINT,
    "ACTION"              D_INTEGER,
    DATETIME              D_DATETIME DEFAULT LOCALTIMESTAMP,
    DAYCOUNT              D_INTEGER,
    USER_ID               D_INTEGER,
    EMAIL                 D_VARCHAR100,
    SNAME                 D_VARCHAR50,
    FNAME                 D_VARCHAR50,
    PNAME                 D_VARCHAR50,
    PHONE                 D_VARCHAR20,
    CARD_NUM_FIRST        D_VARCHAR20,
    CARD_NUM_LAST         D_VARCHAR20,
    CARD_ID               D_VARCHAR20,
    HARDWARE_ID_CH        D_HARDWARE,
    DEVICE_MODEL_ID       D_INTEGER,
    INFOCAS_PERIOD        D_INTEGER,
    INFOCAS_INTERVAL      D_INTEGER,
    INFOCAS_MESSAGE_TEXT  D_DRE_INFO,
    INFOCAS_MESSAGE_ID    D_INTEGER,
    COUNTER               D_INTEGER,
    COUNTERUNIT           D_INTEGER,
    GEOCODE               D_INTEGER,
    ENDDATE               D_DATETIME,
    FP_DURATION           D_INTEGER,
    FP_IOC                D_INTEGER,
    WINDOW_TYPE           D_INTEGER,
    X_COORDINATE          D_INTEGER,
    Y_COORDINATE          D_INTEGER,
    WINDOW_TRANSPARENCY   D_INTEGER,
    BACKGROUND_COLOR      D_INTEGER,
    FONT_TRANSPARENCY     D_INTEGER,
    FONT_COLOR            D_INTEGER,
    SHOW_TIME             D_INTEGER,
    FINGERPRINTING_ID     D_INTEGER,
    GEOCODE_HEX           D_VARBINARY16
);

CREATE TABLE TV_LAN (
    LAN_ID       UID NOT NULL,
    CUSTOMER_ID  UID NOT NULL,
    IP           D_IP,
    IPV6         D_IPV6,
    MAC          D_MAC,
    IP_ADD       D_IP,
    PORT         D_PORT_NS,
    NOTICE       D_NOTICE,
    IP_BIN       D_INT_IP,
    IP_ADD_BIN   D_INT_IP,
    TAG          D_INTEGER,
    TAG_STR      D_VARCHAR50,
    EQ_ID        D_UID_NULL,
    VLAN_ID      D_UID_NULL,
    HOUSE_ID     D_UID_NULL,
    PLACE        D_VARCH20_NS,
    LAST_UPDATE  D_DATETIME,
    ADDED_BY     D_VARCHAR50,
    ADDED_ON     D_DATETIME,
    EDIT_BY      D_VARCHAR50,
    EDIT_ON      D_TIMESTAMP
);

CREATE TABLE TV_LAN_PACKETS (
    LAN_ID      UID,
    SERVICE_ID  UID,
    NOTICE      D_NOTICE
);

CREATE TABLE VLANS (
    V_ID          UID NOT NULL,
    NAME          D_VARCHAR50,
    IP_BEGIN      D_IP,
    IP_END        D_IP,
    MASK          D_IP,
    GATEWAY       D_IP,
    IP_BEGIN_BIN  D_INT_IP,
    IP_END_BIN    D_INT_IP,
    NOTICE        D_DESCRIPTION,
    CONFIG_FILE   D_VARCHAR255,
    FOR_OBJECTS   D_SMALLINT DEFAULT 0,
    VLAN_NUM      D_INTEGER,
    DNS           D_VARCHAR255
);

CREATE TABLE VPN_SESSIONS (
    ID          UID,
    CLASS       D_VARCHAR10 NOT NULL,
    ACCOUNT_NO  D_ACCOUNT NOT NULL,
    BEGIN_DATE  D_INTEGER NOT NULL,
    END_DATE    D_INTEGER,
    IP          D_IP NOT NULL,
    IP_VPN      D_IP,
    USERNAME    D_VARCHAR50,
    INTERFACE   D_VARCHAR50,
    SERVER      D_IP,
    STATUS      D_VARCHAR50 NOT NULL
);

CREATE TABLE WIRE (
    WID       UID,
    WTYPE     UID,
    NAME      D_NAME,
    METERS    D_N15_2,
    STOCK     D_N15_2,
    POINT_S   D_UID_NULL,
    POINT_E   D_UID_NULL,
    NOTICE    D_NOTICE,
    PATH      D_VARCHAR1000,
    CAPACITY  D_INTEGER,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME,
    M_ID      D_UID_NULL,
    LABELS    D_VARCHAR1000
);

CREATE TABLE WIRE_POINT (
    WID       UID,
    NODE_ID   UID,
    METERS    D_N15_2,
    NOTICE    D_NOTICE,
    ADDED_BY  D_VARCHAR50,
    ADDED_ON  D_DATETIME,
    EDIT_BY   D_VARCHAR50,
    EDIT_ON   D_DATETIME
);

CREATE TABLE WORKAREA (
    WA_ID      UID NOT NULL,
    NAME       D_VARCHAR30,
    WA_CODE    D_VARCHAR5,
    REQ_LIMIT  D_INTEGER DEFAULT -1,
    WH_ID      D_UID_NULL,
    NOTICE     D_NOTICE,
    BOSS       D_VARCHAR100,
    FOREMAN    D_VARCHAR100,
    PHONE      D_VARCHAR100,
    ADRES      D_VARCHAR255
);

CREATE TABLE WORKAREALIMIT (
    WA_ID   UID NOT NULL,
    W_ID    UID NOT NULL,
    QUANT   D_INTEGER,
    NOTICE  D_NOTICE
);

CREATE TABLE WORKER (
    WORKER_ID   UID NOT NULL,
    SURNAME     D_VARCHAR30,
    FIRSTNAME   D_VARCHAR30,
    MIDLENAME   D_VARCHAR30,
    PHONE_NO    D_VARCHAR30,
    NOTICE      D_NOTICE,
    WORKING     D_IBOOLEAN DEFAULT 1,
    IBNAME      D_VARCHAR30,
    IN_DOGOVOR  D_IBOOLEAN,
    IN_REQUEST  D_IBOOLEAN,
    EMAIL       D_VARCHAR50,
    DEPARTMENT  D_VARCHAR100,
    POST        D_VARCHAR100,
    BIRTHDAY    D_DATE,
    TEAM        D_VARCHAR100,
    WA_ID       D_UID_NULL,
    PRINT_FIO   D_VARCHAR255,
    PRINT_TEXT  D_VARCHAR255,
    PUSH_TOKEN  D_VARCHAR255,
    PLATFORM    D_VARCHAR20,
    DEVICE_ID   D_VARCHAR255,
    H_RATE      D_N15_2,
    MESSENGER   D_VARCHAR50
);

CREATE TABLE WORKGROUPS (
    WG_ID     UID NOT NULL,
    WA_ID     UID,
    NAME      D_VARCHAR30,
    NOTICE    D_NOTICE,
    RQ_LIMIT  D_INTEGER
);

CREATE TABLE WORKS (
    W_ID        UID NOT NULL,
    RQ_TYPE     UID,
    WG_ID       D_UID_NULL,
    NAME        D_VARCHAR255,
    NOTICE      D_NOTICE,
    W_TIME      D_N15_3,
    W_COST      D_N15_2,
    W_ONOFF     D_INTEGER DEFAULT 0,
    W_SRV       D_UID_NULL,
    W_SRVONOFF  D_UID_NULL DEFAULT 0,
    DELETED     D_IBOOLEAN DEFAULT 0,
    W_ATR_AD    D_SMALLINT DEFAULT 0,
    W_ATR_ID    D_UID_NULL,
    AS_SERVICE  D_UID_NULL,
    ON_DEFAULT  D_IBOOLEAN
);

CREATE VIEW RAYON(
    RID,
    R_NAME,
    LATITUDE,
    LONGITUDE,
    ZOOM)
AS
select SA.SUBAREA_ID, SA.SUBAREA_NAME, SA.LAT, SA.LON, SA.ZOOM
FROM SUBAREA SA
;


CREATE VIEW V_ADRESS(
    STREET_ID,
    STREET_NAME,
    HOUSE_ID,
    HOUSE_NO)
AS
select
    s.STREET_ID, s.STREET_NAME || ' ' || s.Street_Short STREET_NAME, h.HOUSE_ID, h.HOUSE_NO
  from STREET s
       inner join HOUSE h on (S.STREET_ID = h.STREET_ID)
;


CREATE VIEW V_ALL_IP(
    IP,
    IP_BIN,
    O_ID,
    O_TYPE)
AS
select IP, IP_BIN, CUSTOMER_ID, 1 from TV_LAN T where not IP is null
union
select IP, IP_BIN,         EID, 0 from EQUIPMENT E where not IP is null
union
select IP, IP_BIN,          -1, 2 from ALL_USED_IP I 
union
select IP_INET as IP, IP_INET_BIN as IP_BIN, CUSTOMER_ID, 3 from BILLING B
union
select O.O_NAME as IP, INET_ATON(O.O_NAME) as IP_BIN, -1, 4 from OBJECTS O where O.O_TYPE = 20
;


CREATE VIEW V_ALL_MAC(
    MAC,
    O_ID,
    O_TYPE)
AS
select MAC, CUSTOMER_ID, 1 from tv_lan t where not MAC is null
union
select MAC, eid, 0 from equipment e where not MAC is null
;


CREATE VIEW V_ATTRIBUTES(
    O_ID,
    O_NAME,
    O_DESCRIPTION,
    O_DELETED,
    O_DIMENSION)
AS
SELECT O_ID, O_NAME, O_DESCRIPTION, O_DELETED, O_DIMENSION
FROM OBJECTS
WHERE O_TYPE = 4 AND O_DELETED = 0
;


CREATE VIEW V_CUSTOMER_ATTRIBUTES(
    O_ID,
    CUSTOMER_ID,
    O_NAME,
    O_DESCRIPTION,
    O_DIMENSION,
    NOTICE)
AS
SELECT A.O_ID, C.CUSTOMER_ID, A.O_NAME, A.O_DESCRIPTION, A.O_DIMENSION, CA.NOTICE
FROM CUSTOMER_ATTRIBUTES CA
   INNER JOIN CUSTOMER C ON (CA.CUSTOMER_ID = C.CUSTOMER_ID)
   INNER JOIN OBJECTS A ON (CA.O_ID = A.O_ID)
;


CREATE VIEW V_ORDER_CREATOR(
    WORKER_ID,
    FIO)
AS
SELECT
 W.WORKER_ID, w.SURNAME||' '||w.FIRSTNAME||' '||w.MIDLENAME as FIO
FROM WORKER W
WHERE w.working = 1
;


CREATE VIEW V_PAYMENTTYPE(
    O_ID,
    O_NAME,
    O_DESCRIPTION)
AS
select
    O_ID
  , O_NAME
  , O_DESCRIPTION
  from OBJECTS o
  where o.O_DELETED = 0
        and o.O_TYPE = 2
;


ALTER TABLE CARDS_PREPAY ADD CONSTRAINT UNQ_SNP_CARDS_PREPAY UNIQUE (CARD_SERIAL, CARD_NUMBER, CARD_PIN);
ALTER TABLE CARDS_SERIALS ADD CONSTRAINT UNQ_SRL_CARDS_SERIALS UNIQUE (CS_SERIAL);
ALTER TABLE CUSTOMER ADD CONSTRAINT UNQ_CUSTOMER_ACCOUNT UNIQUE (ACCOUNT_NO);
ALTER TABLE CUSTOMER_DECODERS ADD CONSTRAINT UNQ1_CUSTOMER_DECODERS UNIQUE (DECODER_N);
ALTER TABLE CUSTOMER_EQUIPMENT ADD CONSTRAINT UNQ1_CUSTOMER_EQUIPMENT UNIQUE (EQUIP_N);
ALTER TABLE DISTRIB_CONTRACTS ADD CONSTRAINT UNQ1_DISTRIB_CONTRACTS UNIQUE (DISTRIBUTOR_ID, C_NUMBER);
ALTER TABLE EPG_MAPPING ADD CONSTRAINT UNQ1_EPG_MAPPING UNIQUE (EPG_ID, CH_ID);
ALTER TABLE HOUSEFLATS ADD CONSTRAINT UNQ_HOUSEFLATS UNIQUE (HOUSE_ID, FLAT_NO);
ALTER TABLE NODE_FLATS ADD CONSTRAINT UNQ_NODE_FLATS UNIQUE (HOUSE_ID, FLAT_NO);
ALTER TABLE PERSONAL_TARIF ADD CONSTRAINT UNQ1_PERSONAL_TARIF UNIQUE (CUSTOMER_ID, SERVICE_ID, DATE_FROM);
ALTER TABLE TV_LAN ADD CONSTRAINT UNQ2_TV_LAN UNIQUE (MAC)
USING INDEX UNQ_LAN_MAC;
ALTER TABLE TV_LAN ADD CONSTRAINT UNQ_TV_IP_VLAN UNIQUE (IP, VLAN_ID);
ALTER TABLE VLANS ADD CONSTRAINT UNQ1_VLANS UNIQUE (IP_BEGIN_BIN);
ALTER TABLE AREA ADD CONSTRAINT PK_AREA PRIMARY KEY (AREA_ID);
ALTER TABLE ATTRIBUTE ADD CONSTRAINT PK_ATTRIBUTE PRIMARY KEY (TYPE_ID, OBJECT_ID, AID);
ALTER TABLE BCISSUE ADD CONSTRAINT PK_BCISSUE PRIMARY KEY (BI_ID);
ALTER TABLE BCI_CHANNELS ADD CONSTRAINT PK_BCI_CHANNELS PRIMARY KEY (BI_ID, CH_ID);
ALTER TABLE BILLING ADD CONSTRAINT PK_BILLING PRIMARY KEY (BLNG_ID);
ALTER TABLE BLB_GZIP ADD CONSTRAINT PK_BLB_GZIP PRIMARY KEY (BLB_ID);
ALTER TABLE BLOB_TBL ADD CONSTRAINT PK_BLOB_TBL PRIMARY KEY (BL_ID);
ALTER TABLE BONUS_RATE ADD CONSTRAINT PK_BONUS_RATE PRIMARY KEY (ID);
ALTER TABLE CARDS_PREPAY ADD CONSTRAINT PK_CARDS_PREPAY PRIMARY KEY (CARD_ID);
ALTER TABLE CARDS_SERIALS ADD CONSTRAINT PK_CARDS_SERIALS PRIMARY KEY (CS_ID);
ALTER TABLE CHANGELOG ADD CONSTRAINT PK_CHANGELOG PRIMARY KEY (LOG_ID);
ALTER TABLE CHANNELS_IN_SERVCE ADD CONSTRAINT PK_CHANNELS_IN_SERVCE PRIMARY KEY (SRV_ID, CH_ID, ON_OFF);
ALTER TABLE CUSTLETTER ADD CONSTRAINT PK_CUSTLETTER PRIMARY KEY (CUSTLETTERID);
ALTER TABLE CUSTOMER ADD CONSTRAINT CSTMR_PK PRIMARY KEY (CUSTOMER_ID);
ALTER TABLE CUSTOMER_ATTRIBUTES ADD CONSTRAINT PK_CUSTOMER_ATTRIBUTES PRIMARY KEY (CUSTOMER_ID, O_ID);
ALTER TABLE CUSTOMER_CHANNELS ADD CONSTRAINT PK_CUSTOMER_CHANNELS PRIMARY KEY (DECODER_ID, CH_ID);
ALTER TABLE CUSTOMER_CONTACTS ADD CONSTRAINT PK_CUSTOMER_CONTACTS PRIMARY KEY (CUSTOMER_ID, CC_VALUE);
ALTER TABLE CUSTOMER_DECODERS ADD CONSTRAINT PK_CUSTOMER_DECODERS PRIMARY KEY (DEC_ID);
ALTER TABLE CUSTOMER_EQUIPMENT ADD CONSTRAINT PK_CUSTOMER_EQUIPMENT PRIMARY KEY (CE_ID);
ALTER TABLE DECODER_PACKETS ADD CONSTRAINT PK_DECODER_PACKETS PRIMARY KEY (DECODER_N, SERVICE_ID);
ALTER TABLE DEVICES ADD CONSTRAINT PK_DEVICES PRIMARY KEY (ID);
ALTER TABLE DEVPORTS ADD CONSTRAINT PK_DEVPORTS PRIMARY KEY (ID);
ALTER TABLE DEVPROFILES ADD CONSTRAINT PK_DEVPROFILES PRIMARY KEY (ID);
ALTER TABLE DISCOUNT_FACTOR ADD CONSTRAINT PK_DISCOUNT_FACTOR PRIMARY KEY (DISCOUNT_ID);
ALTER TABLE DISTRIBUTOR ADD CONSTRAINT PK_DISTRIBUTOR PRIMARY KEY (ID);
ALTER TABLE DISTRIB_CONTRACTS ADD CONSTRAINT PK_DISTRIB_CONTRACTS PRIMARY KEY (ID);
ALTER TABLE DISTRIB_CONTRACT_REPORTS ADD CONSTRAINT PK_DISTRIB_CONTRACT_REPORTS PRIMARY KEY (CONTRACT_ID, PERIOD);
ALTER TABLE DISTRIB_CONTRACT_REPORTS_CH ADD CONSTRAINT PK_DISTRIB_CONTRACT_REPORTS_CH PRIMARY KEY (CONTRACT_ID, PERIOD, CH_ID);
ALTER TABLE DVB_NETWORK ADD CONSTRAINT PK_DVB_NETWORK PRIMARY KEY (DVBN_ID);
ALTER TABLE DVB_STREAMS ADD CONSTRAINT PK_DVB_STREAMS PRIMARY KEY (DVBN_ID, DVBS_ID);
ALTER TABLE DVB_STREAM_CHANNELS ADD CONSTRAINT PK_DVB_STREAM_CHANNELS PRIMARY KEY (DVBS_ID, CH_ID);
ALTER TABLE EPG_AD ADD CONSTRAINT PK_EPG_AD PRIMARY KEY (ID);
ALTER TABLE EPG_AD_CHANNELS ADD CONSTRAINT PK_EPG_AD_CHANNELS PRIMARY KEY (EA_ID, CH_ID);
ALTER TABLE EPG_LOCAL ADD CONSTRAINT PK_EPG_LOCAL PRIMARY KEY (CH_ID, DATE_START);
ALTER TABLE EPG_SOURCES ADD CONSTRAINT PK_EPG_SOURCES PRIMARY KEY (ID);
ALTER TABLE EQUIPMENT ADD CONSTRAINT PK_EQUIPMENT PRIMARY KEY (EID);
ALTER TABLE EQUIPMENT_ATTRIBUTES ADD CONSTRAINT PK_EQUIPMENT_ATTRIBUTES PRIMARY KEY (EA_ID);
ALTER TABLE EQUIPMENT_CMD_GRP ADD CONSTRAINT PK_EQUIPMENT_CMD_GRP PRIMARY KEY (EC_ID);
ALTER TABLE EQUIPMENT_COVERAGE ADD CONSTRAINT PK_EQUIPMENT_COVERAGE PRIMARY KEY (EID, HOUSE_ID);
ALTER TABLE EQUIPMENT_DVB ADD CONSTRAINT PK_EQUIPMENT_DVB PRIMARY KEY (EQ_N);
ALTER TABLE EXPORTTYPES ADD CONSTRAINT PK_EXPORTTYPES PRIMARY KEY (NAME);
ALTER TABLE HEADEND ADD CONSTRAINT PK_HEADEND PRIMARY KEY (HE_ID);
ALTER TABLE HEADEND_CHANNELS ADD CONSTRAINT PK_HEADEND_CHANNELS PRIMARY KEY (CH_ID, HE_ID);
ALTER TABLE HOUSE ADD CONSTRAINT PK_HOUSE PRIMARY KEY (HOUSE_ID);
ALTER TABLE HOUSEFLOOR ADD CONSTRAINT PK_HOUSEFLOOR PRIMARY KEY (FLOOR_ID);
ALTER TABLE HOUSEPORCH ADD CONSTRAINT PK_HOUSEPORCH PRIMARY KEY (PORCH_ID);
ALTER TABLE HOUSES_ATTRIBUTES ADD CONSTRAINT PK_HOUSES_ATTRIBUTES PRIMARY KEY (HOUSE_ID, O_ID);
ALTER TABLE HOUSEWORKS ADD CONSTRAINT PK_HOUSEWORKS PRIMARY KEY (HW_ID);
ALTER TABLE MAP ADD CONSTRAINT PK_MAP PRIMARY KEY (ID);
ALTER TABLE MAP_XY ADD CONSTRAINT PK_MAP_XY PRIMARY KEY (ID);
ALTER TABLE MATERIALS ADD CONSTRAINT PK_MATERIALS PRIMARY KEY (M_ID)
USING INDEX PK_MATERIALS_ID;
ALTER TABLE MATERIALS_GROUP ADD CONSTRAINT PK_MATERIALS_GROUP PRIMARY KEY (MG_ID);
ALTER TABLE MATERIALS_IN_DOC ADD CONSTRAINT PK_MATERIALS_IN_DOC PRIMARY KEY (ID);
ALTER TABLE MATERIALS_IN_DOC_UNIT ADD CONSTRAINT PK_MATERIALS_IN_DOC_UNIT PRIMARY KEY (DOC_ID, M_ID, SERIAL);
ALTER TABLE MATERIAL_DOCS ADD CONSTRAINT PK_MATERIAL_DOCS PRIMARY KEY (DOC_ID);
ALTER TABLE MATERIAL_UNIT ADD CONSTRAINT PK_MATERIAL_UNIT PRIMARY KEY (SERIAL, M_ID);
ALTER TABLE NODES ADD CONSTRAINT PK_NODES PRIMARY KEY (NODE_ID);
ALTER TABLE NODES_ATTRIBUTES ADD CONSTRAINT PK_NODES_ATTRIBUTES PRIMARY KEY (NODE_ID, O_ID);
ALTER TABLE NODE_LAYOUT ADD CONSTRAINT PK_NODE_LAYOUT PRIMARY KEY (NODE_ID, M_TYPE);
ALTER TABLE OBJECTS ADD CONSTRAINT PK_OBJECTS PRIMARY KEY (O_ID, O_TYPE);
ALTER TABLE OBJECTS_TYPE ADD CONSTRAINT PK_OBJECTS_TYPE PRIMARY KEY (OT_ID);
ALTER TABLE ORDERS_TP ADD CONSTRAINT PK_ORDERS_TP PRIMARY KEY (OTP_ID);
ALTER TABLE ORGANIZATION ADD CONSTRAINT PK_ORGANIZATION PRIMARY KEY (ORG_ID);
ALTER TABLE PAYMENT ADD CONSTRAINT PK_PAYMENT PRIMARY KEY (PAYMENT_ID);
ALTER TABLE PAYSOURCE ADD CONSTRAINT PK_PAYSOURCE PRIMARY KEY (PAYSOURCE_ID);
ALTER TABLE PAY_DOC ADD CONSTRAINT PK_PAY_DOC PRIMARY KEY (PAY_DOC_ID);
ALTER TABLE PAY_ERRORS ADD CONSTRAINT PK_PAY_ERRORS PRIMARY KEY (PE_ID);
ALTER TABLE PERSONAL_TARIF ADD CONSTRAINT PK_PERSONAL_TARIF PRIMARY KEY (TARIF_ID);
ALTER TABLE PORT ADD CONSTRAINT PK_PORT PRIMARY KEY (EID, PORT);
ALTER TABLE PREPAY_DETAIL ADD CONSTRAINT PK_PREPAY_DETAIL PRIMARY KEY (PPD_ID);
ALTER TABLE PROFILES ADD CONSTRAINT PK_PROFILES PRIMARY KEY (PROFILE);
ALTER TABLE QUEUE_SWITCH_SRV ADD CONSTRAINT PK_QUEUE_SWITCH_SRV PRIMARY KEY (CUSTOMER_ID, SRV_FROM);
ALTER TABLE RECOURSE ADD CONSTRAINT PK_RECOURSE PRIMARY KEY (RC_ID);
ALTER TABLE RECOURSE_TEMPLATES ADD CONSTRAINT PK_RECOURSE_TEMPLATES PRIMARY KEY (RT_ID);
ALTER TABLE REPORTS ADD CONSTRAINT PK_REPORTS PRIMARY KEY (ID_REPORT);
ALTER TABLE REQUEST ADD CONSTRAINT PK_REQUEST PRIMARY KEY (RQ_ID);
ALTER TABLE REQUEST_EXECUTORS ADD CONSTRAINT PK_REQUEST_EXECUTORS PRIMARY KEY (RQ_ID, EXEC_ID);
ALTER TABLE REQUEST_MATERIALS ADD CONSTRAINT PK_REQUEST_MATERIALS PRIMARY KEY (RM_ID);
ALTER TABLE REQUEST_MATERIALS_RETURN ADD CONSTRAINT PK_REQUEST_MATERIALS_RETURN PRIMARY KEY (ID);
ALTER TABLE REQUEST_MSG ADD CONSTRAINT PK_REQUEST_MSG PRIMARY KEY (ID);
ALTER TABLE REQUEST_RESULTS ADD CONSTRAINT PK_REQUEST_RESULTS PRIMARY KEY (RR_ID);
ALTER TABLE REQUEST_TEMPLATES ADD CONSTRAINT PK_REQUEST_TEMPLATES PRIMARY KEY (RQTL_ID);
ALTER TABLE REQUEST_TYPES ADD CONSTRAINT PK_REQUEST_TYPES PRIMARY KEY (RT_ID);
ALTER TABLE REQUEST_WORKS ADD CONSTRAINT PK_REQUEST_WORKS PRIMARY KEY (RQ_ID, W_ID);
ALTER TABLE SERVICES ADD CONSTRAINT PK_SERVICES PRIMARY KEY (SERVICE_ID);
ALTER TABLE SERVICES_ATTRIBUTES ADD CONSTRAINT PK_SERVICES_ATTRIBUTES PRIMARY KEY (SERVICE_ID, O_ID);
ALTER TABLE SETTINGS ADD CONSTRAINT PK_SETTINGS_NAME PRIMARY KEY (VAR_NAME);
ALTER TABLE SINGLE_SERV ADD CONSTRAINT PK_SINGLE_SERV PRIMARY KEY (SINGLE_SERVICE_ID);
ALTER TABLE STREET ADD CONSTRAINT PK_STREET PRIMARY KEY (STREET_ID);
ALTER TABLE STREET_TYPE ADD CONSTRAINT PK_STREET_TYPE PRIMARY KEY (STRTYPE_SHORT);
ALTER TABLE SUBAREA ADD CONSTRAINT PK_SUBAREA PRIMARY KEY (SUBAREA_ID);
ALTER TABLE SUBSCR_HIST ADD CONSTRAINT PK_SUBSCR_HIST PRIMARY KEY (SUBSCR_HIST_ID);
ALTER TABLE SUBSCR_SERV ADD CONSTRAINT PK_SUBSCR_SERV PRIMARY KEY (SUBSCR_SERV_ID);
ALTER TABLE SYS$GROUP ADD CONSTRAINT PK_SYS_GROUP PRIMARY KEY (ID);
ALTER TABLE SYS$RIGHTS ADD CONSTRAINT PK_SYS$RIGHTS PRIMARY KEY (ID);
ALTER TABLE SYS$USER ADD CONSTRAINT PK_SYS_USER PRIMARY KEY (ID);
ALTER TABLE TARIF ADD CONSTRAINT PK_TARIF PRIMARY KEY (TARIF_ID);
ALTER TABLE TASKLIST ADD CONSTRAINT PK_TASKLIST PRIMARY KEY (ID);
ALTER TABLE TASKMSG ADD CONSTRAINT PK_TASKMSG PRIMARY KEY (ID);
ALTER TABLE TQUEUE ADD CONSTRAINT PK_TQUEUE PRIMARY KEY (ID);
ALTER TABLE TV_LAN ADD CONSTRAINT PK_TV_LAN PRIMARY KEY (LAN_ID);
ALTER TABLE VLANS ADD CONSTRAINT PK_VLANS PRIMARY KEY (V_ID);
ALTER TABLE WIRE ADD CONSTRAINT PK_WIRE_ID PRIMARY KEY (WID)
USING INDEX PK_WIRE;
ALTER TABLE WIRE_POINT ADD CONSTRAINT PK_WIRE_PWN PRIMARY KEY (WID, NODE_ID)
USING INDEX PK_WIRE_POINT;
ALTER TABLE WORKAREA ADD CONSTRAINT PK_WORKAREA PRIMARY KEY (WA_ID);
ALTER TABLE WORKAREALIMIT ADD CONSTRAINT PK_WORKAREALIMIT PRIMARY KEY (WA_ID, W_ID);
ALTER TABLE WORKER ADD CONSTRAINT PK_WORKER PRIMARY KEY (WORKER_ID);
ALTER TABLE WORKGROUPS ADD CONSTRAINT PK_WORKGROUPS PRIMARY KEY (WG_ID);
ALTER TABLE WORKS ADD CONSTRAINT PK_WORKS PRIMARY KEY (W_ID);
ALTER TABLE CARDS_PREPAY ADD CONSTRAINT FK_CARDS_PREPAY_SERIAL FOREIGN KEY (CARD_SERIAL) REFERENCES CARDS_SERIALS (CS_ID) ON DELETE SET NULL ON UPDATE SET NULL;
ALTER TABLE CHANNELS ADD CONSTRAINT FK_CHANNELS_1 FOREIGN KEY (CONTRACT_ID) REFERENCES DISTRIB_CONTRACTS (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE CUSTLETTER ADD CONSTRAINT FK_CUSTLETTER_CUST FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER ADD CONSTRAINT FK_CUSTOMER_HOUSE FOREIGN KEY (HOUSE_ID) REFERENCES HOUSE (HOUSE_ID) ON DELETE CASCADE;
ALTER TABLE CUSTOMER_ATTRIBUTES ADD CONSTRAINT FK_CUSTOMER_ATTRIBUTES_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_BONUSES ADD CONSTRAINT FK_CUSTOMER_BONUSES_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_CHANNELS ADD CONSTRAINT FK_CUSTOMER_CHANNELS_1 FOREIGN KEY (DECODER_ID) REFERENCES CUSTOMER_DECODERS (DEC_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_CONTACTS ADD CONSTRAINT FK_CUSTOMER_CONTACTS_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_DECODERS ADD CONSTRAINT FK_CUSTOMER_DECODERS_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_EQUIPMENT ADD CONSTRAINT FK_CUSTOMER_EQUIPMENT_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUSTOMER_FILES ADD CONSTRAINT FK_CUSTOMER_FILES_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE DEVPORTS ADD CONSTRAINT FK_DEVICES_DEVICE FOREIGN KEY (DEVICE) REFERENCES DEVICES (ID) ON DELETE CASCADE;
ALTER TABLE DISTRIB_CONTRACTS ADD CONSTRAINT FK_DISTRIB_CONTRACTS_1 FOREIGN KEY (DISTRIBUTOR_ID) REFERENCES DISTRIBUTOR (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE EPG_MAPPING ADD CONSTRAINT FK_EPG_MAPPING_1 FOREIGN KEY (EPG_ID) REFERENCES EPG_SOURCES (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE EPG_MAPPING_GENRE ADD CONSTRAINT FK_EPG_MAPPING_GENRE_1 FOREIGN KEY (EPG_ID) REFERENCES EPG_SOURCES (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE HOUSE ADD CONSTRAINT FK_HOUSE_1 FOREIGN KEY (STREET_ID) REFERENCES STREET (STREET_ID);
ALTER TABLE HOUSE ADD CONSTRAINT FK_HOUSE_2 FOREIGN KEY (ORG_ID) REFERENCES ORGANIZATION (ORG_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE HOUSEFLOOR ADD CONSTRAINT FK_HOUSEFLOOR_1 FOREIGN KEY (PORCH_ID) REFERENCES HOUSEPORCH (PORCH_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE HOUSEPORCH ADD CONSTRAINT FK_HOUSEPORCH_1 FOREIGN KEY (HOUSE_ID) REFERENCES HOUSE (HOUSE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE HOUSEWORKS ADD CONSTRAINT FK_HOUSEWORKS_1 FOREIGN KEY (HOUSE_ID) REFERENCES HOUSE (HOUSE_ID);
ALTER TABLE MAP_XY ADD CONSTRAINT FK_MAP_XY_OBJECT FOREIGN KEY (OBJECT) REFERENCES MAP (ID) ON DELETE CASCADE;
ALTER TABLE MONTHLY_FEE ADD CONSTRAINT FK_MONTHLY_FEE_CUST FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE;
ALTER TABLE NODE_FILES ADD CONSTRAINT FK_NODE_FILES_1 FOREIGN KEY (NODE_ID) REFERENCES NODES (NODE_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJECTS ADD CONSTRAINT FK_OBJECTS_TYPE FOREIGN KEY (O_TYPE) REFERENCES OBJECTS_TYPE (OT_ID);
ALTER TABLE OTHER_FEE ADD CONSTRAINT FK_OTHER_FEE_CUST FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE;
ALTER TABLE PAYMENT ADD CONSTRAINT FK_PAYMENT_CUST FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE;
ALTER TABLE PAYMENT ADD CONSTRAINT FK_PAYMENT_PAY_DOC FOREIGN KEY (PAY_DOC_ID) REFERENCES PAY_DOC (PAY_DOC_ID) ON DELETE CASCADE;
ALTER TABLE PREPAY_DETAIL ADD CONSTRAINT FK_PREPAY_DETAIL_CUST FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE;
ALTER TABLE REQUEST ADD CONSTRAINT FK_REQUEST_CUST FOREIGN KEY (RQ_CUSTOMER) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE REQUEST ADD CONSTRAINT FK_REQUEST_HOUSE FOREIGN KEY (HOUSE_ID) REFERENCES HOUSE (HOUSE_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE REQUEST_EXECUTORS ADD CONSTRAINT FK_REQUEST_EXECUTORS_1 FOREIGN KEY (RQ_ID) REFERENCES REQUEST (RQ_ID) ON DELETE CASCADE;
ALTER TABLE REQUEST_MATERIALS ADD CONSTRAINT FK_REQUEST_MATERIALS_1 FOREIGN KEY (RQ_ID) REFERENCES REQUEST (RQ_ID) ON DELETE CASCADE;
ALTER TABLE REQUEST_MATERIALS_RETURN ADD CONSTRAINT FK_REQUEST_MATERIALS_RETURN_1 FOREIGN KEY (RQ_ID) REFERENCES REQUEST (RQ_ID) ON DELETE CASCADE;
ALTER TABLE REQUEST_MSG ADD CONSTRAINT FK_REQUEST_MSG_1 FOREIGN KEY (RQ_ID) REFERENCES REQUEST (RQ_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE REQUEST_TEMPLATES ADD CONSTRAINT FK_REQUEST_TEMPLATES_1 FOREIGN KEY (RQ_TYPE) REFERENCES REQUEST_TYPES (RT_ID);
ALTER TABLE REQUEST_WORKS ADD CONSTRAINT FK_REQUEST_WORKS_R FOREIGN KEY (RQ_ID) REFERENCES REQUEST (RQ_ID) ON DELETE CASCADE;
ALTER TABLE REQUEST_WORKS ADD CONSTRAINT FK_REQUEST_WORKS_W FOREIGN KEY (W_ID) REFERENCES WORKS (W_ID);
ALTER TABLE SINGLE_SERV ADD CONSTRAINT FK_SINGLE_SERV_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SUBAREA ADD CONSTRAINT FK_SUBAREA_1 FOREIGN KEY (AREA_ID) REFERENCES AREA (AREA_ID);
ALTER TABLE SUBSCR_HIST ADD CONSTRAINT FK_SUBSCR_HIST_SUB_SERV FOREIGN KEY (SUBSCR_SERV_ID) REFERENCES SUBSCR_SERV (SUBSCR_SERV_ID) ON DELETE CASCADE;
ALTER TABLE SUBSCR_SERV ADD CONSTRAINT FK_SUBSCR_SERV_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE;
ALTER TABLE TASKMSG ADD CONSTRAINT FK_TASKMSG_1 FOREIGN KEY (TASK_ID) REFERENCES TASKLIST (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TASKUSER ADD CONSTRAINT FK_TASKUSER_1 FOREIGN KEY (TASK_ID) REFERENCES TASKLIST (ID);
ALTER TABLE TV_LAN ADD CONSTRAINT FK_TV_LAN_1 FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER (CUSTOMER_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TV_LAN_PACKETS ADD CONSTRAINT FK_TV_LAN_PACKETS_1 FOREIGN KEY (LAN_ID) REFERENCES TV_LAN (LAN_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE WORKGROUPS ADD CONSTRAINT FK_WORKGROUPS_1 FOREIGN KEY (WA_ID) REFERENCES WORKAREA (WA_ID);
CREATE INDEX ALL_USED_IP_IDX1 ON ALL_USED_IP (IP);
CREATE INDEX ALL_USED_IP_IDX2 ON ALL_USED_IP (IP_BIN);
CREATE INDEX APPLIANCE_OWNER ON APPLIANCE (OWN_TYPE, OWN_ID);
CREATE INDEX PK_APPLIANCE_ID ON APPLIANCE (ID);
CREATE INDEX ATTRIBUTE_IDX_ATTR ON ATTRIBUTE (AID, OBJECT_ID, TYPE_ID);
CREATE INDEX ATTRIBUTE_IDX_OBJECT ON ATTRIBUTE (OBJECT_ID, AID, TYPE_ID);
CREATE INDEX BCISSUE_IDX1 ON BCISSUE (ADDED_ON);
CREATE INDEX BILLING_IDX_CID ON BILLING (CUSTOMER_ID);
CREATE INDEX BILLING_IDX_IP ON BILLING (IP_INET);
CREATE INDEX BILLING_IDX_IP_BIN ON BILLING (IP_INET_BIN);
CREATE INDEX BILLING_IDX_LOGIN ON BILLING (LOGIN);
CREATE INDEX BILLING_IDX_UID ON BILLING (UNIT_ID);
CREATE INDEX BLOB_TBL_TYPE_OWN ON BLOB_TBL (BL_TYPE, OWNER_ID);
CREATE INDEX BONUS_RATE_IDX1 ON BONUS_RATE (BT_ID, UNITS_FROM, UNITS_TO);
CREATE INDEX CHANGELOG_IDX1 ON CHANGELOG (LOG_GROUP, OBJECT_ID);
CREATE INDEX CHANNELS_IDX_FRQ ON CHANNELS (CH_FREQ);
CREATE INDEX PK_CHANNELS_ID ON CHANNELS (CH_ID);
CREATE INDEX CHANNEL_SRCP_IDX_CH_ID ON CHANNEL_SRC_PARAM (CH_ID);
CREATE INDEX CONNECT_LOG_IDX1 ON CONNECT_LOG (CONNECT_DATE);
CREATE INDEX CONNECT_LOG_IDX2 ON CONNECT_LOG (CONNECT_ADDRESS);
CREATE INDEX CUSTLETTER_CUSTOMER_ID ON CUSTLETTER (CUSTOMER_ID, LETTERTYPEID);
CREATE INDEX CSTMR_CUST_CODE ON CUSTOMER (CUST_CODE);
CREATE INDEX CSTMR_UPPER_ACCOUNT ON CUSTOMER COMPUTED BY (UPPER(ACCOUNT_NO));
CREATE INDEX CUSTOMER_IDX_DOG ON CUSTOMER (DOGOVOR_NO);
CREATE INDEX CUSTOMER_IDX_ORG ON CUSTOMER (ORG_ID);
CREATE INDEX CUSTOMER_IDX_VD ON CUSTOMER (VALID_TO);
CREATE INDEX CUSTOMER_INVSBL ON CUSTOMER (INVISIBLE, CUSTOMER_ID);
CREATE UNIQUE INDEX UNQ_CSTMR_EXT_ID ON CUSTOMER (EXTERNAL_ID);
CREATE INDEX CUSTOMER_ATTRIBUTES_IDX1 ON CUSTOMER_ATTRIBUTES (CA_ID);
CREATE INDEX CUSTOMER_ATTRIBUTES_OID ON CUSTOMER_ATTRIBUTES (O_ID);
CREATE INDEX CUSTOMER_BONUSES_IDX1 ON CUSTOMER_BONUSES (ID, BONUS_DATE);
CREATE INDEX CUSTOMER_CHANNELS_IDX1 ON CUSTOMER_CHANNELS (CH_ID, DECODER_ID, DATE_ON, DATE_OFF);
CREATE INDEX CUSTOMER_CONTACTS_IDX1 ON CUSTOMER_CONTACTS (CC_TYPE, CUSTOMER_ID, CC_VALUE);
CREATE INDEX CUSTOMER_CONTACTS_IDX_REVERSE ON CUSTOMER_CONTACTS (CC_VAL_REVERSE);
CREATE INDEX CUSTOMER_DECODERS_IDX1 ON CUSTOMER_DECODERS (STB_N);
CREATE INDEX DAYS_TARIF_IDX1 ON DAYS_TARIF (SERV_ID, T_DAY);
CREATE INDEX DEVICES_IDX_MAC ON DEVICES (MACADDRESS);
CREATE INDEX DEVICES_IDX_NODE1 ON DEVICES (NODE1);
CREATE INDEX DEVICES_IDX_NODE2 ON DEVICES (NODE2);
CREATE INDEX DEVICES_IDX_OBJECT ON DEVICES (OBJECT);
CREATE INDEX DEVPORTS_IDX_DEV ON DEVPORTS (DEVICE);
CREATE INDEX DEVPORTS_IDX_LINK ON DEVPORTS (LINK);
CREATE INDEX DEVPORTS_IDX_NODE ON DEVPORTS (NODE);
CREATE INDEX DEVPROFILES_IDX_NAME ON DEVPROFILES (NAME);
CREATE INDEX DISCOUNT_FACTOR_IDX1 ON DISCOUNT_FACTOR (CUSTOMER_ID, SERV_ID, DATE_FROM);
CREATE INDEX DISCOUNT_FACTOR_IDX2 ON DISCOUNT_FACTOR (DATE_FROM, SERV_ID);
CREATE UNIQUE INDEX DISTRIB_CARDS_IDX1 ON DISTRIB_CARDS (CARD);
CREATE INDEX DISTRIB_CONTRACT_CH_IDX1 ON DISTRIB_CONTRACT_CH (CONTRACT_ID, CH_ID);
CREATE INDEX DISTRIB_CONTRACT_REPORTS_IDX1 ON DISTRIB_CONTRACT_REPORTS (PERIOD);
CREATE INDEX DVB_STREAMS_ID ON DVB_STREAMS (DVBS_ID, DVBN_ID);
CREATE INDEX DVB_STREAMS_IDX_FRQ ON DVB_STREAMS (FREQ);
CREATE INDEX DVB_STREAM_CHANNELS_IDX1 ON DVB_STREAM_CHANNELS (CH_ID);
CREATE INDEX EPG_EPG_ID ON EPG (EPG_ID);
CREATE INDEX EPG_IDX1 ON EPG (CH_ID, EPG_DATE);
CREATE INDEX EPG_IDX_DATE_CH ON EPG (EPG_DATE, CH_ID);
CREATE INDEX EQUIPMENT_IDX_HID ON EQUIPMENT (HOUSE_ID);
CREATE INDEX EQUIPMENT_IDX_VLAN_ID ON EQUIPMENT (VLAN_ID);
CREATE INDEX EQUIPMENT_ATTRIBUTES_IDX1 ON EQUIPMENT_ATTRIBUTES (EID);
CREATE INDEX EQUIPMENT_CMD_GRP_IDX1 ON EQUIPMENT_CMD_GRP (EG_ID);
CREATE INDEX EQUIPMENT_COVERAGE_IDX1 ON EQUIPMENT_COVERAGE (HOUSE_ID);
CREATE INDEX EQUIPMENT_DVB_T_N ON EQUIPMENT_DVB (EQ_TYPE, EQ_N);
CREATE INDEX EQUIPMENT_HISTORY_IDX1 ON EQUIPMENT_HISTORY (EQ_N, EDIT_ON);
CREATE INDEX EQUIPMENT_LOG_IDX1 ON EQUIPMENT_LOG (EQ_ID, LOG_DATE);
CREATE INDEX EVENT_DETAIL_IDX1 ON EVENT_DETAIL (CUSTOMER_ID, EVENT_ID, E_DATE);
CREATE INDEX GPS_LOG_GW ON GPS_LOG (GPS_TIME, WORKER);
CREATE INDEX GPS_LOG_WG ON GPS_LOG (WORKER, GPS_TIME);
CREATE INDEX HEADEND_CHANNELS_IDX1 ON HEADEND_CHANNELS (HE_ID);
CREATE INDEX HOUSE_IDX_HE ON HOUSE (HEADEND_ID);
CREATE INDEX HOUSE_IDX_WG ON HOUSE (WG_ID);
CREATE INDEX IDX_HOUSE_SA ON HOUSE (SUBAREA_ID);
CREATE INDEX HOUSEFLOOR_IDX1 ON HOUSEFLOOR (PORCH_ID, FLAT_FROM, FLAT_TO);
CREATE INDEX HOUSEPORCH_IDX1 ON HOUSEPORCH (PORCH_N, FLAT_FROM, FLAT_TO);
CREATE INDEX HOUSES_ATTRIBUTES_OID ON HOUSES_ATTRIBUTES (O_ID);
CREATE INDEX INVENTORY_IDX_OM ON INVENTORY (OWNER_TYPE, OWNER, M_ID);
CREATE INDEX MAP_IDX_ADDRESS ON MAP (ADDRESS);
CREATE INDEX MAP_IDX_MODIFIED ON MAP (MODIFIED);
CREATE INDEX MAP_IDX_NAME ON MAP (NAME);
CREATE INDEX MAP_IDX_TYPE ON MAP (O_TYPE);
CREATE INDEX MAP_XY_IDX_MODIFIED ON MAP_XY (MODIFIED);
CREATE INDEX MAP_XY_IDX_OBJECT ON MAP_XY (OBJECT);
CREATE INDEX MATERIALS_IN_DOC_IDX1 ON MATERIALS_IN_DOC (DOC_ID, M_ID);
CREATE INDEX MATERIALS_IN_DOC_IDX2 ON MATERIALS_IN_DOC (M_ID);
CREATE INDEX MATERIALS_REMAIN_IDX1 ON MATERIALS_REMAIN (M_ID, WH_ID, MR_COST);
CREATE INDEX MATERIALS_REMAIN_IDX2 ON MATERIALS_REMAIN (WH_ID, M_ID);
CREATE INDEX MESSAGES_IDX1 ON MESSAGES (MES_TYPE, ADDED_ON);
CREATE INDEX MESSAGES_IDX2 ON MESSAGES (CUSTOMER_ID);
CREATE INDEX MONTHLY_FEE_CUST_DATE ON MONTHLY_FEE (CUSTOMER_ID, MONTH_ID);
CREATE INDEX MONTHLY_FEE_CUST_SERV ON MONTHLY_FEE (CUSTOMER_ID, SERVICE_ID);
CREATE INDEX MONTHLY_FEE_MONTH_SERV ON MONTHLY_FEE (MONTH_ID, SERVICE_ID);
CREATE INDEX MONTHLY_FEE_MON_CUST ON MONTHLY_FEE (MONTH_ID, CUSTOMER_ID);
CREATE INDEX MONTHLY_FEE_SERV_ID ON MONTHLY_FEE (SERVICE_ID);
CREATE INDEX MONTHLY_FREEZE_CUST_DATE ON MONTHLY_FREEZE (CUSTOMER_ID, MONTH_ID);
CREATE INDEX MONTHLY_FREEZE_CUST_SERV ON MONTHLY_FREEZE (CUSTOMER_ID, SERVICE_ID);
CREATE INDEX MONTHLY_FREEZE_MONTH_SERV ON MONTHLY_FREEZE (MONTH_ID, SERVICE_ID);
CREATE INDEX MONTHLY_FREEZE_MON_CUST ON MONTHLY_FREEZE (MONTH_ID, CUSTOMER_ID);
CREATE INDEX MONTHLY_FREEZE_SERV_ID ON MONTHLY_FREEZE (SERVICE_ID);
CREATE INDEX NODES_IDX1 ON NODES (HOUSE_ID);
CREATE INDEX NODES_ATTRIBUTES_IDX1 ON NODES_ATTRIBUTES (NA_ID);
CREATE INDEX NODES_ATTRIBUTES_OID ON NODES_ATTRIBUTES (O_ID);
CREATE INDEX NODE_FLATS_IDX_NODES ON NODE_FLATS (NODE_ID);
CREATE INDEX NPS_IDX_CID ON NPS (CUSTOMER_ID);
CREATE INDEX NPS_IDX_DATE ON NPS (NPS_DATE);
CREATE INDEX OBJECTS_IDX1 ON OBJECTS (O_TYPE, O_ID);
CREATE INDEX OBJECTS_COVERAGE_IDX1 ON OBJECTS_COVERAGE (OC_TYPE, O_ID);
CREATE INDEX ORDERS_TP_IDX_DATE ON ORDERS_TP (OTP_DATE);
CREATE INDEX ORDERS_TP_IDX_TYPE ON ORDERS_TP (OTTP_TYPE);
CREATE INDEX OTHER_FEE_IDX1 ON OTHER_FEE (CUSTOMER_ID, FEE_DATE);
CREATE INDEX OTHER_FEE_IDX2 ON OTHER_FEE (FEE_DATE, CUSTOMER_ID);
CREATE INDEX PAYMENT_CUST_DATE ON PAYMENT (CUSTOMER_ID, PAY_DATE);
CREATE INDEX PAYMENT_DATE ON PAYMENT (PAY_DATE);
CREATE INDEX PAYMENT_IDX1 ON PAYMENT (CUSTOMER_ID, TAG);
CREATE INDEX PAY_EXT_SYS_IDX ON PAYMENT (EXT_PAY_ID);
CREATE INDEX PAYMENT_DELETED_IDX1 ON PAYMENT_DELETED (PAY_DOC_ID);
CREATE INDEX PAYMENT_DELETED_IDX2 ON PAYMENT_DELETED (EXT_PAY_ID);
CREATE INDEX PAY_DOC_DATE ON PAY_DOC (PAY_DOC_DATE);
CREATE INDEX PAY_ERRORS_PDOC ON PAY_ERRORS (PAY_DOC_ID);
CREATE INDEX PTARIF_SERVID ON PERSONAL_TARIF (SERVICE_ID, DATE_FROM);
CREATE INDEX PERS_TARIF_TMP_IDX1 ON PERS_TARIF_TMP (SERV_ID, T_DAY);
CREATE INDEX PORT_IDX_WID ON PORT (WID);
CREATE INDEX PREPAY_DETAIL_DATE ON PREPAY_DETAIL (PPD_DATE);
CREATE INDEX QRATING_IDX_DATE ON QRATING (QR_DATE);
CREATE INDEX QRATING_IDX_OID ON QRATING (QR_TYPE, OBJECT_ID);
CREATE INDEX RECOURSE_IDX_ADDED ON RECOURSE (ADDED_ON);
CREATE INDEX RECOURSE_IDX_CUST ON RECOURSE (CUSTOMER_ID);
CREATE INDEX RECOURSE_IDX_HOUSE ON RECOURSE (HOUSE_ID);
CREATE INDEX RECOURSE_IDX_TYPE ON RECOURSE (RC_TYPE);
CREATE INDEX REMINDER_IDX1 ON REMINDER (REM_USER, REM_DATE);
CREATE INDEX IDX_REQUEST_CUST ON REQUEST (RQ_TYPE);
CREATE INDEX REQUEST_EXEC_D ON REQUEST (RQ_EXEC_TIME);
CREATE INDEX REQUEST_IDX1 ON REQUEST (RQ_COMPLETED);
CREATE INDEX REQUEST_IDX2 ON REQUEST (REQ_RESULT);
CREATE INDEX REQUEST_IDX3 ON REQUEST (ADDED_ON);
CREATE INDEX REQUEST_IDX4 ON REQUEST (NODE_ID);
CREATE INDEX REQUEST_PLAN_D ON REQUEST (RQ_PLAN_DATE);
CREATE INDEX REQUEST_EXECUTORS_IDX1 ON REQUEST_EXECUTORS (EXEC_ID);
CREATE INDEX REQUEST_MATERIALS_IDX1 ON REQUEST_MATERIALS (WH_ID, M_ID);
CREATE INDEX REQUEST_MATERIALS_IDX2 ON REQUEST_MATERIALS (RQ_ID, WH_ID, M_ID);
CREATE INDEX REQUEST_MATERIALS_RETURN_IDX1 ON REQUEST_MATERIALS_RETURN (WH_ID, M_ID);
CREATE INDEX REQUEST_MATERIALS_RETURN_IDX2 ON REQUEST_MATERIALS_RETURN (RQ_ID, WH_ID, M_ID);
CREATE INDEX REQUEST_RESULTS_IDX1 ON REQUEST_RESULTS (RT_ID);
CREATE INDEX SERVICES_PK_ID ON SERVICES (SERVICE_ID);
CREATE INDEX SERVICES_TYPES ON SERVICES (SRV_TYPE_ID, SHIFT_MONTHS);
CREATE INDEX SERVICES_ATTRIBUTES_OID ON SERVICES_ATTRIBUTES (O_ID);
CREATE INDEX SERVICES_LINKS_TYPE ON SERVICES_LINKS (LINK_TYPE);
CREATE INDEX SINGLE_SERV_CUSTOMER_SERV ON SINGLE_SERV (CUSTOMER_ID, SERVICE_ID);
CREATE INDEX SINGLE_SERV_SERV_DATE ON SINGLE_SERV (SERVICE_ID, SERV_DATE);
CREATE UNIQUE INDEX STAT_IP_IDX ON STAT_IP (IP_BIN, STAT_DATE, TC_ID);
CREATE INDEX SUBSCR_HIST_DDATE_TO ON SUBSCR_HIST (DATE_TO);
CREATE INDEX SUBSCR_HIST_DFT ON SUBSCR_HIST (DATE_FROM, DATE_TO);
CREATE INDEX SUBSCR_HIST_IDX1 ON SUBSCR_HIST (CUSTOMER_ID, SERV_ID);
CREATE INDEX SUBSCR_HIST_IDX2 ON SUBSCR_HIST (CUSTOMER_ID, DATE_FROM, DATE_TO);
CREATE INDEX SUBSCR_HIST_IDX_DATES ON SUBSCR_HIST (SERV_ID, DATE_FROM, DATE_TO);
CREATE INDEX SUBSCR_HIST_SRV_CUST ON SUBSCR_HIST (SERV_ID, CUSTOMER_ID);
CREATE INDEX SUBSCR_SERV_CONTRACT ON SUBSCR_SERV (CONTRACT);
CREATE INDEX SUBSCR_SERV_C_ID_SATET ON SUBSCR_SERV (STATE_SGN, CUSTOMER_ID);
CREATE INDEX SUBSCR_SERV_SRV_CUST ON SUBSCR_SERV (SERV_ID, CUSTOMER_ID);
CREATE INDEX SYS$GROUP_RIGHTS_IDX1 ON SYS$GROUP_RIGHTS COMPUTED BY (coalesce(rights_type,0));
CREATE INDEX SYS$GROUP_RIGHTS_IDX2 ON SYS$GROUP_RIGHTS (GROUP_ID, RIGHTS_TYPE);
CREATE INDEX TARIF_SERVID ON TARIF (SERVICE_ID);
CREATE INDEX TASKLIST_D_A_E ON TASKLIST (DELETED, ADDED_BY, EXEC_DATE);
CREATE INDEX TMP_COL_DATE ON TMP_COL (C_DATE);
CREATE INDEX TMP_COL_INT_STR ON TMP_COL (C_INT, C_STR);
CREATE INDEX TMP_COL_NUM ON TMP_COL (C_NUM);
CREATE INDEX TMP_COL_STR ON TMP_COL (C_STR);
CREATE INDEX TQUEUE_IDX_STATE ON TQUEUE (STATUS);
CREATE INDEX TV_LAN_EID ON TV_LAN (EQ_ID);
CREATE INDEX TV_LAN_IDX_IP_BIN ON TV_LAN (IP_BIN);
CREATE INDEX TV_LAN_VLAN ON TV_LAN (VLAN_ID);
CREATE INDEX WIRE_IDX_END ON WIRE (POINT_E);
CREATE INDEX WIRE_IDX_START ON WIRE (POINT_S);
CREATE INDEX WIRE_POINT_IDX_NODE ON WIRE_POINT (NODE_ID);
CREATE INDEX WORKER_IDX1 ON WORKER (IBNAME);
CREATE INDEX WORKER_IDX_TEAM ON WORKER (TEAM);
CREATE INDEX WORKS_IDX1 ON WORKS (RQ_TYPE);


CREATE OR ALTER TRIGGER TR_ON_CONNECT
ACTIVE ON CONNECT POSITION 0
as
begin
  --insert into connect_log (connect_date, connect_user) values (localtimestamp, current_user);
  /*
  in autonomous transaction do
  begin
    update Sys$User
    set Last_Logged = localtimestamp
    where (Ibname = CURRENT_USER);
  end
  */
end;

CREATE OR ALTER TRIGGER ALL_USED_IP_BIU FOR ALL_USED_IP
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
   NEW.IP_BIN = INET_ATON(NEW.IP);
end;

CREATE OR ALTER TRIGGER APPLIANCE_BI FOR APPLIANCE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Id is null) then
    new.Id = gen_id(Gen_Appliance_Uid, 1);

  if (new.OWN_TYPE is null) then
    new.OWN_TYPE = 0;

  if (new.Property is null) then
    new.Property = 1;

  if ((new.Name is null) and (not new.M_Id is null)) then
    select
        m.Name
      from materials m
      where m.M_Id = new.M_Id
    into new.Name;

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER AREA_AU FOR AREA
ACTIVE AFTER UPDATE POSITION 0
as
  declare variable CUSTOMER_ID type of Uid;
  declare variable HOUSE_ID    type of Uid;
  declare variable FLAT_NO     type of D_FLAT;
  declare variable CUST_CODE   type of D_Varchar20;
begin
  if (new.Area_Code is distinct from old.Area_Code) then
  begin
    for select C.Customer_Id, c.House_Id, c.Flat_No
          from Customer C
                inner join House H on (C.House_Id = H.House_Id)
                inner join Street S on (H.Street_Id = S.Street_Id)
          where S.Area_Id = new.Area_Id
        into :customer_id, :HOUSE_ID, :FLAT_NO
    do
    begin
      execute procedure GET_CUSTOMER_CODE(:HOUSE_ID, :FLAT_NO)
        returning_values :CUST_CODE;
      update customer
        set Cust_Code = :CUST_CODE
        where Customer_Id = :CUSTOMER_ID;
    end
  end
end;

CREATE OR ALTER TRIGGER AREA_BI0 FOR AREA
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.AREA_ID is null) then new.AREA_ID = GEN_ID(gen_operations_uid,1);
 if (new.Area_Code='') then new.Area_Code = null;
end;

CREATE OR ALTER TRIGGER AREA_BU FOR AREA
ACTIVE BEFORE UPDATE POSITION 0
as
begin
 if (new.Area_Code='') then new.Area_Code = null;
end;

CREATE OR ALTER TRIGGER ATTRIBUTE_BIU0 FOR ATTRIBUTE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.AValue = coalesce(new.AValue, '');
  new.ADeleted = coalesce(new.ADeleted, 0);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.edit_by = current_user;
    new.edit_on = localtimestamp;
    if (old.AValue is distinct from new.AValue) then
      new.OValue = old.AValue;
    else
      new.OValue = null;
  end
end;

CREATE OR ALTER TRIGGER BCISSUE_BIU FOR BCISSUE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.BI_ID = coalesce(new.BI_ID, gen_id(GEN_ISSUE, 1));
  new.SOLUTION = coalesce(new.SOLUTION, 0);
  new.Dtv = coalesce(new.Dtv, 0);
  new.Atv = coalesce(new.Atv, 0);
  new.Iptv = coalesce(new.Iptv, 0);
  new.Ott = coalesce(new.Ott, 0);
  new.ALTER_CONFIG = coalesce(new.ALTER_CONFIG, 0);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER BILLING_BI FOR BILLING
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (NEW.blng_id is null) then new.blng_id = gen_id(gen_operations_uid,1);

  NEW.IP_INET_BIN = INET_ATON(NEW.IP_INET);
  NEW.secret = coalesce(NEW.secret, NEW.secret_web);
end;

CREATE OR ALTER TRIGGER BLB_GZIP_BI FOR BLB_GZIP
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (NEW.BLB_ID is null) then NEW.BLB_ID = GEN_ID(Gen_Blb,1);
end;

CREATE OR ALTER TRIGGER BLOB_TBL_BI FOR BLOB_TBL
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (NEW.Bl_Id is null) then NEW.Bl_Id = GEN_ID(Gen_Blb,1);
  NEW.bl_name = upper(new.bl_name);
end;

CREATE OR ALTER TRIGGER BONUS_RATE_BI FOR BONUS_RATE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(Gen_Uid, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER BONUS_RATE_BU FOR BONUS_RATE
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER CARDS_PREPAY_AD FOR CARDS_PREPAY
ACTIVE AFTER DELETE POSITION 0
as
begin
  if (not OLD.Payment_Id is null)
  then DELETE FROM Payment WHERE (Payment_Id = OLD.Payment_Id);
end;

CREATE OR ALTER TRIGGER CARDS_PREPAY_BIU0 FOR CARDS_PREPAY
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Card_Id is null) then
    new.Card_Id = gen_id(Gen_Card_Id, 1);
  if (new.Card_Pin is null) then
    new.Card_Pin = 0;
  if (new.Payment_Id is null) then
    new.Card_State = 0;
  else
    new.Card_State = 1;
  if (inserting) then
    new.Added_By = current_user;
end;

CREATE OR ALTER TRIGGER CARDS_SERIALS_BI FOR CARDS_SERIALS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  IF (NEW.Cs_Id IS NULL) THEN
    NEW.Cs_Id = GEN_ID(Gen_Card_Id,1);
end;

CREATE OR ALTER TRIGGER CHANGELOG_BI FOR CHANGELOG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  NEW.log_id = coalesce(NEW.log_id, gen_id(g_log_id,1));
  NEW.Log_Group = upper(NEW.Log_Group);
  NEW.Param = upper(NEW.Param);
  NEW.who_change  = current_user;
  NEW.when_change = localtimestamp;
end;

CREATE OR ALTER TRIGGER CHANNELS_AD FOR CHANNELS
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from CHANNELS_IN_SERVCE where Ch_Id = old.Ch_Id;
  delete from CHANNEL_SRC_PARAM where Ch_Id = old.Ch_Id;
  delete from CUSTOMER_CHANNELS where Ch_Id = old.Ch_Id;
  delete from DISTRIB_CONTRACT_CH where Ch_Id = old.Ch_Id;
  delete from DVB_STREAM_CHANNELS where Ch_Id = old.Ch_Id;
  delete from EPG where Ch_Id = old.Ch_Id;
  delete from EPG_AD_CHANNELS where Ch_Id = old.Ch_Id;
  delete from EPG_LOCAL where Ch_Id = old.Ch_Id;
  delete from EPG_MAPPING where Ch_Id = old.Ch_Id;
  delete from HEADEND_CHANNELS where Ch_Id = old.Ch_Id;
  delete from IPTV_GROUP_CHANNELS where Ch_Id = old.Ch_Id;
end;

CREATE OR ALTER TRIGGER CHANNELS_BI FOR CHANNELS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable i d_integer;
begin
  if (new.Ch_Id is null) then
    new.Ch_Id = gen_id(Gen_Operations_Uid, 1);

  if (new.ch_trunk = 0) then
    new.ch_trunk = 1;

  if (new.Lang is null) then
    new.Lang = 'RUS';
  else
    new.Lang = upper(new.Lang);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_BI FOR CHANNEL_SRC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Cs_Id is null) then
    new.Cs_Id = gen_id(GEN_UID, 1);
  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_BU FOR CHANNEL_SRC
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.EDIT_BY = current_user;
  new.EDIT_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_PARAM_AD FOR CHANNEL_SRC_PARAM
ACTIVE AFTER DELETE POSITION 0
as
begin
  update Channel_Src s
  set s.Added_By = current_user
  where s.Cs_Id = OLD.Cs_Id;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_PARAM_AU FOR CHANNEL_SRC_PARAM
ACTIVE AFTER UPDATE POSITION 0
as
begin
  update Channel_Src s
  set s.Added_By = current_user
  where s.Cs_Id = NEW.Cs_Id;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_PARAM_BI FOR CHANNEL_SRC_PARAM
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_PARAM_BIU0 FOR CHANNEL_SRC_PARAM
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.On_Analog = coalesce(new.On_Analog, 0);
  new.On_Dvb = coalesce(new.On_Dvb, 0);
  new.On_Iptv = coalesce(new.On_Iptv, 0);

  if (new.On_Analog = 1) then
    update CHANNEL_SRC_PARAM
    set On_Analog = 0
    where Ch_Id = new.Ch_Id
          and Cs_Id <> new.Cs_Id;

  if (new.On_Dvb = 1) then
    update CHANNEL_SRC_PARAM
    set On_Dvb = 0
    where Ch_Id = new.Ch_Id
          and Cs_Id <> new.Cs_Id;

  if (new.On_Iptv = 1) then
    update CHANNEL_SRC_PARAM
    set On_Iptv = 0
    where Ch_Id = new.Ch_Id
          and Cs_Id <> new.Cs_Id;
end;

CREATE OR ALTER TRIGGER CHANNEL_SRC_PARAM_BU FOR CHANNEL_SRC_PARAM
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.EDIT_BY = current_user;
  new.EDIT_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER CONNECT_LOG_BI FOR CONNECT_LOG
ACTIVE BEFORE INSERT POSITION 0
as
declare variable s d_varchar255;
begin

  select first 1 a.Mon$Remote_Process from Mon$Attachments a where a.Mon$Attachment_Id = current_connection
  into :s;
  NEW.connect_address = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');
  NEW.connect_exe = s;

end;

CREATE OR ALTER TRIGGER CUSTLETTER_BIU0 FOR CUSTLETTER
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.CUSTLETTERID is null) then
    new.CUSTLETTERID = gen_id(gen_operations_uid, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_ATTRIBUTES_AD FOR CUSTOMER_ATTRIBUTES
ACTIVE AFTER DELETE POSITION 1
as
begin
  IF (not OLD.CUSTOMER_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, OLD.CUSTOMER_ID, 'CUSTOMER_ID', 'DELETE', OLD.CUSTOMER_ID);
  IF (not OLD.O_Id IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, OLD.CUSTOMER_ID, 'O_ID', 'DELETE', OLD.O_Id);
  IF (not OLD.Ca_Value IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, OLD.CUSTOMER_ID, 'CA_VALUE', 'DELETE', OLD.Ca_Value);
  IF (not OLD.Notice IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, OLD.CUSTOMER_ID, 'NOTICE', 'DELETE', OLD.Notice);
end;

CREATE OR ALTER TRIGGER CUSTOMER_ATTRIBUTES_AIUD FOR CUSTOMER_ATTRIBUTES
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
as
declare variable CODE D_VARCHAR500;
begin
  if ((new.CUSTOMER_ID is distinct from old.CUSTOMER_ID)
      or
      (new.O_ID is distinct from old.O_ID)) then begin

    select
        A_LINE
      from ATRIBUTES_LINE(old.CUSTOMER_ID)
    into :CODE;

    update CUSTOMER
    set CUST_PROP = :CODE
    where (CUSTOMER_ID = old.CUSTOMER_ID);

    if (new.CUSTOMER_ID is distinct from old.CUSTOMER_ID) then begin
      select
          A_LINE
        from ATRIBUTES_LINE(new.CUSTOMER_ID)
      into :CODE;

      update CUSTOMER
      set CUST_PROP = :CODE
      where (CUSTOMER_ID = new.CUSTOMER_ID);
    end
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_ATTRIBUTES_AU FOR CUSTOMER_ATTRIBUTES
ACTIVE AFTER UPDATE POSITION 1
as
begin
  IF (new.CUSTOMER_ID is distinct from old.CUSTOMER_ID) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, NEW.CUSTOMER_ID, 'CUSTOMER_ID', OLD.CUSTOMER_ID, NEW.CUSTOMER_ID);
  IF (new.O_Id is distinct from old.O_Id) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, NEW.CUSTOMER_ID, 'O_ID', OLD.O_Id, NEW.O_Id);
  IF (new.Ca_Value is distinct from old.Ca_Value) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, NEW.CUSTOMER_ID, 'CA_VALUE', OLD.Ca_Value, NEW.Ca_Value);
  IF (new.Notice is distinct from old.Notice) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('ATTRIBUTE', 0, NEW.CUSTOMER_ID, 'NOTICE', OLD.Notice, NEW.Notice);
end;

CREATE OR ALTER TRIGGER CUSTOMER_ATTRIBUTES_BIU0 FOR CUSTOMER_ATTRIBUTES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.ca_id is null) then
    new.ca_id = gen_id(gen_uid, 1);
  if (new.ca_value is null) then
    new.ca_value = '';
  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_AU_MONEY FOR CUSTOMER
ACTIVE AFTER UPDATE POSITION 3
as
begin
  if ((new.debt_sum < 0) and (old.debt_sum > 0)) then
    execute procedure Change_To_Positive(new.Customer_Id, old.Debt_Sum, new.Debt_Sum, new.House_Id, new.Flat_No);

  if (old.Contract_Date is distinct from new.Contract_Date) then
    execute procedure Full_Recalc_Customer(new.Customer_Id);
end;

CREATE OR ALTER TRIGGER CUSTOMER_BI0 FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.CUSTOMER_ID is null) then
    new.CUSTOMER_ID = gen_id(GEN_CUSTOMER_UID, 1);
  if (new.flat_no is null) then
    new.flat_no = '';

  if (new.Surname is null) then
    new.Surname = '';
  else
    new.Surname = trim(new.Surname);

  if (new.FIRSTNAME is null) then
    new.FIRSTNAME = '';
  else
    new.FIRSTNAME = trim(new.FIRSTNAME);

  if (new.MIDLENAME is null) then
    new.MIDLENAME = '';
  else
    new.MIDLENAME = trim(new.MIDLENAME);

  if (trim(new.EXTERNAL_ID) = '') then
    new.EXTERNAL_ID = null;
  if (new.hand_control is null) then
    new.hand_control = 0;

  if (new.Secret is null) then
    select
        Pwd
      from Gen_Password(8, 10)
    into new.Secret;

  select
      cust_code
    from get_customer_code(new.HOUSE_ID, new.FLAT_NO)
  into new.CUST_CODE;

  select
      RESULT
    from extract_number(new.flat_no)
  into new.FLAT_DIGIT;

  if (new.Juridical = 1) then begin
    new.INITIALS = substring(new.FIRSTNAME from 1 for 10);
    new.Jur_Inn = trim(new.Jur_Inn);
  end
  else
    new.INITIALS = trim(substring(new.FIRSTNAME from 1 for 1) || ' ' || substring(new.MIDLENAME from 1 for 1));

  if ((not new.Bank_Id is null) and (new.Juridical = 1)) then begin
    select
        o.O_Name
      , o.O_Dimension
      from objects o
      where o.O_Id = new.Bank_Id
            and o.O_Type = 11
    into new.Bank, new.PERSONAL_N;
  end

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER CUSTOMER_BONUSES_AD FOR CUSTOMER_BONUSES
ACTIVE AFTER DELETE POSITION 0
as
begin
  update CUSTOMER C
  set C.DEBT_SUM = C.DEBT_SUM + round(OLD.Bonus, 2)
  where C.CUSTOMER_ID = OLD.CUSTOMER_ID;
end;

CREATE OR ALTER TRIGGER CUSTOMER_BONUSES_AI FOR CUSTOMER_BONUSES
ACTIVE AFTER INSERT POSITION 0
as
begin
  update CUSTOMER C
  set C.DEBT_SUM = C.DEBT_SUM - round(NEW.Bonus, 2)
  where C.CUSTOMER_ID = NEW.CUSTOMER_ID;
end;

CREATE OR ALTER TRIGGER CUSTOMER_BONUSES_AU FOR CUSTOMER_BONUSES
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (new.Customer_Id is distinct from old.Customer_Id) then begin
    update CUSTOMER C
    set C.DEBT_SUM = C.DEBT_SUM + round(old.Bonus, 2)
    where C.CUSTOMER_ID = old.CUSTOMER_ID;

    update CUSTOMER C
    set C.DEBT_SUM = C.DEBT_SUM - round(new.Bonus, 2)
    where C.CUSTOMER_ID = new.CUSTOMER_ID;
  end
  else begin
    if (new.Bonus is distinct from old.Bonus) then begin
      update CUSTOMER C
      set C.DEBT_SUM = C.DEBT_SUM + round(old.Bonus, 2) - round(new.Bonus, 2)
      where C.CUSTOMER_ID = new.CUSTOMER_ID;
    end
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_BONUSES_BIU0 FOR CUSTOMER_BONUSES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Id is null) then
    new.Id = gen_id(gen_uid, 1);

  new.Bonus = coalesce(new.Bonus, 0);
  new.Bonus_Date = coalesce(new.Bonus_Date, current_date);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_BU0 FOR CUSTOMER
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if ((new.debt_sum = old.debt_sum) and (old.Cust_State_Descr is not distinct from new.Cust_State_Descr)) then begin

    if (new.flat_no is null) then
      new.flat_no = '';

    if (new.Surname is null) then
      new.Surname = '';
    else
      new.Surname = trim(new.Surname);

    if (new.FIRSTNAME is null) then
      new.FIRSTNAME = '';
    else
      new.FIRSTNAME = trim(new.FIRSTNAME);

    if (new.MIDLENAME is null) then
      new.MIDLENAME = '';
    else
      new.MIDLENAME = trim(new.MIDLENAME);

    if ((new.HOUSE_ID is distinct from old.HOUSE_ID)
        or
        (new.FLAT_NO is distinct from old.FLAT_NO)) then begin
      select
          cust_code
        from get_customer_code(new.HOUSE_ID, new.FLAT_NO)
      into new.CUST_CODE;
      select
          RESULT
        from extract_number(new.flat_no)
      into new.FLAT_DIGIT;
    end

    if (new.hand_control is null) then
      new.hand_control = 0;

    if (new.Juridical = 1) then begin
      new.INITIALS = substring(new.FIRSTNAME from 1 for 10);
      new.Jur_Inn = trim(new.Jur_Inn);
    end
    else
      new.INITIALS = trim(substring(new.FIRSTNAME from 1 for 1) || ' ' || substring(new.MIDLENAME from 1 for 1));

    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;

  end

  if (trim(new.EXTERNAL_ID) = '') then
    new.EXTERNAL_ID = null;

  if ((old.Bank_Id is distinct from new.Bank_Id) and (new.Juridical = 1)) then begin
    if (not new.Bank_Id is null) then begin
      select
          o.O_Name
        , o.O_Dimension
        from objects o
        where o.O_Id = new.Bank_Id
              and o.O_Type = 11
      into new.Bank, new.PERSONAL_N;
    end
    else begin
      new.Bank = null;
      new.PERSONAL_N = null;
    end
  end

  -- если меняли паспорт, сбросим флаг проверки паспорта
  if ((old.Passport_Number is distinct from new.Passport_Number)
      or
      (old.Passport_Registration is distinct from new.Passport_Registration)
      or
      (old.Surname is distinct from new.Surname)
      or
      (old.Firstname is distinct from new.Firstname)
      or
      (old.Midlename is distinct from new.Midlename)) then begin
    new.Passport_Valid = null;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_BU1 FOR CUSTOMER
ACTIVE BEFORE UPDATE POSITION 1
as
begin
  if (old.debt_sum is distinct from new.debt_sum) then begin
    if ((new.debt_sum > 0) and (old.debt_sum < 0)) then
      new.TIME_ON_MINUS = localtimestamp;
    if ((new.debt_sum < 0) and (old.debt_sum > 0)) then
      new.TIME_ON_MINUS = null;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_CHANNELS_AD FOR CUSTOMER_CHANNELS
ACTIVE AFTER UPDATE OR DELETE POSITION 0
as
begin
  update customer_decoders d
  set d.last_update = localtimestamp
  where d.dec_id = old.decoder_id;
end;

CREATE OR ALTER TRIGGER CUSTOMER_CHANNELS_BI FOR CUSTOMER_CHANNELS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
  if (new.date_on is null) then
    new.date_on = current_date;
  if (new.date_off is null) then
    new.date_off = cast('2100-01-01' as date);
  update customer_decoders d
  set d.last_update = localtimestamp
  where d.dec_id = new.decoder_id;
end;

CREATE OR ALTER TRIGGER CUSTOMER_CHANNELS_BU FOR CUSTOMER_CHANNELS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.date_on is null) then
    new.date_on = current_date;
  if (new.date_off is null) then
    new.date_off = cast('2100-01-01' as date);

  new.edit_by = current_user;
  new.edit_on = localtimestamp;

  update customer_decoders d
  set d.last_update = localtimestamp
  where d.dec_id = new.decoder_id;
end;

CREATE OR ALTER TRIGGER CUSTOMER_CONTACTS_AD FOR CUSTOMER_CONTACTS
ACTIVE AFTER DELETE POSITION 0
as
declare variable s d_varchar255;
begin
  select list(cc.cc_value, ',') from customer_contacts cc
      where cc.customer_id = OLD.customer_id and cc.cc_type = OLD.cc_type
  into :S;

  if (OLD.cc_type = 0)
  then
    update customer c
        set c.phone_no = LEFT(:s, 50)
        where c.customer_id = OLD.customer_id;

  if (OLD.cc_type = 1)
  then
    update customer c
        set c.mobile_phone = LEFT(:s, 50)
        where c.customer_id = OLD.customer_id;

  if (OLD.cc_type = 2)
  then
    update customer c
        set c.email = LEFT(:s, 50)
        where c.customer_id = OLD.customer_id;

end;

CREATE OR ALTER TRIGGER CUSTOMER_CONTACTS_AI FOR CUSTOMER_CONTACTS
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
declare variable s d_varchar255;
declare variable o d_varchar255;
declare variable u d_integer;
begin
  -- обновим контакты в таблице абонентов
  if (new.cc_type <= 2) then begin
    select
        list(cc.cc_value, ',')
      from customer_contacts cc
      where cc.customer_id = new.customer_id
            and cc.cc_type = new.cc_type
    into :S;

    u = 0;

    if ((new.cc_type is distinct from old.Cc_Type)
        or
        (old.Customer_Id is distinct from new.Customer_Id)) then begin
      u = 1;
      select
          list(cc.cc_value, ',')
        from customer_contacts cc
        where cc.customer_id = old.customer_id
              and cc.cc_type = old.cc_type
      into :o;
    end

    if (new.cc_type = 0) then
      update customer c
      set c.phone_no = left(:s, 50)
      where c.customer_id = new.customer_id;

    if (new.cc_type = 1) then
      update customer c
      set c.mobile_phone = left(:s, 50)
      where c.customer_id = new.customer_id;

    if (new.cc_type = 2) then
      update customer c
      set c.email = left(:s, 50)
      where c.customer_id = new.customer_id;

    if (u = 1) then begin
      if (old.cc_type = 0) then
        update customer c
        set c.phone_no = left(:o, 50)
        where c.customer_id = old.customer_id;

      if (old.cc_type = 1) then
        update customer c
        set c.mobile_phone = left(:o, 50)
        where c.customer_id = old.customer_id;

      if (old.cc_type = 2) then
        update customer c
        set c.email = left(:o, 50)
        where c.customer_id = old.customer_id;
    end
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_CONTACTS_BIU FOR CUSTOMER_CONTACTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable s d_varchar255;
begin
  if ((new.cc_value is null)
      or
      (new.cc_value = '')) then
    exception e_not_empty;

  if (new.Cc_Notify is null) then
    new.Cc_Notify = 1;

  -- select DIGITS from extract_all_digits(new.cc_value) into :S;
  S = ONLY_DIGITS(new.cc_value);
  if (s <> '') then
    new.cc_val_reverse = reverse(s);
  else
    new.cc_val_reverse = '';

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_AD0 FOR CUSTOMER_DECODERS
ACTIVE AFTER DELETE POSITION 0
as
declare variable srv D_Varchar10;
begin
  if (old.decoder_n is not null) then begin
    update EQUIPMENT_DVB
    set EQ_state = 1
    where EQ_n = old.decoder_n;

    delete from decoder_packets
        where decoder_n = old.decoder_n;

    -- добавим услугу если есть такая в настройках
    select
        s.Var_Value
      from Settings s
      where s.Var_Name = 'CARD_DEL_SRV'
    into :srv;
    if (coalesce(srv, '') <> '') then
      execute procedure Add_Single_Service(old.Customer_Id, cast(srv as integer), 1, current_date, old.Decoder_N);
  end

  if (not old.stb_n is null) then
    update EQUIPMENT_DVB
    set EQ_state = 1
    where EQ_n = old.stb_n;

  execute procedure DIGITAL_EVENT(2, old.customer_id, old.decoder_n, null, null, null);
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_AI FOR CUSTOMER_DECODERS
ACTIVE AFTER INSERT POSITION 1
as
declare variable srv D_Varchar10;
begin
  if (new.decoder_n is not null) then begin
    execute procedure DIGITAL_EVENT(1, new.customer_id, new.decoder_n, null, null, null);
    -- добавим услугу если есть такая в настройках
    select
        s.Var_Value
      from Settings s
      where s.Var_Name = 'CARD_ADD_SRV'
    into :srv;
    if (coalesce(srv, '') <> '') then
      execute procedure Add_Single_Service(new.Customer_Id, cast(srv as integer), 1, current_date, new.Decoder_N);
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_AIU0 FOR CUSTOMER_DECODERS
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin

  if (new.DECODER_N is distinct from old.DECODER_N) then begin
    if (new.DECODER_N is not null) then
      update EQUIPMENT_DVB D
      set D.EQ_STATE = 2
      where D.EQ_N = new.DECODER_N;

    if (old.DECODER_N is not null) then
      update EQUIPMENT_DVB D
      set D.EQ_STATE = 1
      where D.EQ_N = old.DECODER_N;

  end

  if (new.STB_N is distinct from old.STB_N) then begin
    if (new.Stb_N is not null) then
      update EQUIPMENT_DVB
      set EQ_STATE = 2
      where EQ_N = new.STB_N;

    if (old.Stb_N is not null) then
      update EQUIPMENT_DVB
      set EQ_STATE = 1
      where EQ_N = old.STB_N;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_AU FOR CUSTOMER_DECODERS
ACTIVE AFTER UPDATE POSITION 1
as
declare variable srv D_Varchar10;
begin
  if ((new.decoder_n is distinct from old.decoder_n)
      or
      (old.customer_id is distinct from new.customer_id)) then begin
    update decoder_packets
    set decoder_n = new.decoder_n
    where decoder_n = old.decoder_n;
    if (new.decoder_n is not null) then begin
      execute procedure DIGITAL_EVENT(1, new.customer_id, new.decoder_n, null, null, null);
      -- добавим услугу если есть такая в настройках
      select
          s.Var_Value
        from Settings s
        where s.Var_Name = 'CARD_ADD_SRV'
      into :srv;
      if (coalesce(srv, '') <> '') then
        execute procedure Add_Single_Service(new.Customer_Id, cast(srv as integer), 1, current_date, new.Decoder_N);
    end
    if (old.decoder_n is not null) then begin
      execute procedure DIGITAL_EVENT(2, old.customer_id, old.decoder_n, null, null, null);
      srv = null;
      -- добавим услугу если есть такая в настройках
      select
          s.Var_Value
        from Settings s
        where s.Var_Name = 'CARD_DEL_SRV'
      into :srv;
      if (coalesce(srv, '') <> '') then
        execute procedure Add_Single_Service(old.Customer_Id, cast(srv as integer), 1, current_date, old.Decoder_N);
    end
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_BI FOR CUSTOMER_DECODERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  -- номер декодера не может быть пустым
  if (new.Decoder_N is null) then
    exception E_Not_Empty;

  if (new.Customer_Id is null) then
    exception E_Not_Empty;

  if (new.Dec_Id is null) then
    new.Dec_Id = gen_id(Gen_Operations_Uid, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
  new.last_update = localtimestamp;
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_BIU2 FOR CUSTOMER_DECODERS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
as
begin

  if (new.Decoder_N is distinct from old.Decoder_N) then begin
    if (not exists(select
                       *
                     from EQUIPMENT_DVB
                     where EQ_N = new.DECODER_N)) then
      exception E_DECODER_ERROR;
    new.Pairing = 0;
  end

  if ((new.Stb_N is distinct from old.Stb_N) and (not new.Stb_N is null)) then begin
    if (not exists(select
                       *
                     from EQUIPMENT_DVB
                     where EQ_N = new.Stb_N)) then
      exception E_DECODER_ERROR;
    new.Pairing = 0;
  end
end;

CREATE OR ALTER TRIGGER CUSTOMER_DECODERS_BU0 FOR CUSTOMER_DECODERS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  -- номер декодера не может быть пустым
  if (new.Decoder_N is null) then
    exception E_Not_Empty;

  if (new.Customer_Id is null) then
    exception E_Not_Empty;

  if (new.Dec_Id is null) then
    new.Dec_Id = gen_id(Gen_Operations_Uid, 1);

  new.edit_by = current_user;
  new.edit_on = localtimestamp;
  new.last_update = localtimestamp;
end;

CREATE OR ALTER TRIGGER CUSTOMER_EQUIPMENT_BI FOR CUSTOMER_EQUIPMENT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  -- номер декодера не может быть пустым
  if (new.EQUIP_N is null) then
    exception E_Not_Empty;

  if (new.Customer_Id is null) then
    exception E_Not_Empty;

  if (new.CE_ID is null) then
    new.CE_ID = gen_id(GEN_EQ_ID, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER CUSTOMER_FILES_BI FOR CUSTOMER_FILES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.CF_ID is null) then
    new.CF_ID = gen_id(Gen_Operations_Uid, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER DECODER_PACKETS_AD FOR DECODER_PACKETS
ACTIVE AFTER DELETE POSITION 0
as
begin
  execute procedure DIGITAL_EVENT_DECODER(old.decoder_n, null, old.Service_Id);
end;

CREATE OR ALTER TRIGGER DECODER_PACKETS_AI FOR DECODER_PACKETS
ACTIVE AFTER INSERT POSITION 0
as
begin
  execute procedure DIGITAL_EVENT_DECODER(new.decoder_n, new.Service_Id, null);
end;

CREATE OR ALTER TRIGGER DECODER_PACKETS_AU FOR DECODER_PACKETS
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if ((new.DECODER_N is distinct from old.DECODER_N)
      or
      (new.Service_Id is distinct from old.Service_Id)) then begin
    execute procedure DIGITAL_EVENT_DECODER(old.decoder_n, null, old.Service_Id);
    execute procedure DIGITAL_EVENT_DECODER(new.decoder_n, new.Service_Id, null);
  end
end;

CREATE OR ALTER TRIGGER DECODER_PACKETS_BI FOR DECODER_PACKETS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER DEVICES_BI0 FOR DEVICES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.id = coalesce(new.id, gen_id(gen_devices_id, 1));
  new."TYPE" = coalesce(new."TYPE", '');
  new.subtype = coalesce(new.subtype, '');
  new.login = coalesce(new.login, '');
  new."PASSWORD" = coalesce(new."PASSWORD", '');
  new.ssid = coalesce(new.ssid, '');
  new.psk = coalesce(new.psk, '');
  new.ip = coalesce(new.ip, '');
  new.community = coalesce(new.community, '');
  new.name = coalesce(new.name, '');
  new.firmname = coalesce(new.firmname, '');
  new.colorscheme = coalesce(new.colorscheme, '');
  new.numports = coalesce(new.numports, 0);
  new.bandleports = coalesce(new.bandleports, 0);
  new.macaddress = coalesce(new.macaddress, '');
  new.note = coalesce(new.note, '');
end;

CREATE OR ALTER TRIGGER DEVICES_BU0 FOR DEVICES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.modified = CURRENT_TIMESTAMP;
end;

CREATE OR ALTER TRIGGER DEVPORTS_BI0 FOR DEVPORTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_devports_id, 1);
  if (new.number is null) then
    new.number = 0;
  if (new.node is null) then
    new.node = 0;
  if (new.snmp_ID is null) then
    new.snmp_ID = 0;
  if (new.name is null) then
    new.name = '';
  if (new.porttype is null) then
    new.porttype = '';
  if (new.module is null) then
    new.module = '';
  if (new.color is null) then
    new.color = '';
  if (new.coloropt is null) then
    new.coloropt = 'solid';
  if (new.bandle is null) then
    new.bandle = '';
  if (new.note is null) then
    new.note = '';
end;

CREATE OR ALTER TRIGGER DEVPORTS_BU0 FOR DEVPORTS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.link=0) then
    new.link = null;
  if (new.divide=0.0) then
    new.divide = null;
  new.modified = CURRENT_TIMESTAMP;
end;

CREATE OR ALTER TRIGGER DEVPROFILES_BI0 FOR DEVPROFILES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.id = coalesce(new.id, gen_id(gen_devprofiles_id, 1));
  new.name = coalesce(new.name, '');
  new.port = coalesce(new.port, 0);
  new.rucolor = coalesce(new.rucolor, '');
  new.color = coalesce(new.color, '');
  new."OPTION" = coalesce(new."OPTION", '');
  new.htmlcolor = coalesce(new.htmlcolor, '');
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_AD FOR DISCOUNT_FACTOR
ACTIVE AFTER DELETE POSITION 0
as
begin
  if (old.Date_From < current_date) then
    execute procedure FULL_RECALC_CUSTOMER(OLD.CUSTOMER_ID, old.Date_From);
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_AI FOR DISCOUNT_FACTOR
ACTIVE AFTER INSERT POSITION 0
as
declare variable d D_DATE;
begin
  select
      cast(VAR_VALUE as date)
    from SETTINGS S
    where S.VAR_NAME = 'CURRENT_DATE'
  into :d;
  d = coalesce(d, Month_First_Day(current_date));
  d = dateadd(1 month to d);
  if (new.Date_From < d) then
    execute procedure FULL_RECALC_CUSTOMER(new.CUSTOMER_ID, new.Date_From);
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_AU FOR DISCOUNT_FACTOR
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if ((new.Date_From < current_date)
      or
      (old.Date_From < current_date)) then
    execute procedure FULL_RECALC_CUSTOMER(new.CUSTOMER_ID);
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_BD FOR DISCOUNT_FACTOR
ACTIVE BEFORE DELETE POSITION 0
as
declare variable F_MONTH  D_DATE;
declare variable inStrict D_IBOOLEAN;
declare variable OP_DATE  D_DATE;
begin
  select
      cast(s.Var_Value as date)
    from settings s
    where s.Var_Name = 'CURRENT_DATE'
  into :F_MONTH;

  if ((old.Date_From < F_MONTH)
      or
      (old.Date_To < F_MONTH)) then begin
    select
        cast(s.Var_Value as integer)
      from settings s
      where s.Var_Name = 'STRICT_MODE'
    into :inStrict;
    inStrict = coalesce(inStrict, 1);
    if (inStrict = 1) then
      exception E_Strict_Mode;
  end
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_BI0 FOR DISCOUNT_FACTOR
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.DISCOUNT_ID is null) then
    new.DISCOUNT_ID = gen_id(gen_operations_uid, 1);
  if (new.SERV_ID is null) then
    new.SERV_ID = -1;
  if (new.DATE_TO is null) then
    new.DATE_TO = '2100-01-01';
  if (new.Srv_Type is null) then
    new.Srv_Type = -1;
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER DISCOUNT_FACTOR_BU0 FOR DISCOUNT_FACTOR
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.SERV_ID is null) then
    new.SERV_ID = -1;
  if (new.DATE_TO is null) then
    new.DATE_TO = '2100-01-01';
  if (new.Srv_Type is null) then
    new.Srv_Type = -1;
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER DISTRIBUTOR_BI FOR DISTRIBUTOR
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(gen_operations_uid, 1);
end;

CREATE OR ALTER TRIGGER DISTRIB_CARDS_AI FOR DISTRIB_CARDS
ACTIVE AFTER INSERT POSITION 0
as
declare variable O_DELETED D_INTEGER;
begin
  select
      O_DELETED
    from OBJECTS o
    where o.O_TYPE = 44
          and o.O_Name = new.Card
  into :O_DELETED;

  if (O_DELETED is null) then
    insert into Objects (O_Type, O_Name, O_Deleted)
    values (44, new.Card, 0);
  else begin
    if (O_DELETED = 1) then
      update OBJECTS o
      set O_DELETED = 0
      where o.O_TYPE = 44
            and o.O_Name = new.Card;
  end
end;

CREATE OR ALTER TRIGGER DISTRIB_CONTRACTS_BI FOR DISTRIB_CONTRACTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(gen_operations_uid, 1);

  if (new.Delivery is null) then
    new.Delivery = 0;

  if (new.Report_Frmt is null) then
    new.Report_Frmt = 'PDF';
  else
    new.Report_Frmt = upper(new.Report_Frmt);
end;

CREATE OR ALTER TRIGGER DISTRIB_CONTRACT_REPORTS_AD FOR DISTRIB_CONTRACT_REPORTS
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from Distrib_Contract_Reports_Ch c
      where c.Contract_Id = old.Contract_Id
            and c.Period = old.Period;
end;

CREATE OR ALTER TRIGGER DISTRIB_CONTRACT_REPORTS_BIU0 FOR DISTRIB_CONTRACT_REPORTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  NEW.Period = NEW.Period - extract(day from NEW.Period) + 1;
end;

CREATE OR ALTER TRIGGER DVB_NETWORK_AD FOR DVB_NETWORK
ACTIVE AFTER DELETE POSITION 0
as
begin
   delete from Dvb_Streams where Dvbn_Id = old.Dvbn_Id;
end;

CREATE OR ALTER TRIGGER DVB_NETWORK_BI FOR DVB_NETWORK
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Dvbn_Id is null) then
    new.Dvbn_Id = gen_id(gen_operations_uid, 1);

  if (new.Lang is null) then
    new.Lang = 'RUS';
  else
    new.Lang = upper(new.Lang);

  if (new.Country is null) then
    new.Country = 'RUS';
  else
    new.Country = upper(new.Country);
end;

CREATE OR ALTER TRIGGER DVB_STREAMS_AD FOR DVB_STREAMS
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from Dvb_Stream_Channels
      where Dvbs_Id = old.Dvbs_Id;
  update Dvb_Network
  set Epg_Updated = localtimestamp
  where (Dvbn_Id = old.Dvbn_Id);
end;

CREATE OR ALTER TRIGGER DVB_STREAMS_AU FOR DVB_STREAMS
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin
  update Dvb_Network
  set Epg_Updated = localtimestamp
  where (Dvbn_Id = new.Dvbn_Id);
end;

CREATE OR ALTER TRIGGER DVB_STREAMS_BI FOR DVB_STREAMS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Dvbs_Id is null) then
    new.Dvbs_Id = gen_id(gen_operations_uid, 1);
end;

CREATE OR ALTER TRIGGER DVB_STREAM_CHANNELS_AD FOR DVB_STREAM_CHANNELS
ACTIVE AFTER DELETE POSITION 0
as
begin
  update Dvb_Streams
  set Epg_Updated = localtimestamp
  where (Dvbs_Id = old.Dvbs_Id);
end;

CREATE OR ALTER TRIGGER DVB_STREAM_CHANNELS_AIU0 FOR DVB_STREAM_CHANNELS
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin
  update Dvb_Streams
  set Epg_Updated = localtimestamp
  where (Dvbs_Id = new.Dvbs_Id);
end;

CREATE OR ALTER TRIGGER EPG_AD_BD FOR EPG_AD
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from Epg_Ad_Channels where Ea_Id = old.Id;
end;

CREATE OR ALTER TRIGGER EPG_AD_BIU0 FOR EPG_AD
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Id is null) then new.Id = gen_id(Gen_Operations_Uid,1);
  if (new.All_Chan is null) then new.All_Chan = 0;
end;

CREATE OR ALTER TRIGGER EPG_BIU0 FOR EPG
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Epg_Id is null) then
    new.Epg_Id = gen_id(Gen_Epg, 1);

  new.epg_date = cast(new.date_start as date);
  new.Utc_Date = cast(new.Utc_Start as date);

  if ((new.Duration is null) and (not new.Date_Stop is null)) then
    new.Duration = datediff(minute, new.date_start, new.Date_Stop);
  else begin
    if ((not new.Duration is null) and (new.Date_Stop is null)) then
      new.Date_Stop = dateadd(minute, new.Duration, new.date_start);
  end

  if (new.Create_Year = '0') then
    new.Create_Year = null;

  if (new.Genres = '') then
    new.Genres = null;
  if (new.Create_Year = '') then
    new.Create_Year = null;
  if (new.Actors = '') then
    new.Actors = null;
  if (new.Directed = '') then
    new.Directed = null;
  if (new.Country = '') then
    new.Country = null;
end;

CREATE OR ALTER TRIGGER EPG_SOURCES_AD FOR EPG_SOURCES
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from Epg_Mapping where Epg_Id = old.Id;
  delete from Epg_Mapping_Genre where Epg_Id = old.Id;
end;

CREATE OR ALTER TRIGGER EPG_SOURCES_BIU FOR EPG_SOURCES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(GEN_EPG, 1);

  if (new.HAND_ONLY is null) then
    new.HAND_ONLY = 0;

  if (new.LOCAL_TZONE is null) then
    new.LOCAL_TZONE = 0;

  if (new.Time_Shift is null) then
    new.Time_Shift = 0;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_AD0 FOR EQUIPMENT
ACTIVE AFTER DELETE POSITION 0
as
begin
  -- если порт очистили, сборсим в таблице портов
  if (not((old.Parent_Id is null)
      or
      (old.Parent_Port is null))) then begin
    update or insert into Port (Eid, Port, Con, Con_Id)
    values (old.Parent_Id, old.Parent_Port, null, null)
    matching (Eid, Port);
  end

  delete from equipment_coverage
      where eid = old.eid
            and house_id = old.house_id;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_AI0 FOR EQUIPMENT
ACTIVE AFTER INSERT POSITION 0
AS
begin
  if (not new.house_id is null)
  then
    insert into equipment_coverage (eid, house_id) values (NEW.eid, NEW.house_id);
end;

CREATE OR ALTER TRIGGER EQUIPMENT_AIU0 FOR EQUIPMENT
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin
  if (not((new.Parent_Id is null)
      or
      (new.Parent_Port is null))) then begin
    if (new.Parent_Id is distinct from old.Parent_Id) then begin
      if (new.Parent_Port is distinct from old.Parent_Port) then begin
        update or insert into Port (Eid, Port, Con, Con_Id)
        values (new.Parent_Id, new.Parent_Port, 0, new.Eid)
        matching (Eid, Port);
      end
    end
  end
end;

CREATE OR ALTER TRIGGER EQUIPMENT_ATTRIBUTES_BIU0 FOR EQUIPMENT_ATTRIBUTES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.ea_id is null) then
    new.ea_id = gen_id(gen_uid, 1);
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_AU0 FOR EQUIPMENT
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (new.house_id is distinct from old.house_id) then begin
    delete from equipment_coverage where eid = old.eid
          and house_id = old.house_id;

    if (not new.house_id is null) then begin
      if (not exists(select
                         *
                       from equipment_coverage
                       where eid = new.eid
                             and house_id = new.house_id)) then
        insert into equipment_coverage (eid, house_id)
        values (new.eid, new.house_id);
    end

    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('EQUIPMENT', 1, new.eid, 'ADDRESS', old.house_id, new.house_id);
  end

  -- если порт очистили, сборсим в таблице портов
  if ((not old.Parent_Id is null)
      and
      (not old.Parent_Port is null)) then begin
    if ((new.Parent_Port is distinct from old.Parent_Port)
        and
        (new.Parent_Id is distinct from old.Parent_Id)) then begin
      update or insert into Port (Eid, Port, Con, Con_Id)
      values (old.Parent_Id, old.Parent_Port, null, null)
      matching (Eid, Port);
    end
  end
end;

CREATE OR ALTER TRIGGER EQUIPMENT_BD FOR EQUIPMENT
ACTIVE BEFORE DELETE POSITION 0
as
declare variable CCOUNT d_INTEGER;
begin
  select
      count(*)
    from Tv_Lan t
    where t.Eq_Id = old.Eid
  into ccount;

  if (ccount <> 0) then
    exception E_CANNOT_DELETE;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_BIU FOR EQUIPMENT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable mac d_mac;
begin
  if (new.EID is null) then
    new.EID = gen_id(gen_operations_uid, 1);

  if ((new.Parent_Port <> '0') and (new.Parent_Port starting with '0')) then begin
    new.Parent_Port = trim(leading '0' from new.Parent_Port); /* Удалим 0 в начале */
  end
  if (new.Ip is not null) then
    select
        Int_Ip
      from Ip2int(new.IP)
    into new.Ip_Bin;
  if (not new.Ipv6 is null) then
    new.Ipv6 = lower(new.Ipv6);

  if (not new.MAC is null) then begin
    select
        MAC
      from FORMAT_MAC(new.MAC)
    into :Mac;
    new.mac = mac;
  end

  new.last_update = localtimestamp;
  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER EQUIPMENT_CMD_GRP_BIU0 FOR EQUIPMENT_CMD_GRP
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.ec_id is null) then new.ec_id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER EQUIPMENT_DGTL_AU0 FOR EQUIPMENT_DVB
ACTIVE AFTER UPDATE POSITION 0
as
declare variable CID type of UID;
begin
  if (new.EQ_STATE is distinct from old.EQ_STATE) then begin
    if (new.Eq_State = 2) then
      select
          CUSTOMER_ID
        from CUSTOMER_DECODERS CD
        where (CD.DECODER_N = new.EQ_N)
                or (CD.Stb_N = new.Eq_N)
      into :CID;
    insert into equipment_HISTORY (EQ_N, CUSTOMER_ID, EQ_STATE, OLD_STATE, EDIT_BY, EDIT_ON)
    values (new.EQ_N, :CID, new.EQ_STATE, old.Eq_State, current_user, localtimestamp);
  end
end;

CREATE OR ALTER TRIGGER EQUIPMENT_DGTL_BI FOR EQUIPMENT_DVB
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.eq_id is null) then
    new.eq_id = gen_id(GEN_EQ_ID, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_DGTL_BIU0 FOR EQUIPMENT_DVB
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.EQ_State is null) then
    new.EQ_state = 1;
end;

CREATE OR ALTER TRIGGER EQUIPMENT_DVB_AD FOR EQUIPMENT_DVB
ACTIVE AFTER DELETE POSITION 0
as
begin
  insert into equipment_HISTORY (EQ_N, CUSTOMER_ID, EQ_STATE, OLD_STATE, EDIT_BY, EDIT_ON)
  values (old.EQ_N, null, -1, old.Eq_State, current_user, localtimestamp);
end;

CREATE OR ALTER TRIGGER EVENT_DETAIL_BIU0 FOR EVENT_DETAIL
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.Event_Id = coalesce(new.Event_Id, gen_id(Gen_Uid, 1));
  new.E_Date = coalesce(new.E_Date, current_date);
  new.E_Year = coalesce(new.E_Year, extract(year from new.E_Date));
  new.E_Month = coalesce(new.E_Year, extract(month from new.E_Date));
  new.E_Day = coalesce(new.E_Year, extract(day from new.E_Date));
end;

CREATE OR ALTER TRIGGER FREQPLAN_BI FOR FREQPLAN
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.FQ_ID is null) then
    new.FQ_ID = gen_id(Gen_Operations_Uid, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER GPS_LOG_BI FOR GPS_LOG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Worker is null) then
    new.Worker = current_user;

  if (new.Gps_Time is null) then
    new.Gps_Time = localtimestamp;
end;

CREATE OR ALTER TRIGGER HEADEND_BI FOR HEADEND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.he_id is null) then new.he_id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER HOUSEFLATS_AD FOR HOUSEFLATS
ACTIVE AFTER DELETE POSITION 0
as
declare variable v_floor_id D_Uid_Null;
declare variable v_porch_id D_Uid_Null;
begin

  v_porch_id = null;
  v_floor_id = null;
  select
      p.Porch_Id
    from Houseporch p
    where p.House_Id = old.House_Id
          and p.Porch_N = old.Porch_N
  into :v_porch_id;

  if (not v_porch_id is null) then begin
    select
        f.Floor_Id
      from Housefloor f
      where f.Porch_Id = :v_porch_id
            and f.Floor_N = old.Floor_N
    into :v_floor_id;

    if (not v_floor_id is null) then
      update housefloor h
      set h.flats = substring((select
                                   list(distinct f.flat_no, ',')
                                 from houseflats f
                                 where f.porch_n = old.Porch_N
                                       and f.floor_n = old.Floor_N
                                       and f.House_Id = old.House_Id) from 1 for 1000)
      where h.Floor_Id = :v_floor_id;
  end
end;

CREATE OR ALTER TRIGGER HOUSEFLATS_AIU0 FOR HOUSEFLATS
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
declare variable v_floor_id D_Uid_Null;
declare variable v_porch_id D_Uid_Null;
begin
  select
      p.Porch_Id
    from Houseporch p
    where p.House_Id = new.House_Id
          and p.Porch_N = new.Porch_N
  into :v_porch_id;
  if (v_porch_id is null) then
    insert into Houseporch (House_Id, Porch_N)
    values (new.House_Id, new.Porch_N)
    returning (porch_id)
    into :v_porch_id;

  select
      f.Floor_Id
    from Housefloor f
    where f.Porch_Id = :v_porch_id
          and f.Floor_N = new.Floor_N
  into :v_floor_id;
  if (v_floor_id is null) then
    insert into Housefloor (Porch_Id, Floor_N)
    values (:v_porch_id, new.Floor_N)
    returning (floor_id)
    into :v_floor_id;

  update housefloor h
  set h.flats = substring((select
                               list(distinct f.flat_no, ',')
                             from houseflats f
                             where f.porch_n = new.Porch_N
                                   and f.floor_n = new.Floor_N
                                   and f.House_Id = new.House_Id) from 1 for 1000)
  where h.Floor_Id = :v_floor_id;

  if (updating) then begin
    if ((new.House_Id is distinct from old.House_Id)
        or
        (new.Porch_N is distinct from old.Porch_N)
        or
        (new.Floor_N is distinct from old.Floor_N)) then begin
      v_porch_id = null;
      v_floor_id = null;
      select
          p.Porch_Id
        from Houseporch p
        where p.House_Id = old.House_Id
              and p.Porch_N = old.Porch_N
      into :v_porch_id;

      if (not v_porch_id is null) then begin
        select
            f.Floor_Id
          from Housefloor f
          where f.Porch_Id = :v_porch_id
                and f.Floor_N = old.Floor_N
        into :v_floor_id;

        if (not v_floor_id is null) then
          update housefloor h
          set h.flats = substring((select
                                       list(distinct f.flat_no, ',')
                                     from houseflats f
                                     where f.porch_n = old.Porch_N
                                           and f.floor_n = old.Floor_N
                                           and f.House_Id = old.House_Id) from 1 for 1000)
          where h.Floor_Id = :v_floor_id;
      end
    end
  end
end;

CREATE OR ALTER TRIGGER HOUSEFLATS_BI0 FOR HOUSEFLATS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.flat_no is null) then
    new.flat_no = '';
  select
      RESULT
    from extract_number(new.flat_no)
  into new.FLAT_DIGIT;

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSEFLATS_BU0 FOR HOUSEFLATS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.flat_no is null) then
    new.flat_no = '';
  select
      RESULT
    from extract_number(new.flat_no)
  into new.FLAT_DIGIT;

  new.EDIT_by = current_user;
  new.EDIT_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSEFLOOR_BI FOR HOUSEFLOOR
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable f type of d_varchar500;
declare variable i type of d_integer;
begin
  if (NEW.Floor_Id is null) then  NEW.Floor_Id = GEN_ID(Gen_Operations_Uid,1);
  if (not new.flats is null)
  then begin
    f = trim(new.flats);
    f = REPLACE( f, '  ', ' ' );
    f = REPLACE( f, ' -', '-' );
    f = REPLACE( f, '- ', '-' );
    f = REPLACE( f, ' ',  ',' );
    f = REPLACE( f, '.',  ',' );
    f = REPLACE( f, ';',  ',' );
    f = REPLACE( f, '--', '-' );
    f = REPLACE( f, ',,', ',' );
    f = REPLACE( f, ',,', ',' );
    new.flats = f;

  end
end;

CREATE OR ALTER TRIGGER HOUSEPORCH_BI FOR HOUSEPORCH
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (NEW.Porch_Id is null) then  NEW.Porch_Id = GEN_ID(Gen_Operations_Uid,1);
end;

CREATE OR ALTER TRIGGER HOUSES_ATTRIBUTES_BI FOR HOUSES_ATTRIBUTES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.HA_ID is null) then
    new.HA_ID = gen_id(gen_uid, 1);
  if (new.HA_Value is null) then
    new.HA_Value = '';
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSES_ATTRIBUTES_BU FOR HOUSES_ATTRIBUTES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.HA_ID is null) then
    new.HA_ID = gen_id(gen_uid, 1);
  if (new.HA_Value is null) then
    new.HA_Value = '';
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSEWORKS_BIU0 FOR HOUSEWORKS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (NEW.hw_id is null) then new.hw_id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER HOUSE_AD0 FOR HOUSE
ACTIVE AFTER DELETE POSITION 0
AS
begin
    delete from houseflats f where f.house_id = old.house_id;
end;

CREATE OR ALTER TRIGGER HOUSE_AU FOR HOUSE
ACTIVE AFTER UPDATE POSITION 0
as
declare variable CUSTOMER_ID type of Uid;
declare variable HOUSE_ID    type of Uid;
declare variable FLAT_NO     type of D_FLAT;
declare variable CUST_CODE   type of D_Varchar20;
begin
  if (new.House_No is distinct from old.House_No) then begin
    for select
            C.Customer_Id
          , c.House_Id
          , c.Flat_No
          from Customer C
          where c.House_Id = new.House_Id
        into :customer_id, :HOUSE_ID, :FLAT_NO
    do begin
      execute procedure GET_CUSTOMER_CODE(:HOUSE_ID, :FLAT_NO)
          returning_values :CUST_CODE;
      update customer
      set Cust_Code = :CUST_CODE
      where Customer_Id = :CUSTOMER_ID;
    end
  end
end;

CREATE OR ALTER TRIGGER HOUSE_BI0 FOR HOUSE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.HOUSE_ID is null) then
    new.HOUSE_ID = gen_id(gen_operations_uid, 1);
  if (new.Q_Flat is null) then
    new.Q_Flat = 0;
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSE_BU FOR HOUSE
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.Q_Flat is null) then
    new.Q_Flat = 0;
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER HOUSE_CIRCUIT_BIU0 FOR HOUSE_CIRCUIT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Hc_Id is null) then
    new.Hc_Id = gen_id(Gen_Operations_Uid, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER INVENTORY_BIU0 FOR INVENTORY
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Quant is null) then
    new.Quant = 1;
  if (new.ownership is null) then
    new.ownership = 1;
  if (new.Serial is null) then
    new.Serial = '';
  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_ATTRIBUTES_BI FOR IPTV_GROUP_ATTRIBUTES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Iga_Id is null) then
    new.Iga_Id = gen_id(Gen_Operations_Uid, 1);
  new.Added_By = current_user;
  new.Added_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_ATTRIBUTES_BU FOR IPTV_GROUP_ATTRIBUTES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_BI FOR IPTV_GROUP
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Ig_Id is null) then
    new.Ig_Id = gen_id(Gen_Operations_Uid, 1);
  if (new.Disabled is null) then
    new.Disabled = 0;

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_BU FOR IPTV_GROUP
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.Disabled is null) then
    new.Disabled = 0;
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_CHANNELS_BI FOR IPTV_GROUP_CHANNELS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER IPTV_GROUP_CHANNELS_BU FOR IPTV_GROUP_CHANNELS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER JOURNAL_BI FOR JOURNAL
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.j_id is null) then
    new.j_id = gen_id(gen_journal, 1);
  if (new.j_date is null) then
    new.j_date = localtimestamp;
  if (new.j_whom is null) then
    new.j_whom = 'ALL';
end;

CREATE OR ALTER TRIGGER LETTERTYPE_BI0 FOR LETTERTYPE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.LETTERTYPEID is null) then
 new.LETTERTYPEID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER MAP_BI0 FOR MAP
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.id = coalesce(new.id, gen_id(GEN_MAP_ID, 1));
  new.name = coalesce(new.name, '');
  new.o_type = coalesce(new.o_type, '');
  new.subtype = coalesce(new.subtype, '');
  new.rayon = coalesce(new.rayon, 0);
  new.address = coalesce(new.address, '');
  new.gtype = coalesce(new.gtype, '');
  new.hostname = coalesce(new.hostname, '');
  new.service = coalesce(new.service, '');
  new.CONNECTED = coalesce(new.CONNECTED, 0);
  new.note = coalesce(new.note, '');
end;

CREATE OR ALTER TRIGGER MAP_BU0 FOR MAP
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.modified = CURRENT_TIMESTAMP;
end;

CREATE OR ALTER TRIGGER MAP_LOG_BIU0 FOR MAP_LOG
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.Unique_Id = coalesce(new.Unique_Id, gen_id(MAP_LOG_ID, 1));
  new.ACT_UId = coalesce(new.ACT_UId, gen_id(MAP_LOG_ID, 1));
end;

CREATE OR ALTER TRIGGER MAP_XY_BI0 FOR MAP_XY
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_map_xy_id, 1);
  if (new.slice is null) then
    new.slice = 0;
  if (new.num is null) then
    new.num = 0;
end;

CREATE OR ALTER TRIGGER MAP_XY_BU0 FOR MAP_XY
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.modified = CURRENT_TIMESTAMP;
end;

CREATE OR ALTER TRIGGER MATERIALS_BI FOR MATERIALS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.M_ID is null) then
    new.M_ID = gen_id(GEN_UID, 1);
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER MATERIALS_BU FOR MATERIALS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER MATERIALS_GROUP_BD FOR MATERIALS_GROUP
ACTIVE BEFORE DELETE POSITION 0
as
begin
  UPDATE Materials SET Mg_Id = null
  WHERE (Mg_Id = OLD.Mg_Id);
end;

CREATE OR ALTER TRIGGER MATERIALS_GROUP_BI FOR MATERIALS_GROUP
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (NEW.MG_ID is NULL) then NEW.MG_ID = GEN_ID(GEN_UID, 1);
end;

CREATE OR ALTER TRIGGER MATERIALS_IN_DOC_BI FOR MATERIALS_IN_DOC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(GEN_UID, 1);
  if (new.M_Quant is null) then
    new.M_Quant = 0;
  if (new.B_Quant is null) then
    new.B_Quant = 0;
  new.Added_On = localtimestamp;
  new.Added_By = current_user;
end;

CREATE OR ALTER TRIGGER MATERIALS_IN_DOC_BU FOR MATERIALS_IN_DOC
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.M_Quant is null) then
    new.M_Quant = 0;
  if (new.B_Quant is null) then
    new.B_Quant = 0;
  new.Edit_On = localtimestamp;
  new.Edit_By = current_user;
end;

CREATE OR ALTER TRIGGER MATERIALS_IN_DOC_UNIT_BI FOR MATERIALS_IN_DOC_UNIT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.Added_On = localtimestamp;
  new.Added_By = current_user;
end;

CREATE OR ALTER TRIGGER MATERIALS_IN_DOC_UNIT_BU FOR MATERIALS_IN_DOC_UNIT
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_On = localtimestamp;
  new.Edit_By = current_user;
end;

CREATE OR ALTER TRIGGER MATERIALS_REMAIN_BIU0 FOR MATERIALS_REMAIN
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.Mr_Quant = coalesce(new.Mr_Quant, 0);
end;

CREATE OR ALTER TRIGGER MATERIAL_DOCS_BD FOR MATERIAL_DOCS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (old.Doc_Closed = 1) then
    exception E_CANNOT_DELETE;
end;

CREATE OR ALTER TRIGGER MATERIAL_DOCS_BI0 FOR MATERIAL_DOCS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Doc_Id is null) then
    new.Doc_Id = gen_id(Gen_Uid, 1);
  new.Added_On = localtimestamp;
  new.Added_By = current_user;
end;

CREATE OR ALTER TRIGGER MATERIAL_DOCS_BU FOR MATERIAL_DOCS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_On = localtimestamp;
  new.Edit_By = current_user;
end;

CREATE OR ALTER TRIGGER MESSAGES_BI FOR MESSAGES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.mes_id is null) then
    new.mes_id = gen_id(GEN_QUEUE, 1);
  if (new.Mes_Result is null) then
    new.Mes_Result = 0;
  if (new.Mes_Prior is null) then
    new.Mes_Prior = 0;
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER MESSAGES_BU FOR MESSAGES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.Mes_Result is null) then
    new.Mes_Result = 0;
  if (new.Mes_Prior is null) then
    new.Mes_Prior = 0;
  if ((new.Mes_Result <> 0) and (new.Send_Date is null)) then
    new.Send_Date = localtimestamp;
end;

CREATE OR ALTER TRIGGER MODULES_BI0 FOR MODULES
ACTIVE BEFORE INSERT POSITION 0
as
begin
    if (new.Id_Module is null)
    then new.Id_Module = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER MONTHLY_FEE_AD_0 FOR MONTHLY_FEE
ACTIVE AFTER DELETE POSITION 0
as
begin
  execute procedure RecalcCustomerDebt(OLD.Customer_Id);
end;

CREATE OR ALTER TRIGGER MONTHLY_FEE_AI_0 FOR MONTHLY_FEE
ACTIVE AFTER INSERT POSITION 0
as
begin
  execute procedure RecalcCustomerDebt(NEW.Customer_Id);
end;

CREATE OR ALTER TRIGGER MONTHLY_FEE_AU_0 FOR MONTHLY_FEE
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (new.Customer_Id is distinct from old.Customer_Id) then
    execute procedure RecalcCustomerDebt(old.Customer_Id);

  execute procedure RecalcCustomerDebt(new.Customer_Id);
end;

CREATE OR ALTER TRIGGER MONTHLY_FEE_BIU0 FOR MONTHLY_FEE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER MONTHLY_FEE_STRICTCHECK FOR MONTHLY_FEE
ACTIVE BEFORE INSERT OR UPDATE OR DELETE POSITION 1
as
declare variable F_MONTH  D_DATE;
declare variable inStrict D_IBOOLEAN;
declare variable OP_DATE  D_DATE;
begin
  -- проверим в строгом режиме или нет
  if (deleting) then
    OP_DATE = old.Month_Id;
  else
    OP_DATE = new.Month_Id;

  if (OP_DATE < (current_date - extract(day from current_date) + 1)) then begin
    select
        cast(s.Var_Value as integer)
      from settings s
      where s.Var_Name = 'STRICT_MODE'
    into :inStrict;
    inStrict = coalesce(inStrict, 1);
    if (inStrict = 1) then begin
      select
          cast(s.Var_Value as date)
        from settings s
        where s.Var_Name = 'CURRENT_DATE'
      into :F_MONTH;

      if (OP_DATE < F_MONTH) then begin
        exception E_Strict_Mode;
      end
    end
  end
end;

CREATE OR ALTER TRIGGER MONTHLY_FREEZE_BI FOR MONTHLY_FREEZE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  NEW.Added_On = current_date;
end;

CREATE OR ALTER TRIGGER NODES_ATTRIBUTES_BI FOR NODES_ATTRIBUTES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.NA_ID is null) then
    new.NA_ID = gen_id(gen_uid, 1);
  if (new.NA_Value is null) then
    new.NA_Value = '';
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NODES_ATTRIBUTES_BU FOR NODES_ATTRIBUTES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.NA_ID is null) then
    new.NA_ID = gen_id(gen_uid, 1);
  if (new.NA_Value is null) then
    new.NA_Value = '';
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NODES_BI FOR NODES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Node_Id is null) then
    new.Node_Id = gen_id(Gen_Operations_Uid, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NODES_BU FOR NODES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.Node_Id is null) then
    new.Node_Id = old.Node_Id;

  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER NODE_FILES_BI FOR NODE_FILES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.NF_ID is null) then
    new.NF_ID = gen_id(Gen_Operations_Uid, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER NODE_FLATS_BI0 FOR NODE_FLATS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NODE_FLATS_BU0 FOR NODE_FLATS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.EDIT_by = current_user;
  new.EDIT_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NPS_BI FOR NPS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.NPS_DATE = current_date;
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER NPS_BU FOR NPS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER OBJECTS_BI0 FOR OBJECTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.O_ID is null) then
    new.O_ID = gen_id(GEN_UID, 1);
  if (new.O_Deleted is null) then
    new.O_Deleted = 0;
  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER OBJECTS_BIU1 FOR OBJECTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
as
declare variable s d_varchar1000;
begin
  if ((new.o_type = 4)
      or
      (new.o_type = 5)
      or
      (new.o_type = 6)
      or
      (new.o_type = 25)
      or
      (new.o_type = 32)) then begin
    if (not new.o_charfield is null) then begin
      select
          list(STR, ascii_char(13) || ascii_char(10))
        from EXPLODE_NO_EMPTY(',', new.o_charfield)
      into :s;
      select
          list(STR, ascii_char(13) || ascii_char(10))
        from EXPLODE_NO_EMPTY(';', :S)
      into :s;
      new.o_charfield = s;
    end
  end
  else begin
    -- пропишем права на склад владельцу
    if ((new.O_Type = 10) and (not new.O_Numericfield is null)) then begin
      update or insert into Sys$User_Wh (User_Id, Wh_Id, Can_View, Can_Edit)
      values (new.O_Numericfield, new.O_Id, 1, 1)
      matching (User_Id, Wh_Id);
    end
  end
end;

CREATE OR ALTER TRIGGER OBJECTS_BU FOR OBJECTS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.O_Deleted is null) then
    new.O_Deleted = 0;
  new.EDIT_BY = current_user;
  new.EDIT_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER OBJECTS_COVERAGE_BI FOR OBJECTS_COVERAGE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.oc_id is null)
  then new.oc_id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER OBJECTS_TYPE_BI0 FOR OBJECTS_TYPE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (NEW.OT_ID is NULL)
  then NEW.OT_ID = GEN_ID(GEN_UID, 1);
end;

CREATE OR ALTER TRIGGER OPERATION_LOG_BI FOR OPERATION_LOG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.Oper_Time = localtimestamp;
  new.Oper_Who = current_user;
  new.from_address = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');
end;

CREATE OR ALTER TRIGGER ORDERS_TP_BIU0 FOR ORDERS_TP
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Otp_Id is null) then
    new.Otp_Id = gen_id(GEN_ORDER_TP, 1);

  if (new.Otp_Number is null) then
    new.Otp_Number = new.Otp_Id;

  if ((not new.Quant is null) and (not new.Price is null)) then
    new.Amount = new.Quant * new.Price;

  if ((not new.customer_id is null) and (new.Adress is null) and (new.Fio is null)) then begin
    select
        trim(s.Street_Short || ' ' || s.Street_Name || ', ' || h.House_No || ', ' || c.Flat_No)
      , trim(c.Surname || ' ' || c.Firstname || ' ' || c.Midlename)
      from customer c
           inner join house h on (h.House_Id = c.House_Id)
           inner join street s on (s.Street_Id = h.Street_Id)
      where c.Customer_Id = new.Customer_Id
    into new.Adress, new.Fio;
  end

  if (inserting) then begin
    new.ADDED_BY = current_user;
    new.ADDED_ON = localtimestamp;
  end
  else begin
    new.EDIT_BY = current_user;
    new.EDIT_ON = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER ORGANIZATION_BI FOR ORGANIZATION
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (NEW.org_id is NULL) then NEW.ORG_ID = GEN_ID(GEN_UID, 1);
end;

CREATE OR ALTER TRIGGER OTHER_FEE_AD FOR OTHER_FEE
ACTIVE AFTER DELETE POSITION 0
as
begin
  execute procedure CUSTOMER_DEBT_ADD (OLD.CUSTOMER_ID, -1.00*old.fee);
end;

CREATE OR ALTER TRIGGER OTHER_FEE_AI FOR OTHER_FEE
ACTIVE AFTER INSERT POSITION 0
as
begin
  execute procedure CUSTOMER_DEBT_ADD (new.CUSTOMER_ID, new.fee);
end;

CREATE OR ALTER TRIGGER OTHER_FEE_AU FOR OTHER_FEE
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (old.CUSTOMER_ID = new.CUSTOMER_ID) then
    execute procedure CUSTOMER_DEBT_ADD(new.CUSTOMER_ID, (new.FEE - old.FEE));
  else begin
    execute procedure CUSTOMER_DEBT_ADD(old.CUSTOMER_ID, -1.00 * old.FEE);
    execute procedure CUSTOMER_DEBT_ADD(new.CUSTOMER_ID, new.FEE);
  end
end;

CREATE OR ALTER TRIGGER OTHER_FEE_STRICTCHECK FOR OTHER_FEE
ACTIVE BEFORE INSERT OR UPDATE OR DELETE POSITION 1
as
declare variable F_MONTH  D_DATE;
declare variable inStrict D_IBOOLEAN;
declare variable OP_DATE  D_DATE;
begin
  -- проверим в строгом режиме или нет
  if (deleting) then
    OP_DATE = old.Fee_Date;
  else
    OP_DATE = new.Fee_Date;

  if (OP_DATE < (current_date - extract(day from current_date) + 1)) then begin
    select
        cast(s.Var_Value as integer)
      from settings s
      where s.Var_Name = 'STRICT_MODE'
    into :inStrict;
    inStrict = coalesce(inStrict, 1);
    if (inStrict = 1) then begin
      select
          cast(s.Var_Value as date)
        from settings s
        where s.Var_Name = 'CURRENT_DATE'
      into :F_MONTH;

      if (OP_DATE < F_MONTH) then begin
        exception E_Strict_Mode;
      end
    end
  end
end;

CREATE OR ALTER TRIGGER PAYMENT_AD0 FOR PAYMENT
ACTIVE AFTER DELETE POSITION 0
as
begin

  update CUSTOMER C
  set C.DEBT_SUM = C.DEBT_SUM + round(old.PAY_SUM, 2)
  where C.CUSTOMER_ID = old.CUSTOMER_ID;

  delete from Customer_Bonuses
   where Customer_Id = old.Customer_Id
     and Bt_Id in ( 1,2,3 )
     and Ext_Id = old.Payment_Id;

  insert into OPERATION_LOG (OPERATION, OPER_WHAT, OPER_NOTE)
  values (0, 'ПЛАТЕЖ', old.CUSTOMER_ID || ' ' || old.PAY_DATE || ' ' || old.PAY_SUM || ' ' || old.FINE_SUM);

  insert into PAYMENT_DELETED (PAYMENT_ID, PAY_DOC_ID, CUSTOMER_ID, PAY_DATE, PAY_SUM, FINE_SUM,
                               NOTICE, PAYMENT_SRV, EXT_PAY_ID, TAG, PAY_DATETIME, WHOM, FISCAL)
  values (old.PAYMENT_ID, old.PAY_DOC_ID, old.CUSTOMER_ID, old.PAY_DATE, old.PAY_SUM, old.FINE_SUM,
          old.NOTICE, old.PAYMENT_SRV, old.EXT_PAY_ID, old.TAG, old.Pay_Datetime, old.added_by, old.Fiscal);

end;

CREATE OR ALTER TRIGGER PAYMENT_AI_0 FOR PAYMENT
ACTIVE AFTER INSERT POSITION 0
as
begin
  execute procedure UpdateCustomerDebt4pay (new.CUSTOMER_ID, new.PAY_SUM);
  execute procedure Bonus_Add_After_Payment(new.CUSTOMER_ID, new.Payment_Id, new.PAY_SUM);
end;

CREATE OR ALTER TRIGGER PAYMENT_AU0 FOR PAYMENT
ACTIVE AFTER UPDATE POSITION 0
as
begin
  -- если сменился абонент или сумма, обновим абонента и занесем в лог
  if ((old.CUSTOMER_ID is distinct from new.CUSTOMER_ID)
      or
      (old.PAY_SUM is distinct from new.PAY_SUM)) then begin
    if (old.CUSTOMER_ID = new.CUSTOMER_ID) then
      update CUSTOMER C
      set C.DEBT_SUM = coalesce(C.DEBT_SUM, 0) + old.PAY_SUM - new.PAY_SUM
      where C.CUSTOMER_ID = new.CUSTOMER_ID;
    else begin
      update CUSTOMER C
      set C.DEBT_SUM = coalesce(C.DEBT_SUM, 0) + old.PAY_SUM
      where C.CUSTOMER_ID = old.CUSTOMER_ID;
      update CUSTOMER C
      set C.DEBT_SUM = coalesce(C.DEBT_SUM, 0) - new.PAY_SUM
      where C.CUSTOMER_ID = new.CUSTOMER_ID;
    end

    insert into OPERATION_LOG (OPERATION, OPER_WHAT, OPER_NOTE)
    values (2, 'ПЛАТЕЖ', old.CUSTOMER_ID || ' ' || old.PAY_DATE || ' ' || old.PAY_SUM || ' -> ' || new.CUSTOMER_ID || ' ' || new.PAY_DATE || ' ' || new.PAY_SUM);
  end
end;

CREATE OR ALTER TRIGGER PAYMENT_BI0 FOR PAYMENT
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.PAYMENT_ID is null) then
    new.PAYMENT_ID = gen_id(GEN_PAYMENT, 1);
  if (new.PAYMENT_SRV is null) then
    new.PAYMENT_SRV = -1;
  if (coalesce(new.Pay_Type_Str, '') = '') then
    new.Pay_Type_Str = 'CASH';
  if (new.Fiscal is null) then
    new.Fiscal = 0;

  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAYMENT_BU0 FOR PAYMENT
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (coalesce(new.Pay_Type_Str, '') = '') then
    new.Pay_Type_Str = 'CASH';

  if (new.Fiscal is null) then
    new.Fiscal = 0;

  new.EDIT_BY = current_user;
  new.EDIT_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAYMENT_DELETED_BI FOR PAYMENT_DELETED
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.Deleted_By = current_user;
  new.Deleted_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAYMENT_HOLD_BI FOR PAYMENT_HOLD
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.PAYMENT_ID is null) then
    new.PAYMENT_ID = gen_id(GEN_PAYMENT, 1);

  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAYMENT_STRICTCHECK FOR PAYMENT
ACTIVE BEFORE INSERT OR UPDATE OR DELETE POSITION 1
as
declare variable F_MONTH  D_DATE;
declare variable inStrict D_IBOOLEAN;
declare variable OP_DATE  D_DATE;
begin
  -- проверим в строгом режиме или нет
  if (deleting) then
    OP_DATE = old.Pay_Date;
  else
    OP_DATE = new.Pay_Date;

  if (OP_DATE < (current_date - extract(day from current_date) + 1)) then begin
    select
        cast(s.Var_Value as integer)
      from settings s
      where s.Var_Name = 'STRICT_MODE'
    into :inStrict;
    inStrict = coalesce(inStrict, 1);
    if (inStrict = 1) then begin
      select
          cast(s.Var_Value as date)
        from settings s
        where s.Var_Name = 'CURRENT_DATE'
      into :F_MONTH;
      -- позволим вносить платежи в предидущую неделю
      F_MONTH = dateadd(day, -7, F_MONTH);
      if (OP_DATE < F_MONTH) then begin
        exception E_Strict_Mode;
      end
    end
  end
end;

CREATE OR ALTER TRIGGER PAYSOURCE_BD FOR PAYSOURCE
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (exists(select
                 p.Paysource_Id
               from Pay_Doc p
               where p.Paysource_Id = old.Paysource_Id)) then
    exception E_Cannot_Delete;
end;

CREATE OR ALTER TRIGGER PAYSOURCE_BI0 FOR PAYSOURCE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (new.PAYSOURCE_ID is null) then new.PAYSOURCE_ID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER PAY_DOC_AD FOR PAY_DOC
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from PAY_ERRORS pe where pe.pay_doc_id = OLD.pay_doc_id;
end;

CREATE OR ALTER TRIGGER PAY_DOC_BD FOR PAY_DOC
ACTIVE BEFORE DELETE POSITION 0
as
declare variable i D_Integer;
begin
  i = null;
  /* проверим есть ли у документа платежи */
  select
      count(*)
    from payment p
    where p.Pay_Doc_Id = old.Pay_Doc_Id
  into :i;
/*
  if (i is null) then
    -- проверим есть ли у документа удаленные платежи
    select
        count(*)
      from Payment_Deleted p
      where p.Pay_Doc_Id = old.Pay_Doc_Id
    into :i;
*/
  if (i > 0 ) then
    exception E_CANNOT_DELETE ;
end;

CREATE OR ALTER TRIGGER PAY_DOC_BI0 FOR PAY_DOC
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.PAY_DOC_ID is null) then
    new.PAY_DOC_ID = gen_id(gen_operations_uid, 1);
  if (new.Pay_Doc_Date is null) then
    new.Pay_Doc_Date = current_date;
  if (new.Pay_Doc_No is null) then
    new.Pay_Doc_No = extract(year from new.Pay_Doc_Date) || lpad(extract(month from new.Pay_Doc_Date), 2, '0') || lpad(extract(day from new.Pay_Doc_Date), 2, '0');

  new.ADDED_BY = current_user;
  new.ADDED_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAY_DOC_BU FOR PAY_DOC
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.EDIT_BY = current_user;
  new.EDIT_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER PAY_ERRORS_BI FOR PAY_ERRORS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.pe_id is null) then new.pe_id = gen_id(gen_operations_uid, 1);
end;

CREATE OR ALTER TRIGGER PERSONAL_TARIF_BI0 FOR PERSONAL_TARIF
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.TARIF_ID is null) then
    new.TARIF_ID = gen_id(gen_operations_uid, 1);
  if (new.date_from is null) then
    new.date_from = current_date - extract(day from current_date) + 1;
  if (new.date_to is null) then
    new.date_to = cast('2099-12-31' as date);
  /*
    с 2018-06-01 введена возможность расчета персонального тарифа с любойго дня месяца
    если до этого дату вносим, то задаем начало и конец месяца.
    чтоб "не поплыли" остатки
  */
  if (new.date_from < '2018-06-01') then begin
    new.date_from = new.date_from - extract(day from new.date_from) + 1;
    new.date_to = dateadd(-1 day to(dateadd(1 month to(new.date_to - extract(day from new.date_to) + 1))));
  end

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.edit_by = current_user;
    new.edit_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER PORT_BIU0 FOR PORT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if ((new.port <> '0') and (new.port starting with '0')) then begin
    new.port = trim(leading '0' from new.port); /* Удалим 0 в начале */
  end
  new.P_Type = coalesce(new.P_Type, 0);/* RJ45 */
  new.P_State = coalesce(new.P_State, 1);/* Исправен */

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER PREPAY_DETAIL_AI0 FOR PREPAY_DETAIL
ACTIVE AFTER INSERT POSITION 0
as
begin
  if (new.PPD_SUM > 0) then begin
    update CUSTOMER C
    set PREPAY = new.PPD_SUM,
        PREPAY_TIME = localtimestamp
    where (CUSTOMER_ID = new.CUSTOMER_ID);
    execute procedure CHECK_FOR_UNBLOCK(new.CUSTOMER_ID);
  end
  else begin
    update CUSTOMER C
    set PREPAY = 0,
        PREPAY_TIME = null
    where (CUSTOMER_ID = new.CUSTOMER_ID);
    execute procedure CLOSE_MONTH_PROC(current_date, new.CUSTOMER_ID);
  end
end;

CREATE OR ALTER TRIGGER PREPAY_DETAIL_BI0 FOR PREPAY_DETAIL
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.PPD_ID is null) then
    new.PPD_ID = gen_id(GEN_OPERATIONS_UID, 1);
  new.PPD_DATE = localtimestamp;
  new.WHO_ADD = current_user;
  if (new.PPD_SUM is null) then
    new.PPD_SUM = 0;
  select
      C.DEBT_SUM
    from CUSTOMER C
    where C.CUSTOMER_ID = new.CUSTOMER_ID
  into new.DEBT_SAVE;
end;

CREATE OR ALTER TRIGGER RATES_BIU0 FOR RATES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  NEW.Cur = UPPER(NEW.CUR);
end;

CREATE OR ALTER TRIGGER RECOURSE_BI FOR RECOURSE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.rc_id is null) then
    new.rc_id = gen_id(gen_operations_uid, 1);
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER RECOURSE_BU FOR RECOURSE
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.EDIT_by = current_user;
  new.EDIT_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER RECOURSE_TEMPLATES_BI FOR RECOURSE_TEMPLATES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.rt_id is null) then
    new.rt_id = gen_id(gen_operations_uid, 1);

  if (new.Deleted is null) then
    new.Deleted = 0;
end;

CREATE OR ALTER TRIGGER REPORTS_BD FOR REPORTS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (exists(select * from reports where id_parent = old.id_report))
  then
    update reports
    set id_parent = 0
    where id_parent = old.id_report;
end;

CREATE OR ALTER TRIGGER REPORTS_BI FOR REPORTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id_report is null) then
    new.id_report = gen_id(gen_report_id, 1);
  if (new.no_visible is null) then
    new.no_visible = 0;
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REPORTS_BU FOR REPORTS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.ID_REPORT is distinct from old.ID_REPORT) then
    update REPORTs R
    set R.ID_PARENT = new.ID_REPORT
    where R.ID_PARENT = old.ID_REPORT;

  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_AD FOR REQUEST
ACTIVE AFTER DELETE POSITION 0
as
begin
  -- вернем материалы и начисления
  execute procedure REQUEST_CLOSE_ROLLBACK(old.RQ_ID, old.RQ_CUSTOMER);
  delete from Other_Fee o where o.In_Request = old.Rq_Id;

  insert into OPERATION_LOG (OPERATION, OPER_WHAT, OPER_NOTE)
  values (0, 'ЗАЯВКА', old.RQ_ID);
end;

CREATE OR ALTER TRIGGER REQUEST_AI FOR REQUEST
ACTIVE AFTER INSERT POSITION 0
as
declare variable SMS varchar(255);
declare variable PN  varchar(255);
begin
  if (not((new.RQ_CUSTOMER is null)
      or
      (new.RQTL_ID is null))) then begin
    select
        Sms_Create
      from Request_Templates
      where Rqtl_Id = new.Rqtl_Id
    into :SMS;
    if (coalesce(SMS, '') <> '') then begin
      select first 1
          C.CC_VAL_REVERSE
        from CUSTOMER_CONTACTS C
        where C.CC_TYPE = 1
              and C.CUSTOMER_ID = new.RQ_CUSTOMER
        order by C.CC_NOTIFY desc
      into :PN;
      PN = coalesce(reverse(PN), '');
      if (PN <> '') then begin
        SMS = replace(SMS, '[NN]', coalesce(new.Rq_Id, ''));
        SMS = replace(SMS, '[PD]', coalesce(new.Rq_Plan_Date || coalesce(' ' || new.Rq_Time_From || ':' || new.Rq_Time_To, ''), ''));
        SMS = replace(SMS, '[TEXT]', coalesce(new.RQ_CONTENT, ''));
        insert into MESSAGES (CUSTOMER_ID, MES_TYPE, RECIVER, MES_HEAD, MES_TEXT, MES_RESULT)
        values (new.RQ_CUSTOMER, 'SMS', :PN, null, :SMS, 0);
      end
    end
  end
end;

CREATE OR ALTER TRIGGER REQUEST_AU FOR REQUEST
ACTIVE AFTER UPDATE POSITION 0
as
declare variable NEED_FEE   D_INTEGER;
declare variable DT         D_DATE;
declare variable Fee_Name   D_Varchar1000;
declare variable DEM        D_Varchar1000;
declare variable Units      D_N15_2;
declare variable Fee        D_N15_2;
declare variable Fee_Type   Uid;
declare variable In_Request D_Integer;

begin
  NEED_FEE = 0;
  -- если заявка закрываеться
  -- то нужно добавлять начисления за материалы и работы
  if (new.REQ_RESULT is distinct from old.REQ_RESULT) then begin
    if (new.REQ_RESULT = 2) then
      NEED_FEE = 1;

    if (old.REQ_RESULT = 2) then
      execute procedure REQUEST_CLOSE_ROLLBACK(old.RQ_ID, old.RQ_CUSTOMER);
  end

  -- если сменился абонент и заявка закрыта - удалим ему начисления
  if (old.RQ_CUSTOMER is distinct from new.RQ_CUSTOMER) then begin
    execute procedure REQUEST_CLOSE_ROLLBACK(old.RQ_ID, old.RQ_CUSTOMER);
    if (new.REQ_RESULT = 2) then
      NEED_FEE = 1;
  end

  -- если нужно то добавим новому абоненту начисления
  if ((not new.RQ_CUSTOMER is null) and (NEED_FEE = 1)) then begin
    -- начислим услуги и добавим атрибуты
    execute procedure REQUEST_CLOSE_PROCESS(new.rq_id);

    DT = coalesce(cast(new.RQ_EXEC_TIME as date), current_date);
    In_Request = new.RQ_ID;
    -- добавим материалы
    Fee_Type = 1;
    for select
            M.NAME
          , M.Demension
          , RM.RM_QUANT
          , RM.RM_QUANT * RM.RM_COST
          from REQUEST_MATERIALS RM
               inner join MATERIALS M on (M.M_ID = RM.M_ID)
          where RM.RQ_ID = new.RQ_ID
                and (coalesce(rm.Not_Calc, 0) = 0)
        into :FEE_NAME, :DEM, :UNITS, :FEE
    do begin
      if (not UNITS is null) then
        Fee_Name = Fee_Name || '. ' || trim(trailing '.' from trim(trailing '0' from UNITS)) || ' ' || coalesce(DEM, '');

      insert into Other_Fee (Fee_Date, Customer_Id, Fee_Name, Units, Fee, Fee_Type, In_Request)
      values (:DT, new.RQ_CUSTOMER, :Fee_Name, :Units, :Fee, :Fee_Type, :In_Request);
    end
    -- добавим работы
    Fee_Type = 2;
    for select
            M.NAME
          , RM.W_QUANT
          , RM.W_QUANT * RM.W_COST
          from REQUEST_WORKS RM
               inner join WORKS M on (M.W_ID = RM.W_ID)
          where RM.RQ_ID = new.RQ_ID
                and (m.as_service is null)
        into :FEE_NAME, :UNITS, :FEE
    do begin
      insert into OTHER_FEE (FEE_DATE, CUSTOMER_ID, FEE_NAME, UNITS, FEE, FEE_TYPE, IN_REQUEST)
      values (:DT, new.RQ_CUSTOMER, :Fee_Name, :Units, :Fee, :Fee_Type, :In_Request);
    end
  end
end;

CREATE OR ALTER TRIGGER REQUEST_BI0 FOR REQUEST
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.RQ_ID is null) then
    new.RQ_ID = gen_id(gen_request, 1);
  if (new.REQ_RESULT is null) then
    new.REQ_RESULT = 0;

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_BU FOR REQUEST
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.RQ_ID is null) then
    new.RQ_ID = gen_id(gen_request, 1);

  if (new.req_result is null) then
    new.req_result = 0;

  -- если результат стоит, а даты выполнения нет, то поставим дату
  if ((new.req_result > 1) and (new.Rq_Exec_Time is null)) then
    new.Rq_Exec_Time = localtimestamp;

  if ((not new.RQ_COMPLETED is null) and (new.req_result < 1)) then
    new.req_result = 1;
  else begin
    if ((new.RQ_COMPLETED is null) and (new.req_result = 1)) then
      new.req_result = 0;
  end

  -- если даты выполнения стоит, а выдачи нет, то поставим выдачи как выполнения
  if ((new.Rq_Completed is null) and (not new.Rq_Exec_Time is null)) then
    new.Rq_Completed = new.Rq_Exec_Time;

  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_AD FOR REQUEST_MATERIALS
ACTIVE AFTER DELETE POSITION 0
as
begin
    if (old.Rm_Quant <> 0)
    then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant,0) + old.Rm_Quant
      where mr.M_Id = old.m_id
            and mr.Wh_Id = old.Wh_Id;

      if (row_count = 0) then -- если не нашли, вставим запись
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (old.m_id, old.Wh_Id, old.Rm_Quant);
    end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_AI FOR REQUEST_MATERIALS
ACTIVE AFTER INSERT POSITION 0
as
begin
  if (new.Rm_Quant <> 0) then begin
    update Materials_Remain mr
    set mr.Mr_Quant = coalesce(mr.Mr_Quant, 0) - new.Rm_Quant
    where mr.M_Id = new.m_id
          and mr.Wh_Id = new.Wh_Id;

    if (row_count = 0) then -- если не нашли, вставим запись
      insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
      values (new.m_id, new.Wh_Id, new.Rm_Quant * (-1));
  end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_AU FOR REQUEST_MATERIALS
ACTIVE AFTER UPDATE POSITION 0
as
begin

  if ((old.M_Id is distinct from new.M_Id)
      or
      (old.Wh_Id is distinct from new.Wh_Id)
      or
      (old.Rm_Quant is distinct from new.Rm_Quant)) then begin

    if (old.Rm_Quant <> 0) then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant,0) + old.Rm_Quant
      where mr.M_Id = old.m_id
            and mr.Wh_Id = old.Wh_Id;

      if (row_count = 0) then
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (old.m_id, old.Wh_Id, old.Rm_Quant);
    end

    if (new.Rm_Quant <> 0) then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant,0) - new.Rm_Quant
      where mr.M_Id = new.m_id
            and mr.Wh_Id = new.Wh_Id;

      if (row_count = 0) then
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (new.m_id, new.Wh_Id, new.Rm_Quant * (-1));
    end
  end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_BI FOR REQUEST_MATERIALS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.rm_id is null) then
    new.rm_id = gen_id(gen_operations_uid, 1);

  new.Rm_Quant = coalesce(new.Rm_Quant, 0);
  new.Rm_Cost = coalesce(new.Rm_Cost, 0);
  new.Not_Calc = coalesce(new.Not_Calc, 0);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_BU FOR REQUEST_MATERIALS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Rm_Quant = coalesce(new.Rm_Quant, 0);
  new.Not_Calc = coalesce(new.Not_Calc, 0);

  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_RETURN_AD FOR REQUEST_MATERIALS_RETURN
ACTIVE AFTER DELETE POSITION 0
as
begin
    if (old.Quant <> 0)
    then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant,0) - old.Quant
      where mr.M_Id = old.m_id
            and mr.Wh_Id = old.Wh_Id;

      if (row_count = 0) then -- если не нашли, вставим запись
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (old.m_id, old.Wh_Id, old.Quant*(-1));
    end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_RETURN_AI FOR REQUEST_MATERIALS_RETURN
ACTIVE AFTER INSERT POSITION 0
as
begin
  if (new.Quant > 0) then begin
    update Materials_Remain mr
    set mr.Mr_Quant = coalesce(mr.Mr_Quant, 0) + new.Quant
    where mr.M_Id = new.m_id
          and mr.Wh_Id = new.Wh_Id;

    if (row_count = 0) then -- если не нашли, вставим запись
      insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
      values (new.m_id, new.Wh_Id, new.Quant);
  end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_RETURN_AU FOR REQUEST_MATERIALS_RETURN
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if ((old.M_Id is distinct from new.M_Id)
      or
      (old.Wh_Id is distinct from new.Wh_Id)) -- пересчитаем остатки
  then begin

    if (old.Quant <> 0) then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant, 0) - old.Quant
      where mr.M_Id = old.m_id
            and mr.Wh_Id = old.Wh_Id;
      if (row_count = 0) then -- если не нашли, вставим запись
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (old.m_id, old.Wh_Id, old.Quant * (-1));
    end

    if (new.Quant <> 0) then begin
      update Materials_Remain mr
      set mr.Mr_Quant = coalesce(mr.Mr_Quant, 0) + new.Quant
      where mr.M_Id = new.m_id
            and mr.Wh_Id = new.Wh_Id;
      if (row_count = 0) then -- если не нашли, вставим запись
        insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
        values (new.m_id, new.Wh_Id, new.Quant);
    end
  end
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_RETURN_BI FOR REQUEST_MATERIALS_RETURN
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_operations_uid, 1);
  if (new.Quant is null) then
    new.Quant = 0;

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MATERIALS_RETURN_BU FOR REQUEST_MATERIALS_RETURN
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.Quant is null) then
    new.Quant = 0;

  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MSG_BI FOR REQUEST_MSG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(Gen_Uid, 1);
  if (new.deleted is null) then
    new.deleted = 0;
  new.Added_By = current_user;
  new.Added_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_MSG_BU FOR REQUEST_MSG
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.deleted is null) then new.deleted = 0;
end;

CREATE OR ALTER TRIGGER REQUEST_PHOTOS_BI FOR REQUEST_PHOTOS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable hid UID;
begin
  if (new.id is null) then
    new.id = gen_id(gen_operations_uid, 1);

  if (new.House_Id is null) then begin
    select
        r.House_Id
      from request r
      where r.Rq_Id = new.Rq_Id
    into :hid;
    new.House_Id = hid;
  end

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.edit_by = current_user;
    new.edit_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER REQUEST_RESULTS_BI FOR REQUEST_RESULTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.rr_id is null) then new.rr_id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER REQUEST_TEMPLATES_BI FOR REQUEST_TEMPLATES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.RQTL_ID is null) then
    new.RQTL_ID = gen_id(gen_operations_uid, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_TEMPLATES_BIU1 FOR REQUEST_TEMPLATES
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
as
declare variable s D_VARCHAR2000;
begin
  if (not new.add_field is null) then begin
    select
        list(STR, ';')
      from EXPLODE_NO_EMPTY(';', new.add_field)
    into :s;
    new.ADD_FIELD = s;
  end

  if (updating) then begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER REQUEST_TYPES_BI FOR REQUEST_TYPES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.rt_id = coalesce(new.rt_id, gen_id(gen_operations_uid, 1));
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_TYPES_BU FOR REQUEST_TYPES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.Edit_By = current_user;
  new.Edit_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_WORKS_BI FOR REQUEST_WORKS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER REQUEST_WORKS_BU FOR REQUEST_WORKS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER SERVICES_AD FOR SERVICES
ACTIVE AFTER DELETE POSITION 0
as
begin
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES', 0, OLD.Service_Id, 'Name', 'DELETE', old.Name);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES', 0, OLD.Service_Id, 'Srv_Type_Id', 'DELETE', old.Srv_Type_Id);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES', 0, OLD.Service_Id, 'Business_Type', 'DELETE', old.Business_Type);

  delete from TARIF t
      where t.Service_Id = old.Service_Id;
end;

CREATE OR ALTER TRIGGER SERVICES_ATTRIBUTES_BI FOR SERVICES_ATTRIBUTES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.SA_ID is null) then
    new.SA_ID = gen_id(gen_uid, 1);
  if (new.Sa_Value is null) then
    new.Sa_Value = '';
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER SERVICES_ATTRIBUTES_BU FOR SERVICES_ATTRIBUTES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.SA_ID is null) then
    new.SA_ID = gen_id(gen_uid, 1);
  if (new.Sa_Value is null) then
    new.Sa_Value = '';
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER SERVICES_AU FOR SERVICES
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (new.Name is distinct from old.Name) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('SERVICES', 0, new.Service_Id, 'Name', old.Name, new.Name);
  if (new.Srv_Type_Id is distinct from old.Srv_Type_Id) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('SERVICES', 0, new.Service_Id, 'Srv_Type_Id', old.Srv_Type_Id, new.Srv_Type_Id);
  if (new.Business_Type is distinct from old.Business_Type) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('SERVICES', 0, new.Service_Id, 'Business_Type', old.Business_Type, new.Business_Type);
end;

CREATE OR ALTER TRIGGER SERVICES_BI0 FOR SERVICES
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.SERVICE_ID is null) then
    new.SERVICE_ID = gen_id(gen_operations_uid, 1);
  if (new.EXPENSE_TYPE is null) then
    new.EXPENSE_TYPE = 0;
  if (new.Inet_Srv is null) then
    new.Inet_Srv = 0;
  if (new.AUTOOFF is null) then
    new.AUTOOFF = 0;
  if (new.Positive_Only is null) then
    new.Positive_Only = 0;
  if (new.Only_One is null) then
    new.Only_One = 0;
  if (new.Shift_Months is null) then
    new.Shift_Months = 0;
  if (new.Inet_Srv = 0) then begin
    new.Ip_Begin = null;
    new.Ip_End = null;
  end
  if (new.Unbl_Meth is null) then
    new.Unbl_Meth = 0;
  if (new.EXTERNAL_ID is not null) then begin
    select
        list(STR)
      from (select
                trim(STR) STR
              from Explode_No_Empty(',', new.EXTERNAL_ID))
    into new.EXTERNAL_ID;
  end
  if (new.Ip_Begin is not null) then
    select
        Int_Ip
      from Ip2int(new.Ip_Begin)
    into new.Ip_Begin_Bin;
  else
    new.Ip_Begin_Bin = null;
  if (new.Ip_End is not null) then
    select
        Int_Ip
      from Ip2int(new.Ip_End)
    into new.Ip_End_Bin;
  else
    new.Ip_End_Bin = null;

  if (inserting) then begin
    new.Added_By = current_user;
    new.Added_On = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER SERVICES_CMPLX_BIU0 FOR SERVICES_CMPLX
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Date_From is null) then
    new.Date_From = current_date;
  if (new.Date_To is null) then
    new.Date_To = cast('2099-12-31' as date);

  new.Date_From = new.Date_From - extract(day from new.Date_From) + 1;
  new.Date_To = dateadd(-1 day to(dateadd(1 month to(new.Date_To - extract(day from new.Date_To) + 1))));

  if (inserting) then begin
    new.Added_By = current_user;
    new.Added_On = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER SERVICES_LINKS_AD FOR SERVICES_LINKS
ACTIVE AFTER DELETE POSITION 0
as
begin
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES_LINKS', 0, OLD.Link_Id, 'Link_Type', 'DELETE', old.Link_Type);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES_LINKS', 0, OLD.Link_Id, 'Parent', 'DELETE', old.Parent);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES_LINKS', 0, OLD.Link_Id, 'Child', 'DELETE', old.Child);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES_LINKS', 0, OLD.Link_Id, 'Add_Srv', 'DELETE', old.Add_Srv);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SERVICES_LINKS', 0, OLD.Link_Id, 'Switch_Time', 'DELETE', old.Switch_Time);
end;

CREATE OR ALTER TRIGGER SERVICES_LINKS_BI0 FOR SERVICES_LINKS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if ((new.Link_Type > 1) and (new.Child is null)) then begin
    exception e_not_empty;
  end

  if (new.LINK_ID is null) then
    new.LINK_ID = gen_id(gen_operations_uid, 1);
end;

CREATE OR ALTER TRIGGER SERVICES_TYPE_BI0 FOR SERVICES_TYPE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.SRV_TYPE_ID is null) then
 new.SRV_TYPE_ID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER SETTINGS_BIU0 FOR SETTINGS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.VAR_NAME = upper(new.VAR_NAME);
  new.Var_Value = coalesce(new.Var_Value, '');

  if (inserting) then begin
    new.Added_By = current_user;
    new.Added_On = localtimestamp;
  end
  else begin
    new.EDIT_by = current_user;
    new.EDIT_on = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER SINGLE_SERV_AD0 FOR SINGLE_SERV
ACTIVE AFTER DELETE POSITION 0
AS
begin
/*
закомментировано обновление талицы оплаты разовых услуг
ибо не знаю где это используется
delete from single_serv_paid sp where sp.single_service_id = OLD.single_service_id;
*/
end;

CREATE OR ALTER TRIGGER SINGLE_SERV_BD0 FOR SINGLE_SERV
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  DELETE FROM MONTHLY_FEE mf
  where mf.CUSTOMER_ID = old.CUSTOMER_ID
    and mf.SERVICE_ID = old.SERVICE_ID
    and mf.MONTH_ID = old.SERV_DATE;
end;

CREATE OR ALTER TRIGGER SINGLE_SERV_BI0 FOR SINGLE_SERV
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Single_Service_Id is null) then
    new.single_service_id = gen_id(gen_operations_uid, 1);
  new.Added_By = current_user;
  new.Added_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER STREET_AU FOR STREET
ACTIVE AFTER UPDATE POSITION 0
as
declare variable CUSTOMER_ID type of Uid;
declare variable HOUSE_ID    type of Uid;
declare variable FLAT_NO     type of D_FLAT;
declare variable CUST_CODE   type of D_Varchar20;
begin
  if (new.Street_Code is distinct from old.Street_Code) then begin
    for select
            C.Customer_Id
          , c.House_Id
          , c.Flat_No
          from Customer C
               inner join House H on (C.House_Id = H.House_Id)
          where h.Street_Id = new.Street_Id
        into :customer_id, :HOUSE_ID, :FLAT_NO
    do begin
      execute procedure GET_CUSTOMER_CODE(:HOUSE_ID, :FLAT_NO)
          returning_values :CUST_CODE;
      update customer
      set Cust_Code = :CUST_CODE
      where Customer_Id = :CUSTOMER_ID;
    end
  end
end;

CREATE OR ALTER TRIGGER STREET_BI0 FOR STREET
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.STREET_ID is null) then
    new.STREET_ID = gen_id(gen_operations_uid, 1);

  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER STREET_BIU1 FOR STREET
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
as
declare variable s D_VARCHAR5;
begin
  if (new.Street_Code is null) then
    new.Street_Code = '';
  if (new.Street_Short is null) then begin
    select
        st.Strtype_Short
      from Street_Type st
      where st.Strtype_Code = 1
    into :s;
    new.Street_Short = s;
  end
end;

CREATE OR ALTER TRIGGER STREET_BU FOR STREET
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER SUBAREA_BI0 FOR SUBAREA
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.SUBAREA_ID is null) then
 new.SUBAREA_ID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER SUBDIVISIONS_BI FOR SUBDIVISIONS
ACTIVE BEFORE INSERT POSITION 0
as
begin
 if (new.id is null) then new.id = gen_id(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER SUBSCR_HIST_AD0 FOR SUBSCR_HIST
ACTIVE AFTER DELETE POSITION 0
as
begin
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'SUBSCR_SERV_ID',  old.subscr_serv_id, null);
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'SERVICE',  old.serv_id, null);
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'FROM',  old.act_serv_id, null);
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'TO',  old.disact_serv_id, null);
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'DATE_FROM',  cast(old.date_from as VARCHAR(10)), null);
  insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_HIST', 0, OLD.customer_id, 'DATE_TO',  cast(old.date_to as VARCHAR(10)), null);


  delete from SINGLE_SERV ss where ss.CUSTOMER_ID = old.CUSTOMER_ID
        and ss.SERVICE_ID = old.ACT_SERV_ID
        and ss.SERV_DATE = old.DATE_FROM;

  delete from SINGLE_SERV ss where ss.CUSTOMER_ID = old.CUSTOMER_ID
        and ss.SERVICE_ID = old.DISACT_SERV_ID
        and ss.SERV_DATE = (old.DATE_TO + 1); --дата отключения на день меньше дня отключения

  execute procedure CUSTOMER_SERVICES_STATE(old.CUSTOMER_ID);
  execute procedure UPDATE_SERVICES_TREE(old.customer_id, old.serv_id);
end;

CREATE OR ALTER TRIGGER SUBSCR_HIST_AIU0 FOR SUBSCR_HIST
ACTIVE AFTER INSERT OR UPDATE POSITION 0
AS
begin
  EXECUTE PROCEDURE CUSTOMER_SERVICES_STATE(NEW.CUSTOMER_ID);
  EXECUTE PROCEDURE UPDATE_SERVICES_TREE(NEW.customer_id,  new.serv_id);
end;

CREATE OR ALTER TRIGGER SUBSCR_HIST_BIU0 FOR SUBSCR_HIST
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.Subscr_Hist_Id is null) then
    new.Subscr_Hist_Id = gen_id(Gen_Operations_Uid, 1);

  if (new.DISACT_SERV_ID is null) then
    new.DISACT_SERV_ID = -1;

  new.Added_By = current_user;
  new.Added_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER SUBSCR_HIST_BU FOR SUBSCR_HIST
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.DISACT_SERV_ID is null) then
    new.DISACT_SERV_ID = -1;

  if (new.DISACT_SERV_ID = -1) then begin
    new.Closed_By = null;
    new.Closed_ON = null;
    new.date_to = '2100-01-01';
  end
  else begin
    new.Closed_By = current_user;
    new.Closed_ON = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER SUBSCR_SERV_AD0 FOR SUBSCR_SERV
ACTIVE AFTER DELETE POSITION 0
as
declare variable ID D_INTEGER;
begin
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_SERV', 0, old.customer_id, 'SUBSCR_SERV_ID', old.Subscr_Serv_Id, null);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_SERV', 0, old.customer_id, 'SERV_ID', old.Serv_Id, null);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_SERV', 0, old.customer_id, 'STATE_DATE', cast(old.State_Date as varchar(10)), null);
  insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
  values ('SUBSCR_SERV', 0, old.customer_id, 'STATE_SRV', old.State_Srv, null);

  delete from SUBSCR_HIST SH
      where SH.SUBSCR_SERV_ID = old.SUBSCR_SERV_ID;

  delete from DECODER_PACKETS p
      where SERVICE_ID = old.SERV_ID
            and exists(select
                           DECODER_N
                         from CUSTOMER_DECODERS d
                         where d.DECODER_N = p.DECODER_N
                               and CUSTOMER_ID = old.CUSTOMER_ID);
  select
      s.business_type
    from services s
    where s.service_id = old.SERV_ID
  into :ID;

  if (id >= 2) then -- digital service
    execute procedure DIGITAL_EVENT(2, old.CUSTOMER_ID, null, old.SERV_ID, localtimestamp, null);

  -- проверим есть ли у абонента услуги, если нет почистим дату подключения
  select
      count(*)
    from Subscr_Serv ss
    where ss.Customer_Id = old.Customer_Id
  into :id;
  if (id = 0) then begin
    update Customer c
    set c.ACTIVIZ_DATE = null
    where c.customer_id = old.Customer_Id
          and not c.ACTIVIZ_DATE is null;
  end
end;

CREATE OR ALTER TRIGGER SUBSCR_SERV_BI0 FOR SUBSCR_SERV
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.SUBSCR_SERV_ID is null) then
 new.SUBSCR_SERV_ID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER SUBSCR_SERV_BIU FOR SUBSCR_SERV
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
as
begin
  new.State_Change_By = current_user;
  new.State_Change_ON = localtimestamp;
end;

CREATE OR ALTER TRIGGER SYS$GROUP_AD FOR SYS$GROUP
ACTIVE AFTER DELETE POSITION 0
as
begin
  /* Trigger text */
  delete from sys$group_rights r where r.group_id = OLD.id;
  delete from sys$user_groups r where r.group_id = OLD.id;
end;

CREATE OR ALTER TRIGGER SYS$GROUP_BI FOR SYS$GROUP
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.id is null) then
    new.ID = gen_id(gen_uid, 1);
  if (inserting) then begin
    new.Added_By = current_user;
    new.Added_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER SYS$GROUP_RIGHTS_AD FOR SYS$GROUP_RIGHTS
ACTIVE AFTER DELETE POSITION 0
as
begin
  update Sys$Group s
  set s.Edit_By = current_user,
      s.Edit_On = localtimestamp
  where s.Id = old.Group_Id;
end;

CREATE OR ALTER TRIGGER SYS$GROUP_RIGHTS_BI FOR SYS$GROUP_RIGHTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.id is null) then
    new.ID = gen_id(gen_uid, 1);
  if (new.Rights_Type is null) then
    new.Rights_Type = 0;
  if (inserting) then begin
    new.Added_By = current_user;
    new.Added_On = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
  update Sys$Group s
  set s.Edit_By = current_user,
      s.Edit_On = localtimestamp
  where s.Id = new.Group_Id;
end;

CREATE OR ALTER TRIGGER SYS$RIGHTS_BIU0 FOR SYS$RIGHTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  new.Rights = upper(new.Rights);
end;

CREATE OR ALTER TRIGGER SYS$USER_AD FOR SYS$USER
ACTIVE AFTER DELETE POSITION 0
as
begin
  delete from sys$user_groups r where r.user_id = old.id;
end;

CREATE OR ALTER TRIGGER SYS$USER_AREAS_BI FOR SYS$USER_AREAS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (NEW.id is null) then NEW.ID = gen_id(gen_uid,1);
end;

CREATE OR ALTER TRIGGER SYS$USER_BI FOR SYS$USER
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.id is null) then
    new.ID = gen_id(gen_uid, 1);
  if (new.All_Areas is null) then
    new.All_Areas = 0;
  if (new.Lockedout is null) then
    new.Lockedout = 0;
end;

CREATE OR ALTER TRIGGER SYS$USER_GROUPS_BI FOR SYS$USER_GROUPS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (NEW.id is null) then NEW.ID = gen_id(gen_uid,1);
end;

CREATE OR ALTER TRIGGER TARIF_BI FOR TARIF
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.TARIF_ID is null) then
    new.TARIF_ID = gen_id(gen_operations_uid, 1);
  if (new.TARIF_SUM_JUR is null) then
    new.TARIF_SUM_JUR = new.TARIF_SUM;
  if (new.DATE_FROM is null) then
    new.DATE_FROM = cast('2100-01-01' as date);
  new.EDIT_by = current_user;
  new.EDIT_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER TASKLIST_AI FOR TASKLIST
ACTIVE AFTER INSERT POSITION 0
as
begin
  POST_EVENT 'TASK_NEW';
end;

CREATE OR ALTER TRIGGER TASKLIST_BI FOR TASKLIST
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(Gen_Task, 1);

  if (new.added_by is null) then
    new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER TASKLIST_BIU0 FOR TASKLIST
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.Deleted is null) then
    new.Deleted = 0;
  new.EDIT_ON = localtimestamp;
  new.Edit_By = current_user;
end;

CREATE OR ALTER TRIGGER TASKMSG_AI FOR TASKMSG
ACTIVE AFTER INSERT POSITION 0
as
begin
  update TASKLIST t
  set t.Edit_On = localtimestamp,
      t.Edit_By = current_user
  where t.Id = new.Task_Id;
end;

CREATE OR ALTER TRIGGER TASKMSG_BI FOR TASKMSG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(Gen_Task, 1);
  if (new.deleted is null) then
    new.deleted = 0;
  new.Added_By = current_user;
  new.Added_On = localtimestamp;
end;

CREATE OR ALTER TRIGGER TASKMSG_BU FOR TASKMSG
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.deleted is null) then new.deleted = 0;
end;

CREATE OR ALTER TRIGGER TQUEUE_BI FOR TQUEUE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.ID is null) then
    new.ID = gen_id(GEN_QUEUE, 1);

  if (new."ACTION" = 1) then
    new.transactionnum = new.ID;

  if (new.Device_Model_Id is null) then
    new.Device_Model_Id = 1;

  if (new.Status is null) then
    new.Status = 0;

  if (new.Dateadded is null) then
    new.Dateadded = localtimestamp;
end;

CREATE OR ALTER TRIGGER TR_CUSTOMER_CHANGELOG_AD FOR CUSTOMER
ACTIVE AFTER DELETE POSITION 0
AS BEGIN
  IF (not OLD.CUSTOMER_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUSTOMER_ID', 'DELETE', OLD.CUSTOMER_ID);
  IF (not OLD.CUST_CODE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUST_CODE', 'DELETE', OLD.CUST_CODE);
  IF (not OLD.HOUSE_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'HOUSE_ID', 'DELETE', OLD.HOUSE_ID);
  IF (not OLD.ACCOUNT_NO IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ACCOUNT_NO', 'DELETE', OLD.ACCOUNT_NO);
  IF (not OLD.DOGOVOR_NO IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'DOGOVOR_NO', 'DELETE', OLD.DOGOVOR_NO);
  IF (not OLD.SURNAME IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'SURNAME', 'DELETE', OLD.SURNAME);
  IF (not OLD.FIRSTNAME IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'FIRSTNAME', 'DELETE', OLD.FIRSTNAME);
  IF (not OLD.MIDLENAME IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'MIDLENAME', 'DELETE', OLD.MIDLENAME);
  IF (not OLD.INITIALS IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'INITIALS', 'DELETE', OLD.INITIALS);
  IF (not OLD.CONTRACT_DATE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CONTRACT_DATE', 'DELETE', OLD.CONTRACT_DATE);
  IF (not OLD.ACTIVIZ_DATE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ACTIVIZ_DATE', 'DELETE', OLD.ACTIVIZ_DATE);
  IF (not OLD.PHONE_NO IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PHONE_NO', 'DELETE', OLD.PHONE_NO);
  IF (not OLD.NOTICE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'NOTICE', 'DELETE', OLD.NOTICE);
  IF (not OLD.VALID_TO IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'VALID_TO', 'DELETE', OLD.VALID_TO);
  IF (not OLD.CUST_STATE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUST_STATE', 'DELETE', OLD.CUST_STATE);
  IF (not OLD.CUST_STATE_DESCR IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUST_STATE_DESCR', 'DELETE', OLD.CUST_STATE_DESCR);
  IF (not OLD.CUST_PROP IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUST_PROP', 'DELETE', OLD.CUST_PROP);
  IF (not OLD.CUST_PROP_DESCR IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CUST_PROP_DESCR', 'DELETE', OLD.CUST_PROP_DESCR);
  IF (not OLD.FLAT_NO IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'FLAT_NO', 'DELETE', OLD.FLAT_NO);
  IF (not OLD.DEBT_SUM IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'DEBT_SUM', 'DELETE', OLD.DEBT_SUM);
  IF (not OLD.PASSPORT_NUMBER IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PASSPORT_NUMBER', 'DELETE', OLD.PASSPORT_NUMBER);
  IF (not OLD.PASSPORT_REGISTRATION IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PASSPORT_REGISTRATION', 'DELETE', OLD.PASSPORT_REGISTRATION);
  IF (not OLD.PERSONAL_N IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PERSONAL_N', 'DELETE', OLD.PERSONAL_N);
  IF (not OLD.MANAGER_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'MANAGER_ID', 'DELETE', OLD.MANAGER_ID);
  IF (not OLD.JURIDICAL IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'JURIDICAL', 'DELETE', OLD.JURIDICAL);
  IF (not OLD.JUR_INN IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'JUR_INN', 'DELETE', OLD.JUR_INN);
  IF (not OLD.JUR_DIRECTOR IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'JUR_DIRECTOR', 'DELETE', OLD.JUR_DIRECTOR);
  IF (not OLD.JUR_BUH IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'JUR_BUH', 'DELETE', OLD.JUR_BUH);
  IF (not OLD.CGIS IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CGIS', 'DELETE', OLD.CGIS);
  IF (not OLD.MOBILE_PHONE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'MOBILE_PHONE', 'DELETE', OLD.MOBILE_PHONE);
  IF (not OLD.HIS_COLOR IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'HIS_COLOR', 'DELETE', OLD.HIS_COLOR);
  IF (not OLD.INVISIBLE IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'INVISIBLE', 'DELETE', OLD.INVISIBLE);
  IF (not OLD.EMAIL IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'EMAIL', 'DELETE', OLD.EMAIL);
  IF (not OLD.TIME_ON_MINUS IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'TIME_ON_MINUS', 'DELETE', OLD.TIME_ON_MINUS);
  IF (not OLD.BIRTHDAY IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'BIRTHDAY', 'DELETE', OLD.BIRTHDAY);
  IF (not OLD.ADRES_REGISTR IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ADRES_REGISTR', 'DELETE', OLD.ADRES_REGISTR);
  IF (not OLD.ORG_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ORG_ID', 'DELETE', OLD.ORG_ID);
  IF (not OLD.VATG_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'VATG_ID', 'DELETE', OLD.VATG_ID);
  IF (not OLD.TAP IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'TAP', 'DELETE', OLD.TAP);
  IF (not OLD.PREPAY IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PREPAY', 'DELETE', OLD.PREPAY);
  IF (not OLD.PREPAY_TIME IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PREPAY_TIME', 'DELETE', OLD.PREPAY_TIME);
  IF (not OLD.SECRET IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'SECRET', 'DELETE', OLD.SECRET);
  IF (not OLD.ADDED_BY IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ADDED_BY', 'DELETE', OLD.ADDED_BY);
  IF (not OLD.ADDED_ON IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'ADDED_ON', 'DELETE', OLD.ADDED_ON);
  IF (not OLD.EDIT_BY IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'EDIT_BY', 'DELETE', OLD.EDIT_BY);
  IF (not OLD.EDIT_ON IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'EDIT_ON', 'DELETE', OLD.EDIT_ON);
  IF (not OLD.HAND_CONTROL IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'HAND_CONTROL', 'DELETE', OLD.HAND_CONTROL);
  IF (not OLD.BANK IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'BANK', 'DELETE', OLD.BANK);
  IF (not OLD.BANK_ACCOUNT IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'BANK_ACCOUNT', 'DELETE', OLD.BANK_ACCOUNT);
  IF (not OLD.EXTERNAL_ID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'EXTERNAL_ID', 'DELETE', OLD.EXTERNAL_ID);
  IF (not OLD.PASSPORT_VALID IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'PASSPORT_VALID', 'DELETE', OLD.PASSPORT_VALID);
  IF (not OLD.CONTRACT_BASIS IS NULL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, OLD.CUSTOMER_ID, 'CONTRACT_BASIS', 'DELETE', OLD.CONTRACT_BASIS);
END;

CREATE OR ALTER TRIGGER TR_CUSTOMER_CHANGELOG_AU FOR CUSTOMER
ACTIVE AFTER UPDATE POSITION 0
as
begin
  if (new.HOUSE_ID is distinct from old.HOUSE_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'HOUSE_ID', old.HOUSE_ID, new.HOUSE_ID);
  if (new.ACCOUNT_NO is distinct from old.ACCOUNT_NO) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'ACCOUNT_NO', old.ACCOUNT_NO, new.ACCOUNT_NO);
  if (new.DOGOVOR_NO is distinct from old.DOGOVOR_NO) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'DOGOVOR_NO', old.DOGOVOR_NO, new.DOGOVOR_NO);
  if (new.SURNAME is distinct from old.SURNAME) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'SURNAME', old.SURNAME, new.SURNAME);
  if (new.FIRSTNAME is distinct from old.FIRSTNAME) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'FIRSTNAME', old.FIRSTNAME, new.FIRSTNAME);
  if (new.MIDLENAME is distinct from old.MIDLENAME) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'MIDLENAME', old.MIDLENAME, new.MIDLENAME);
  if (new.CONTRACT_DATE is distinct from old.CONTRACT_DATE) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'CONTRACT_DATE', old.CONTRACT_DATE, new.CONTRACT_DATE);
  if (new.NOTICE is distinct from old.NOTICE) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'NOTICE', old.NOTICE, new.NOTICE);
  if (new.VALID_TO is distinct from old.VALID_TO) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'VALID_TO', old.VALID_TO, new.VALID_TO);
  if (new.FLAT_NO is distinct from old.FLAT_NO) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'FLAT_NO', old.FLAT_NO, new.FLAT_NO);
  if (new.PASSPORT_NUMBER is distinct from old.PASSPORT_NUMBER) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'PASSPORT_NUMBER', old.PASSPORT_NUMBER, new.PASSPORT_NUMBER);
  if (new.PASSPORT_REGISTRATION is distinct from old.PASSPORT_REGISTRATION) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'PASSPORT_REGISTRATION', old.PASSPORT_REGISTRATION, new.PASSPORT_REGISTRATION);
  if (new.PERSONAL_N is distinct from old.PERSONAL_N) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'PERSONAL_N', old.PERSONAL_N, new.PERSONAL_N);
  if (new.MANAGER_ID is distinct from old.MANAGER_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'MANAGER_ID', old.MANAGER_ID, new.MANAGER_ID);
  if (new.JURIDICAL is distinct from old.JURIDICAL) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'JURIDICAL', old.JURIDICAL, new.JURIDICAL);
  if (new.JUR_INN is distinct from old.JUR_INN) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'JUR_INN', old.JUR_INN, new.JUR_INN);
  if (new.JUR_DIRECTOR is distinct from old.JUR_DIRECTOR) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'JUR_DIRECTOR', old.JUR_DIRECTOR, new.JUR_DIRECTOR);
  if (new.JUR_BUH is distinct from old.JUR_BUH) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'JUR_BUH', old.JUR_BUH, new.JUR_BUH);
  if (new.HIS_COLOR is distinct from old.HIS_COLOR) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'HIS_COLOR', old.HIS_COLOR, new.HIS_COLOR);
  if (new.INVISIBLE is distinct from old.INVISIBLE) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'INVISIBLE', old.INVISIBLE, new.INVISIBLE);
  if (new.BIRTHDAY is distinct from old.BIRTHDAY) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'BIRTHDAY', old.BIRTHDAY, new.BIRTHDAY);
  if (new.ADRES_REGISTR is distinct from old.ADRES_REGISTR) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'ADRES_REGISTR', old.ADRES_REGISTR, new.ADRES_REGISTR);
  if (new.ORG_ID is distinct from old.ORG_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'ORG_ID', old.ORG_ID, new.ORG_ID);
  if (new.VATG_ID is distinct from old.VATG_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'VATG_ID', old.VATG_ID, new.VATG_ID);
  if (new.TAP is distinct from old.TAP) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'TAP', old.TAP, new.TAP);
  if (new.SECRET is distinct from old.SECRET) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'SECRET', old.SECRET, new.SECRET);
  if (new.HAND_CONTROL is distinct from old.HAND_CONTROL) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'HAND_CONTROL', old.HAND_CONTROL, new.HAND_CONTROL);
  if (new.BANK is distinct from old.BANK) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'BANK', old.BANK, new.BANK);
  if (new.BANK_ACCOUNT is distinct from old.BANK_ACCOUNT) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'BANK_ACCOUNT', old.BANK_ACCOUNT, new.BANK_ACCOUNT);
  if (new.EXTERNAL_ID is distinct from old.EXTERNAL_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'EXTERNAL_ID', old.EXTERNAL_ID, new.EXTERNAL_ID);
  if (new.PASSPORT_VALID is distinct from old.PASSPORT_VALID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'PASSPORT_VALID', old.PASSPORT_VALID, new.PASSPORT_VALID);
  if (new.CONTRACT_BASIS is distinct from old.CONTRACT_BASIS) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, new.CUSTOMER_ID, 'CONTRACT_BASIS', old.CONTRACT_BASIS, new.CONTRACT_BASIS);
  IF (NEW.PHONE_NO IS DISTINCT FROM OLD.PHONE_NO) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, NEW.CUSTOMER_ID, 'PHONE_NO', OLD.PHONE_NO, NEW.PHONE_NO);
  IF (NEW.MOBILE_PHONE IS DISTINCT FROM OLD.MOBILE_PHONE) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, NEW.CUSTOMER_ID, 'MOBILE_PHONE', OLD.MOBILE_PHONE, NEW.MOBILE_PHONE);
  IF (NEW.EMAIL IS DISTINCT FROM OLD.EMAIL) THEN
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('CUSTOMER', 0, NEW.CUSTOMER_ID, 'EMAIL', OLD.EMAIL, NEW.EMAIL);
end;

CREATE OR ALTER TRIGGER TR_REQUEST_CHANGELOG_AU FOR REQUEST
ACTIVE AFTER UPDATE POSITION 1
as
begin
  if (new.HOUSE_ID is distinct from old.HOUSE_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'HOUSE_ID', old.HOUSE_ID, new.HOUSE_ID);

  if (new.Rq_Plan_Date is distinct from old.Rq_Plan_Date) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'RQ_PLAN_DATE', old.Rq_Plan_Date, new.Rq_Plan_Date);

  if (new.RQ_TYPE is distinct from old.RQ_TYPE) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'RQ_TYPE', old.RQ_TYPE, new.RQ_TYPE);

  if (new.RQTL_ID is distinct from old.RQTL_ID) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'RQTL_ID', old.RQTL_ID, new.RQTL_ID);

  if (new.RQ_NOTICE is distinct from old.RQ_NOTICE) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'RQ_NOTICE', old.RQ_NOTICE, new.RQ_NOTICE);

  if (new.ADD_INFO is distinct from old.ADD_INFO) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'ADD_INFO', old.ADD_INFO, new.ADD_INFO);

  if (new.RQ_CONTENT is distinct from old.RQ_CONTENT) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('REQUEST', 0, new.Rq_Id, 'RQ_CONTENT', old.RQ_CONTENT, new.RQ_CONTENT);
end;

CREATE OR ALTER TRIGGER TV_LAN_AD FOR TV_LAN
ACTIVE AFTER DELETE POSITION 0
as
begin
  if (not((old.ip is null))) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, old.customer_id, 'IP', old.ip, null);

  if (not((old.mac is null))) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, old.customer_id, 'MAC', old.mac, null);

  if (not old.eq_id is null) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, old.customer_id, 'MODEM', old.eq_id, null);

  if (not old.Tag is null) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, old.customer_id, 'TAG', old.Tag, null);

  if (not old.Tag_Str is null) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, old.customer_id, 'TAG_STR', old.Tag_Str, null);
end;

CREATE OR ALTER TRIGGER TV_LAN_AI FOR TV_LAN
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin
  if (not new.eq_id is null) then begin
    update equipment e
    set e.last_update = localtimestamp
    where e.eid = new.eq_id;
  end
  if ((not old.eq_id is null) and (new.eq_id is distinct from old.eq_id)) then begin
    update equipment e
    set e.last_update = localtimestamp
    where e.eid = old.eq_id;
  end
end;

CREATE OR ALTER TRIGGER TV_LAN_AI1 FOR TV_LAN
ACTIVE AFTER INSERT POSITION 1
as
begin
  if (not new.ip is null)
  then
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, NEW.customer_id, 'IP', null, NEW.ip);

  if (not new.mac is null)
  then
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, NEW.customer_id, 'MAC', null, NEW.mac);

  if (not new.eq_id is null)
  then
    insert into CHANGELOG ( LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, NEW.customer_id, 'MODEM', null, NEW.eq_id);
end;

CREATE OR ALTER TRIGGER TV_LAN_AIU0 FOR TV_LAN
ACTIVE AFTER INSERT OR UPDATE POSITION 0
as
begin
  if ((not new.Eq_Id is null) and (not new.Port is null)) then begin
    update or insert into Port (Eid, Port, Con, Con_Id)
    values (new.Eq_Id, new.Port, 1, new.Customer_Id)
    matching (Eid, Port);
  end
end;

CREATE OR ALTER TRIGGER TV_LAN_AU1 FOR TV_LAN
ACTIVE AFTER UPDATE POSITION 1
as
begin
  if (new.ip is distinct from old.ip) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, new.customer_id, 'IP', old.ip, new.ip);

  if (new.mac is distinct from old.mac) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, new.customer_id, 'MAC', old.mac, new.mac);

  if (new.eq_id is distinct from old.eq_id) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, new.customer_id, 'MODEM', old.eq_id, new.eq_id);

  if (new.Tag is distinct from old.Tag) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, new.customer_id, 'TAG', old.Tag, new.Tag);

  if (new.Tag_Str is distinct from old.Tag_Str) then
    insert into CHANGELOG (LOG_GROUP, OBJECT_TYPE, OBJECT_ID, PARAM, VALUE_BEFORE, VALUE_AFTER)
    values ('LAN', 0, new.customer_id, 'TAG_STR', old.Tag_Str, new.Tag_Str);
end;

CREATE OR ALTER TRIGGER TV_LAN_AUD0 FOR TV_LAN
ACTIVE AFTER UPDATE OR DELETE POSITION 0
as
begin
  if ((not old.Eq_Id is null) and (not old.Port is null)) then begin
    update or insert into Port (Eid, Port, Con, Con_Id)
    values (old.Eq_Id, old.Port, null, null)
    matching (Eid, Port);
  end
end;

CREATE OR ALTER TRIGGER TV_LAN_BI FOR TV_LAN
ACTIVE BEFORE INSERT POSITION 1
as
begin
  new.added_by = current_user;
  new.added_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER TV_LAN_BIU0 FOR TV_LAN
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable mac d_mac;
begin
  if ((new.Ip is null) and (new.Ipv6 is null) and (new.Mac is null) and (new.Port is null)) then
    exception e_not_empty;

  if (new.Lan_Id is null) then
    new.Lan_Id = gen_id(gen_operations_uid, 1);

  if (trim(new.IP) = '') then
    new.IP = null;

  if (new.IP is not null) then
    select
        Int_Ip
      from Ip2int(new.IP)
    into new.Ip_Bin;
  else
    new.Ip_Bin = null;

  select
      Int_Ip
    from Ip2int(new.IP)
  into new.Ip_Bin;

  if (new.Ip_Add is not null) then
    select
        Int_Ip
      from Ip2int(new.IP_ADD)
    into new.Ip_Add_Bin;
  else
    new.Ip_Add_Bin = null;

  if (not new.MAC is null) then begin
    select
        MAC
      from FORMAT_MAC(new.MAC)
    into :Mac;
    new.mac = mac;
  end

  if (not new.Ipv6 is null) then
    new.Ipv6 = lower(new.Ipv6);

  if ((not new.Port is null) and (new.port <> '0')) then
    new.port = trim(leading '0' from new.port);

  new.last_update = localtimestamp;
end;

CREATE OR ALTER TRIGGER TV_LAN_BU FOR TV_LAN
ACTIVE BEFORE UPDATE POSITION 1
as
begin
  new.edit_by = current_user;
  new.edit_on = localtimestamp;
end;

CREATE OR ALTER TRIGGER TV_LAN_PACKETS_AD FOR TV_LAN_PACKETS
ACTIVE AFTER DELETE POSITION 0
as
begin
  update TV_LAN T
  set EDIT_ON = localtimestamp,
      EDIT_BY = current_user
  where LAN_ID = old.LAN_ID;
end;

CREATE OR ALTER TRIGGER TV_LAN_PACKETS_AI FOR TV_LAN_PACKETS
ACTIVE AFTER INSERT POSITION 0
as
begin
  update TV_LAN T
  set EDIT_ON = localtimestamp,
      EDIT_BY = current_user
  where LAN_ID = new.LAN_ID;
end;

CREATE OR ALTER TRIGGER TV_LAN_PACKETS_AU FOR TV_LAN_PACKETS
ACTIVE AFTER UPDATE POSITION 0
as
begin
  update TV_LAN T
  set EDIT_ON = localtimestamp,
      EDIT_BY = current_user
  where LAN_ID = new.LAN_ID;

  if (old.LAN_ID is distinct from new.LAN_ID) then
    update TV_LAN T
    set EDIT_ON = localtimestamp,
        EDIT_BY = current_user
    where LAN_ID = old.LAN_ID;
end;

CREATE OR ALTER TRIGGER VLANS_BIU0 FOR VLANS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.v_id is null) then
    new.v_id = gen_id(gen_operations_uid, 1);

  new.IP_BEGIN_Bin = INET_ATON(new.IP_BEGIN);
  new.IP_END_Bin = INET_ATON(new.IP_END);
end;

CREATE OR ALTER TRIGGER VPN_SESSIONS_BI FOR VPN_SESSIONS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_VPN_SESSIONS_id,1);
end;

CREATE OR ALTER TRIGGER WIRE_BIU0 FOR WIRE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  NEW.WId = coalesce(NEW.WID, gen_id(Gen_Devices_Id, 1));
  NEW.Meters = coalesce(NEW.Meters, 1);
  NEW.Capacity = coalesce(NEW.Capacity, 1);
  NEW.Stock = coalesce(NEW.Stock, 0);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER WIRE_POINT_BIU0 FOR WIRE_POINT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  NEW.Meters = coalesce(NEW.Meters, 1);

  if (inserting) then begin
    new.added_by = current_user;
    new.added_on = localtimestamp;
  end
  else begin
    new.Edit_By = current_user;
    new.Edit_On = localtimestamp;
  end
end;

CREATE OR ALTER TRIGGER WORKAREALIMIT_BI FOR WORKAREALIMIT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
  if (new.quant is null) then new.quant = -1;
end;

CREATE OR ALTER TRIGGER WORKAREA_BIU FOR WORKAREA
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
begin
 if (NEW.WA_ID is null) then new.WA_ID = GEN_ID(gen_operations_uid,1);
 if (new.WA_Code='') then new.WA_Code = null;
end;

CREATE OR ALTER TRIGGER WORKER_BI0 FOR WORKER
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
 if (new.WORKER_ID is null) then new.WORKER_ID = GEN_ID(gen_operations_uid,1);
 if (new.surname is null) then new.surname ='';
 if (new.firstname is null) then new.firstname ='';
 if (new.midlename is null) then new.midlename ='';
end;

CREATE OR ALTER TRIGGER WORKGROUPS_BI0 FOR WORKGROUPS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (NEW.WG_ID is null) then
 new.WG_ID = GEN_ID(gen_operations_uid,1);
end;

CREATE OR ALTER TRIGGER WORKS_BI FOR WORKS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (NEW.w_id is null) then new.w_id = gen_id(gen_operations_uid,1);
end;CREATE OR ALTER PROCEDURE ADD_FLAT_TO_HOUSE (
    HOUSE_ID UID,
    FLAT_NO D_FLAT,
    PORCH_N D_VARCHAR10,
    FLOOR_N D_VARCHAR100)
AS
declare variable ID  type of UID;
declare variable PID type of UID;
begin
  /* Внесем квартиру */
  update or insert into Houseflats (House_Id, Flat_No, Porch_N, Floor_N)
  values (:House_Id, :Flat_No, :Porch_N, :Floor_N)
  matching (House_Id, Flat_No);

  /* Внесем подъезд */
  select
      f.Porch_Id
    from Houseporch f
    where f.House_Id = :House_Id
          and Porch_N = :Porch_N
  into :PID;
  if (PID is null) then
    insert into Houseporch (House_Id, Porch_N)
    values (:House_Id, :Porch_N)
    returning (Porch_Id)
    into :PID;

  /* Внесем этаж */
  select
      f.Floor_Id
    from Housefloor f
    where f.Porch_Id = :PID
          and Floor_N = :Floor_N
  into :ID;
  if (id is null) then
    insert into Housefloor (Porch_Id, Floor_N)
    values (:PID, :Floor_N)
    returning (Floor_Id)
    into :ID;

  /* Обновим таблицы подъездов и домов */
  update HOUSEPORCH h
  set h.floors = (select
                      count(*)
                    from housefloor
                    where porch_id = h.porch_id)
  where h.porch_id = :PID;
end;


CREATE OR ALTER PROCEDURE ADD_OR_MOVE_PAYMENT (
    PAYDOC D_INTEGER,
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable Customer_Id type of Uid;
declare variable P_Count     type of D_Integer;
begin
  PAYMENT_ID = 0;
  -- Проверим абонента
  if (ACCOUNT_NO is null) then
    PAYMENT_ID = -4; -- Не указан абонент
  else begin
    -- выполним два запроса, ибо два разных буит быстрее чем один с ИЛИ
    select
        C.CUSTOMER_ID
      from CUSTOMER C
      where (C.ACCOUNT_NO = :ACCOUNT_NO)
    into :CUSTOMER_ID;

    if (CUSTOMER_ID is null) then
      PAYMENT_ID = -6; -- Не найден абонент
  end

  if (PAYMENT_ID = 0) then begin
    select
        count(*)
      from PAYMENT P
      where P.CUSTOMER_ID = :CUSTOMER_ID
            and P.PAY_SUM = :PAY_SUM
            and P.PAY_DATETIME = :PAY_TIME
            and P.EXT_PAY_ID = :EXT_PAY_ID
    into :P_COUNT;

    if (P_COUNT = 0) then
      -- если платеж не найден добавим его
      select
          PAYMENT_ID
        from ADD_PAYMENT_EXT(:PAYDOC, :CUSTOMER_ID, :PAY_SUM, :PAY_TIME, :NOTICE, :FINE_SUM, :PAYMENT_TYPE, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :CMSN)
      into :PAYMENT_ID;
    else begin
      if (P_COUNT = 1) then begin
        -- если платеж найден перенесем в платежный документ
        select
            PAYMENT_ID
          from PAYMENT P
          where P.CUSTOMER_ID = :CUSTOMER_ID
                and P.PAY_SUM = :PAY_SUM
                and P.PAY_DATETIME = :PAY_TIME
                and P.EXT_PAY_ID = :EXT_PAY_ID
        into :PAYMENT_ID;

        update PAYMENT P
        set P.PAY_DOC_ID = :PAYDOC,
            CMSN = :CMSN
        where P.PAYMENT_ID = :PAYMENT_ID;
      end
      else begin
        delete from PAYMENT P where P.CUSTOMER_ID = :CUSTOMER_ID
              and P.PAY_SUM = :PAY_SUM
              and P.PAY_DATETIME = :PAY_TIME
              and P.EXT_PAY_ID = :EXT_PAY_ID;
        -- если платеж не найден добавим его
        select
            PAYMENT_ID
          from ADD_PAYMENT_EXT(:PAYDOC, :CUSTOMER_ID, :PAY_SUM, :PAY_TIME, :NOTICE, :FINE_SUM, :PAYMENT_TYPE, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :CMSN)
        into :PAYMENT_ID;
      end
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT (
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_NOTICE,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable PAY_DOC_ID type of UID;
declare variable PAY_DATE   D_DATE;
begin
  PAY_DATE = cast(PAY_TIME as date);

  if (CUSTOMER_ID is null) then
    CUSTOMER_ID = -1;

  if (PAY_SUM is null) then
    PAY_SUM = -1;

  if ((PAY_SUM > 0) and (CUSTOMER_ID >= 0)) then begin
    select
        Pay_Doc_Id
      from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
    into :Pay_Doc_Id;

    PAYMENT_ID = gen_id(GEN_PAYMENT, 1);

    insert into PAYMENT (PAYMENT_ID, PAY_DOC_ID, CUSTOMER_ID, PAY_DATE, PAY_SUM, NOTICE, PAYMENT_SRV, PAY_DATETIME, CMSN)
    values (:PAYMENT_ID, :PAY_DOC_ID, :CUSTOMER_ID, :PAY_DATE, :PAY_SUM, :NOTICE, :PAYMENT_SRV, :PAY_TIME, :CMSN);
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACC_SUR (
    ACCOUNT_NO D_ACCOUNT,
    SURNAME D_VARCHAR100,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID TYPE OF UID,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_NOTICE,
    EXT_PAY_ID D_VARCHAR50,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable Customer_Id type of UID;
begin
  PAYMENT_ID = 0;
  if (not Account_No is null) then begin
    select
        Customer_Id
      from customer c
      where c.Account_No = :Account_No
            and upper(:SURNAME) = upper(c.SURNAME)
    into Customer_Id;
    if (not Customer_Id is null) then begin
      select
          Payment_Id
        from Add_Payment(:Customer_Id, :Pay_Sum, :Pay_TIME, :Paysource_Id, null, :Payment_Srv, :Notice, :CMSN)
      into :Payment_Id;
      if (not(EXT_PAY_ID is null)) then
        update payment p
        set p.Ext_Pay_Id = :EXT_PAY_ID
        where p.Payment_Id = :Payment_Id;
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACCOUNT (
    ACCOUNT_NO D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID TYPE OF UID,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV TYPE OF UID,
    NOTICE D_NOTICE,
    EXT_PAY_ID D_VARCHAR50,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable Customer_Id type of UID;
declare variable PAY_DATE    D_DATE;
begin
  PAY_DATE = cast(pay_time as date);
  PAYMENT_ID = 0;
  if (not Account_No is null) then begin
    select
        Customer_Id
      from customer c
      where c.Account_No = :Account_No
    into Customer_Id;
    if (not Customer_Id is null) then begin
      select
          Payment_Id
        from Add_Payment(:Customer_Id, :Pay_Sum, :Pay_time, :Paysource_Id, null, :Payment_Srv, :Notice, :CMSN)
      into :Payment_Id;
      if (not(EXT_PAY_ID is null)) then
        update payment p
        set p.Ext_Pay_Id = :EXT_PAY_ID
        where p.Payment_Id = :Payment_Id;
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_BY_ACCOUNT_FINE (
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATE,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_VARCHAR255,
    EXT_PAY_ID D_VARCHAR50,
    FINE D_N15_2,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable Customer_Id D_UID_NULL;
begin
  PAYMENT_ID = 0;
  if (not Account_No is null) then begin
    select
        Customer_Id
      from customer c
      where c.Account_No = :Account_No
    into Customer_Id;
    if (not Customer_Id is null) then begin
      select
          Payment_Id
        from Add_Payment_fine(:Customer_Id, :Pay_Sum, :Pay_Date, :Paysource_Id, null, :Payment_Srv, :Notice, :FINE, :CMSN)
      into :Payment_Id;
      if (not(EXT_PAY_ID is null)) then
        update payment p
        set p.Ext_Pay_Id = :EXT_PAY_ID
        where p.Payment_Id = :Payment_Id;
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_EXT (
    PAY_DOC_ID TYPE OF D_INTEGER,
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable PAY_DATE D_DATE;
begin
  PAYMENT_ID = 0;
  PAY_DATE = cast(PAY_TIME as date);
  if (CUSTOMER_ID is null) then
    PAYMENT_ID = -1; -- Не указан абонент
  if (PAY_SUM is null) then
    PAYMENT_ID = -2; -- Не указана сумма
  if (PAY_DOC_ID is null) then
    PAYMENT_ID = -3; -- Не указан плат. докумет
  if (PAYMENT_ID = 0) then begin
    PAYMENT_ID = gen_id(GEN_PAYMENT, 1);
    insert into PAYMENT (PAYMENT_ID, PAY_DOC_ID, CUSTOMER_ID, PAY_DATE, PAY_SUM, FINE_SUM, NOTICE, PAYMENT_SRV, EXT_PAY_ID, TAG, PAY_DATETIME, CMSN)
    values (:PAYMENT_ID, :PAY_DOC_ID, :CUSTOMER_ID, :PAY_DATE, :PAY_SUM, :FINE_SUM, :NOTICE, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :PAY_TIME, :CMSN);
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_FINE (
    CUSTOMER_ID D_INTEGER,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATE,
    PAYSOURCE_ID D_INTEGER,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    NOTICE D_VARCHAR255,
    FINE D_N15_2,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable Pay_Doc_Id D_INTEGER;
begin
  if (CUSTOMER_ID is null) then
    CUSTOMER_ID = -1;
  if (Pay_sum is null) then
    Pay_Sum = -1;
  if (FINE is null) then
    FINE = 0;

  if ((Pay_Sum > 0) and (CUSTOMER_ID >= 0)) then begin

    select
        Pay_Doc_Id
      from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
    into :Pay_Doc_Id;

    PAYMENT_ID = gen_id(Gen_Payment, 1);

    insert into Payment (Payment_Id, Pay_Doc_Id, Customer_Id, Pay_Date, Pay_Sum, Notice, Payment_Srv, FINE_SUM, CMSN)
    values (:Payment_Id, :Pay_Doc_Id, :Customer_Id, :Pay_Date, :Pay_Sum, :Notice, :Payment_Srv, :FINE, :CMSN);
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_FROM_EXT_SYSTEMS (
    ACCOUNT_NO TYPE OF D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50,
    NOTICE D_NOTICE,
    PAY_TYPE_STR D_VARCHAR30 = 'CASH',
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER)
AS
declare variable i d_iboolean;
begin
  /* процедура будет удалена в следующих версиях */
  execute procedure Payment_Add_From_Ext_Systems(:Account_No, :Pay_Sum, :Pay_Time, :Paysource_Id, :Ext_Systems_Id, :Notice, :PAY_TYPE_STR, :CMSN)
      returning_values :Payment_Id, :i;
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_ACCOUNT (
    PAYSRC_CODE D_VARCHAR100,
    ACCOUNT_NO D_VARCHAR20,
    PAY_SUM D_N15_2,
    PAY_DATE D_DATETIME,
    NOTICE D_NOTICE = null,
    FINE_SUM D_N15_2 = null,
    PAYMENT_TYPE D_INTEGER = null,
    PAYMENT_SRV D_INTEGER = null,
    EXT_PAY_ID D_VARCHAR50 = null,
    TAG D_INTEGER = null,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
declare variable CUSTOMER_ID type of UID;
begin
  PAYMENT_ID = 0;

  if (ACCOUNT_NO is null) then
    PAYMENT_ID = -4; -- Не указан абонент
  else begin
    select
        C.CUSTOMER_ID
      from CUSTOMER C
      where (C.ACCOUNT_NO = :ACCOUNT_NO)
    into :CUSTOMER_ID;

    if (CUSTOMER_ID is null) then
      PAYMENT_ID = -6; -- Не указан абонент
  end

  if (PAYMENT_ID = 0) then begin
    PAYMENT_ID = null;
    if (coalesce(EXT_PAY_ID, '') <> '') then begin
      select
          P.PAYMENT_ID
        from PAYMENT P
             inner join PAY_DOC D on (P.PAY_DOC_ID = D.PAY_DOC_ID)
        where D.PAYSOURCE_ID = :PAYSRC_CODE
              and P.CUSTOMER_ID = :CUSTOMER_ID
              and P.EXT_PAY_ID = :EXT_PAY_ID
              and P.PAY_SUM = :PAY_SUM
              and P.PAY_DATETIME = :PAY_DATE
      into :PAYMENT_ID;
    end

    if (PAYMENT_ID is null) then begin
      select
          PAYMENT_ID
        , PAY_DOC_ID
        from ADD_PAYMENT_SRC_CUSTID(:PAYSRC_CODE, :CUSTOMER_ID, :PAY_SUM, :PAY_DATE, :NOTICE, :FINE_SUM, null, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :CMSN)
      into :PAYMENT_ID, :PAY_DOC_ID;
    end
    else
      PAYMENT_ID = -7; -- Платеж уже существует
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_CUSTID (
    PAYSRC_CODE D_VARCHAR100,
    CUSTOMER_ID TYPE OF UID,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
declare variable PAYSOURCE_ID D_INTEGER;
declare variable PAY_DATE     D_DATE;
begin
  PAYMENT_ID = 0;
  PAY_DATE = cast(PAY_TIME as date);
  -- Проверим источник платежа
  -- если не задан, берем 0 по умолчанию
  -- если задан, выбираем из базы
  if (PAYSRC_CODE is null) then
    PAYSOURCE_ID = 0;
  else begin

    select
        s.paysource_id
      from paysource s
      where upper(s.code) = upper(:paysrc_code)
    into :PAYSOURCE_ID;

    if (PAYSOURCE_ID is null) then begin
      -- Не найден источник платежа, создадим его
      PAYSOURCE_ID = gen_id(gen_operations_uid, 1);
      insert into PAYSOURCE (PAYSOURCE_ID, PAYSOURCE_DESCR, LEAK_PRC, TAX_PRC, CODE)
      values (:PAYSOURCE_ID, :paysrc_code, 0, 0, upper(:paysrc_code));
    end
  end

  if (PAYMENT_ID = 0) then begin
    select
        Pay_Doc_Id
      from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
    into :Pay_Doc_Id;

    select
        PAYMENT_ID
      from ADD_PAYMENT_EXT(:PAY_DOC_ID, :CUSTOMER_ID, :PAY_SUM, :PAY_TIME, :NOTICE, :FINE_SUM, null, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :CMSN)
    into :PAYMENT_ID;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_PAYMENT_SRC_DOG_FIO (
    PAYSRC_CODE D_VARCHAR100,
    CONTRACT D_VARCHAR20,
    FIO D_VARCHAR100,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    NOTICE D_NOTICE,
    FINE_SUM D_N15_2,
    PAYMENT_TYPE D_INTEGER,
    PAYMENT_SRV D_INTEGER,
    EXT_PAY_ID D_VARCHAR50,
    TAG D_INTEGER,
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DOC_ID TYPE OF UID)
AS
declare variable SURNAME      D_VARCHAR50;
declare variable CUSTOMER_ID  type of UID;
declare variable PAYSOURCE_ID D_INTEGER;
declare variable PAY_DATE     D_DATE;
begin
  PAYMENT_ID = 0;
  PAY_DATE = cast(PAY_TIME as date);
  -- Проверим источник платежа
  -- если не задан, берем 0 по умолчанию
  -- если задан, выбираем из базы
  if (PAYSRC_CODE is null) then
    PAYSOURCE_ID = 0;
  else begin

    select
        s.paysource_id
      from paysource s
      where upper(s.code) = upper(:paysrc_code)
    into :PAYSOURCE_ID;

    if (PAYSOURCE_ID is null) then begin
      -- Не найден источник платежа, создадим его
      PAYSOURCE_ID = gen_id(gen_operations_uid, 1);
      insert into PAYSOURCE (PAYSOURCE_ID, PAYSOURCE_DESCR, LEAK_PRC, TAX_PRC, CODE)
      values (:PAYSOURCE_ID, :paysrc_code, 0, 0, upper(:paysrc_code));
    end
  end

  if (PAYMENT_ID = 0) then begin
    select
        Pay_Doc_Id
      from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
    into :Pay_Doc_Id;
  end

  if (fio is null) then
    fio = '';

  if (CONTRACT is null) then
    PAYMENT_ID = -4; -- Не указан абонент
  else begin
    -- выполним два запроса, ибо два разных буит быстрее чем один с ИЛИ
    select
        c.customer_id
      , upper(c.surname)
      from customer c
      where (c.dogovor_no = :CONTRACT)
    into :CUSTOMER_ID, :SURNAME;

    if (CUSTOMER_ID is null) then
      select
          c.customer_id
        , upper(c.surname)
        from customer c
             inner join subscr_serv s on (c.customer_id = s.customer_id)
        where (s.contract = :CONTRACT)
      into :CUSTOMER_ID, :SURNAME;

    if (CUSTOMER_ID is null) then
      PAYMENT_ID = -6; -- Не указан абонент
    else begin
      -- ФИО сравним лишь в том случае, ессли оно было передано
      if ((SURNAME <> upper(FIO)) and (FIO <> '')) then
        PAYMENT_ID = -5; -- Не совпадают фамилии
    end
  end

  if (PAYMENT_ID = 0) then begin
    select
        PAYMENT_ID
      from ADD_PAYMENT_EXT(:PAY_DOC_ID, :CUSTOMER_ID, :PAY_SUM, :PAY_TIME, :NOTICE, :FINE_SUM, null, :PAYMENT_SRV, :EXT_PAY_ID, :TAG, :CMSN)
    into :PAYMENT_ID;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2 = 1,
    P_DATE D_DATE = current_date,
    P_NOTICE D_NOTICE = null /* COLLATE UTF8 - default */,
    P_HISTORY TYPE OF UID = null,
    RECALC D_IBOOLEAN = 1)
AS
begin
  RECALC = coalesce(RECALC, 1);
  execute procedure Add_Single_Service_Vat(:P_Customer_Id, :P_Service_Id, :P_Units, :P_Date, :P_Notice, :P_History, null, :Recalc);
end;


CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE_VAT (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_HISTORY TYPE OF UID,
    P_VATG_ID TYPE OF UID,
    RECALC D_IBOOLEAN = 1)
AS
declare variable V_C_MONTH D_DATE;
begin
  select
      cast(VAR_VALUE as date)
    from SETTINGS
    where VAR_NAME = 'CURRENT_DATE'
  into :V_C_MONTH;

  insert into SINGLE_SERV (CUSTOMER_ID, SERVICE_ID, SERV_DATE, UNITS, NOTICE, HISTORY_ID)
  values (:P_CUSTOMER_ID, :P_SERVICE_ID, :P_DATE, :P_UNITS, :P_NOTICE, :P_HISTORY);

  -- если дата ранее или текущего месяца - просчитаем
  if ((RECALC = 1) and (Month_First_Day(:P_DATE) <= V_C_MONTH)) then begin
    -- execute procedure Close_Month_Proc(:P_DATE, :P_CUSTOMER_ID);
    execute procedure FULL_RECALC_CUSTOMER(:P_CUSTOMER_ID, :P_DATE);
  end
end;


CREATE OR ALTER PROCEDURE ADD_SINGLE_SERVICE_WO_CALC (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_UNITS D_N15_2,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_HISTORY TYPE OF UID,
    P_VATG_ID TYPE OF UID,
    RQ_ID TYPE OF UID)
AS
declare variable V_C_MONTH D_DATE;
declare variable V_B_MONTH D_DATE;
begin
  insert into SINGLE_SERV (CUSTOMER_ID, SERVICE_ID, SERV_DATE, UNITS, NOTICE, HISTORY_ID, RQ_ID)
  values (:P_CUSTOMER_ID, :P_SERVICE_ID, :P_DATE, :P_UNITS, :P_NOTICE, :P_HISTORY, :RQ_ID);
  /*
  V_B_MONTH = P_DATE - extract(day from P_DATE) + 1;

  select
      cast(VAR_VALUE as date)
    from SETTINGS
    where VAR_NAME = 'CURRENT_DATE'
  into :V_C_MONTH;

  -- если дата ранее или текущего месяца - просчитаем
  if (V_B_MONTH <= V_C_MONTH) then begin
    execute procedure Close_Month_Proc(:V_B_MONTH, :P_CUSTOMER_ID);

    select
        s.Srv_Type_Id
      from SERVICES S where s.Service_Id = :P_SERVICE_ID
    into :SRV_TYPE;

    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :V_ROUND;
    V_ROUND = coalesce(V_ROUND, 2);
    -- если услуга фиксирована, то сразу снимем с баланса
    if (SRV_TYPE = 2) then
      insert into MONTHLY_FEE (MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
      values (:P_DATE, :P_CUSTOMER_ID, :P_SERVICE_ID, 1, round(:P_UNITS, :V_ROUND));
    else
      execute procedure Calc_Single_Srv_Customer(:P_CUSTOMER_ID, :V_B_MONTH, :V_ROUND);
  end
  */
end;


CREATE OR ALTER PROCEDURE ADD_STAT_IP (
    IP_BIN TYPE OF D_INT_IP,
    STAT_DATE TYPE OF D_TIMESTAMP,
    BYTES TYPE OF D_INTEGER,
    TRAFCLASS TYPE OF D_INTEGER)
AS
begin

  STAT_DATE = dateadd(hour, extract(hour from STAT_DATE), Cast(cast(STAT_DATE as DATE) as TIMESTAMP));
  if (TrafClass is null) then TrafClass = 0;
  update Stat_Ip
  set Bytes = Bytes + :Bytes
  where Ip_Bin = :Ip_Bin
        and STAT_DATE = :STAT_DATE
        and TC_ID = :TrafClass;
  if (row_count = 0) then
    insert into Stat_Ip (Ip_Bin, STAT_DATE, Bytes, TC_ID)
    values (:Ip_Bin, :STAT_DATE, :Bytes, :TrafClass);

end;


CREATE OR ALTER PROCEDURE ADD_SUBSCR_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    P_CONTRACT D_VARCHAR20,
    P_CONTRACT_DATE D_DATE,
    RECALC D_IBOOLEAN = 1)
AS
begin
  execute procedure Add_Subscr_Service_Vat(:P_Customer_Id, :P_Service_Id, :P_Actservice, :P_Date, :P_Notice, :P_Units, :P_Contract, :P_Contract_Date, null, :RECALC);
end;


CREATE OR ALTER PROCEDURE ADD_SUBSCR_SERVICE_VAT (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    P_CONTRACT D_VARCHAR20,
    P_CONTRACT_DATE D_DATE,
    P_VATG_ID TYPE OF UID,
    RECALC D_IBOOLEAN = 1)
AS
declare variable ID            D_INTEGER;
declare variable H_ID          D_INTEGER;
declare variable act_timestamp type of d_timestamp;
declare variable vResult       D_INTEGER;
begin
  /* проверим может эта услуга уже есть */
  ID = null;
  select
      s.Subscr_Serv_Id
    , s.State_Date
    , s.State_Sgn
    from Subscr_Serv s
    where s.Customer_Id = :P_CUSTOMER_ID
          and s.Serv_Id = :P_SERVICE_ID
  into :ID, :act_timestamp, :vResult;

  if (ID is null) then begin
    -- Нет услуги у абонента - добавим ее
    ID = gen_id(GEN_OPERATIONS_UID, 1);
    insert into SUBSCR_SERV (SUBSCR_SERV_ID, CUSTOMER_ID, SERV_ID, STATE_SGN, NOTICE, STATE_DATE, STATE_SRV, CONTRACT, CONTRACT_DATE, VATG_ID)
    values (:ID, :P_CUSTOMER_ID, :P_SERVICE_ID, 1, :P_NOTICE, :p_date, :P_ACTSERVICE, :P_CONTRACT, :p_contract_date, :P_VATG_ID);

    H_ID = gen_id(GEN_OPERATIONS_UID, 1);
    insert into SUBSCR_HIST (SUBSCR_HIST_ID, CUSTOMER_ID, SERV_ID, SUBSCR_SERV_ID, DATE_FROM, DATE_TO, ACT_SERV_ID, disact_serv_id)
    values (:H_ID, :P_CUSTOMER_ID, :P_SERVICE_ID, :ID, :P_DATE, '2100-01-01', :P_ACTSERVICE, -1);

    execute procedure ADD_SINGLE_SERVICE_VAT(:P_CUSTOMER_ID, :P_ACTSERVICE, :P_UNITS, :P_DATE, :P_NOTICE, :H_ID, :P_VATG_ID, :RECALC);

    update Customer c
    set c.ACTIVIZ_DATE = :P_DATE
    where c.customer_id = :P_CUSTOMER_ID
          and c.ACTIVIZ_DATE is null;

  end
  else begin
    -- есть услуга у абонена - включем ее если она отключена
    if (vResult = 0) then
      execute procedure onoff_service(:p_customer_id, :id, :p_actservice, :p_date, 0, :p_notice, :p_units, :RECALC)
          returning_values :vResult;
  end

  select
      s.business_type
    from services s
    where s.service_id = :p_service_id
  into :ID;

  if (id >= 2) then begin
    if (P_DATE = current_date) then
      act_timestamp = localtimestamp;
    else
      act_timestamp = P_DATE;
    execute procedure DIGITAL_EVENT(1, :P_CUSTOMER_ID, null, :p_service_id, :act_timestamp, null);
  end
  --EXECUTE PROCEDURE CUSTOMER_SERVICES_STATE(:P_CUSTOMER_ID);
  --EXECUTE PROCEDURE FULL_RECALC_CUSTOMER(:P_CUSTOMER_ID);
end;


CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_BALANCE (
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    B_MONTH D_DATE,
    B_DESCRIPTION D_VARCHAR500,
    B_SUM D_N15_2,
    SUM_TYPE D_INTEGER)
AS
declare variable Fdescription varchar(500);
declare variable Pdescription varchar(500);
declare variable Fsumma       numeric(15,2);
declare variable Psumma       numeric(15,2);
declare variable Rmonth       date;
begin
  for select
          Rmonth, Fdescription, Pdescription, Fsumma, Psumma, SUM_TYPE
        from Customer_Balance(:Customer_Id)
      into :Rmonth, :Fdescription, :Pdescription, :Fsumma, :Psumma, :SUM_TYPE
  do begin
    B_MONTH = Rmonth;

    if (Fdescription is null) then
      B_DESCRIPTION = Pdescription;
    else
      B_DESCRIPTION = Fdescription;

    if (Fsumma is null) then
      B_SUM = Psumma;
    else
      B_SUM = -1 * Fsumma;

    suspend;
  end
end;


CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_SERVICES (
    CUSTOMER_ID TYPE OF UID,
    FOR_DATE D_DATE = current_date,
    SHOW_OLD D_IBOOLEAN = 0)
RETURNS (
    SERVICE_ID TYPE OF UID,
    STATE D_INTEGER,
    STATE_DATE D_DATE,
    CAN_ON D_INTEGER,
    CAN_OFF D_INTEGER)
AS
declare variable State_Srv type of Uid;
declare variable tmpD      type of D_DATE;
declare variable SRV_OLD   D_INTEGER;
begin
  /* Выборка активных услуг */
  FOR_DATE = coalesce(FOR_DATE, current_date);
  for select
          s.SERVICE_ID
        , iif(not exists(select
                         sl.Link_Id
                       from SERVICES_LINKS sl
                       where S.SERVICE_ID = sl.CHILD
                             and sl.LINK_TYPE = 0), 1, 0)
        ,
          (select
               count(*)
             from SERVICES_LINKS won
             where won.Parent = S.SERVICE_ID
                   and won.Link_Type = 7)
        ,
          (select
               count(*)
             from SERVICES_LINKS won
             where won.Parent = S.SERVICE_ID
                   and won.Link_Type = 8)
        from SERVICES S
        where s.srv_type_id = 0
      into :SERVICE_ID, :SRV_OLD, :CAN_ON, :CAN_OFF
  do begin
    STATE = null;
    STATE_DATE = null;
    state_srv = null;

    if (SRV_OLD = 1) then
      CAN_ON = 0;

    select
        ss.State_Sgn
      , ss.State_Date
      , ss.State_Srv
      from subscr_serv ss
      where ss.Customer_Id = :CUSTOMER_ID
            and ss.Serv_Id = :SERVICE_ID
    into :STATE, :STATE_DATE, state_srv;

    STATE = coalesce(STATE, -1);
    if (state_srv = -3) then
      STATE = 2; -- автоблокировка

    if ((STATE_DATE > For_Date) and (STATE >= 0)) then begin
      -- если подкл / отключена
      tmpD = null;
      select first 1
          ss.Date_From
        from subscr_hist ss
        where ss.Customer_Id = :CUSTOMER_ID
              and ss.Serv_Id = :SERVICE_ID
              and :For_Date between ss.Date_From and ss.Date_To
      into :tmpD;
      if (not tmpD is null) then begin
        STATE_DATE = tmpD;
        STATE = 1;
      end
      else
        STATE = -1;
    end

    if (SRV_OLD = 0) then
      suspend;
    else begin
      if ((SHOW_OLD = 1) or (STATE > 0)) then
        suspend;
    end
  end
end;


CREATE OR ALTER PROCEDURE API_GET_CUSTOMER_SERVICES_NEW (
    CUSTOMER_ID TYPE OF UID,
    FOR_DATE D_DATE = current_date,
    SHOW_OLD D_IBOOLEAN = 0)
RETURNS (
    SERVICE_ID TYPE OF UID,
    STATE D_INTEGER,
    STATE_DATE D_DATE,
    CAN_ON D_INTEGER,
    CAN_OFF D_INTEGER)
AS
begin
  -- эту процедуру нужно удалить
  for select
          Service_Id
        , State
        , State_Date
        , Can_On
        , Can_Off
        from Api_Get_Customer_Services(:Customer_Id, :For_Date, :Show_Old)
      into :Service_Id, :State, :State_Date, :Can_On, :Can_Off
  do
    suspend;
end;


CREATE OR ALTER PROCEDURE API_GET_NEW_ACCOUNT (
    HOUSE_ID TYPE OF UID = null,
    FLAT D_FLAT = null,
    SRV_ID TYPE OF UID = null)
RETURNS (
    ACCOUNT_NO D_ACCOUNT)
AS
declare variable cid D_Uid_Null;
begin
  ACCOUNT_NO = null;
  while (ACCOUNT_NO is null) do begin
    cid = null;
    ACCOUNT_NO = gen_id(GEN_ACCOUNT_NO, 1);
    select first 1
        Customer_Id
      from customer
      where Account_No = cast(:ACCOUNT_NO as varchar(15))
    into :cid;
    if (not cid is null) then
      ACCOUNT_NO = null;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE API_GET_SERVICES (
    P_CUSTOMER_ID TYPE OF UID,
    P_TYPE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
begin
  if (P_TYPE is null) then
    P_TYPE = 0;
  if (P_TYPE = 0) then
    for select
            s.SERVICE_ID, s.SRV_TYPE_ID, s.SHIFT_MONTHS, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
            --, (select count(*) from subscr_serv h where h.serv_id = s.service_id and h.state_sgn = 1)
          from SERVICES S
               inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
          where sl.LINK_TYPE = 0
                and (not exists(select
                                    SS.SERV_ID
                                  from SUBSCR_SERV SS
                                  where SS.CUSTOMER_ID = :P_customer_id
                                        and ss.Serv_Id = S.SERVICE_ID))
          order by s.NAME
        into :SERVICE_ID, :SRV_TYPE_ID, :SHIFT_MONTHS, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
    do
      suspend;
  else begin
    for select
            s.SERVICE_ID, s.SRV_TYPE_ID, s.SHIFT_MONTHS, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
          from SERVICES S
               inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
          where sl.LINK_TYPE = 1
          order by s.NAME
        into :SERVICE_ID, :SRV_TYPE_ID, :SHIFT_MONTHS, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
    do
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE API_REMAIN_DAYS (
    CUSTOMER_ID UID,
    FOR_DATE D_DATE = null)
RETURNS (
    REMAIN_DAYS D_INTEGER,
    SUM_ALL_TARIFS D_N15_2,
    SUM_DAY_TARIFS D_N15_2)
AS
declare variable debt   D_N15_2;
declare variable prepay D_N15_2;
declare variable srv_t  D_N15_2;
declare variable days   D_Integer;
declare variable srv_id UID;
begin
  select
      c.debt_sum
    , c.prepay
    from customer c
    where c.customer_id = :CUSTOMER_ID
  into :debt, :prepay;

  remain_days = 0;

  prepay = coalesce(prepay, 0);
  debt = coalesce(-1 * debt, 0) + prepay;
  for_date = coalesce(for_date, current_date);
  days = extract(day from Month_Last_Day(for_date));
  SUM_ALL_TARIFS = 0;

  /* вычисление суммарной платы за месяц для клиента */
  for select
          ss.Serv_Id
        from subscr_serv ss
             inner join services s on (s.Service_Id = ss.Serv_Id)
        where ss.customer_id = :CUSTOMER_ID
              and ((ss.state_sgn = 1)
                or (ss.state_sgn = 0
              and ss.State_Srv = -3)) -- автоблокировка
              and ss.State_Date <= :for_date
              and s.srv_type_id = 0 -- только периодические услуги
      into :srv_id
  do begin
    srv_t = 0;
    srv_t = Get_Srv_Tarif_For_Customer(:CUSTOMER_ID, :srv_id, :for_date);
    SUM_ALL_TARIFS = SUM_ALL_TARIFS + coalesce(srv_t, 0);
  end

  SUM_DAY_TARIFS = SUM_ALL_TARIFS / days;
  if ((SUM_DAY_TARIFS > 0) and (debt > 0)) then
    REMAIN_DAYS = trunc(debt / SUM_DAY_TARIFS);
  else begin
    if ((SUM_DAY_TARIFS = 0) and (debt >= 0)) then
      REMAIN_DAYS = days; -- если тариф 0, то на месяц хватит :)
    else
      REMAIN_DAYS = 0;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE API_REQUEST_CLOSE (
    AREQUEST_ID UID,
    ARESULT D_INTEGER,
    ADEFECT D_NOTICE,
    AEXEC_TIME D_DATETIME = localtimestamp)
AS
begin
  update REQUEST
  set REQ_RESULT = :aRESULT,
      RQ_EXEC_TIME = :aEXEC_TIME,
      RQ_DEFECT = :aDEFECT
  where RQ_ID = :AREQUEST_ID;
end;


CREATE OR ALTER PROCEDURE API_REQUEST_JOIN (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable MY    D_INTEGER;
declare variable WHICH D_VARCHAR1000;
begin
  MY = 0;
  RESULT = 0;
  AUSER = upper(AUSER);
  for select
          upper(W.IBNAME)
        from REQUEST_EXECUTORS E
             inner join WORKER W on (E.EXEC_ID = W.WORKER_ID)
        where E.RQ_ID = :AREQUEST_ID
      into :WHICH
  do begin
    if (AUSER = WHICH) then begin
      MY = 1;
      RESULT = 1;
    end
  end

  if (MY = 0) then begin
    -- присоеденимся
    insert into request_executors (rq_id, exec_id)
    select
        :AREQUEST_ID, w.Worker_Id
      from worker w
      where W.IBNAME = :AUSER
            and w.working = 1
            and w.in_request = 1
            and not exists(select
                               exec_id
                             from request_executors
                             where rq_id = :AREQUEST_ID
                                   and exec_id = w.worker_id);
    -- если удачно, то это и вернем
    if (row_count > 0) then
      RESULT = 1;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE API_REQUEST_REFUSE (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable MY D_INTEGER;
declare variable ALIEN D_INTEGER;
declare variable WHICH D_VARCHAR1000;
begin
  MY = 0;
  ALIEN = 0;
  RESULT = 0;
  AUSER = upper(AUSER);
  for select upper(W.IBNAME)
      from REQUEST_EXECUTORS E
      inner join WORKER W on (E.EXEC_ID = W.WORKER_ID)
      where E.RQ_ID = :AREQUEST_ID
      into :WHICH
  do
  begin
    if (AUSER = WHICH) then
      MY = 1;
    else
      ALIEN = 1;
  end

  if (ALIEN = 0) then
  begin
    if (MY = 1) then
    begin
      -- откажемся
      delete from REQUEST_EXECUTORS
      where RQ_ID = :AREQUEST_ID;
      update REQUEST R
      set R.REQ_RESULT = 0,
          R.RQ_COMPLETED = null,
          R.GIVE_METHOD = null,
          R.GIVE_BY = null
      where R.RQ_ID = :AREQUEST_ID and
            coalesce(R.REQ_RESULT, 0) <= 1;
      RESULT = 1;
    end
  end
  else
  begin
    delete from REQUEST_EXECUTORS
    where RQ_ID = :AREQUEST_ID and
          exists(select W.WORKER_ID
                 from WORKER W
                 where W.IBNAME = :AUSER and
                       EXEC_ID = W.WORKER_ID);
    RESULT = 2;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE API_REQUEST_TAKE (
    AREQUEST_ID UID,
    AUSER D_VARCHAR20 = current_user /* COLLATE UTF8 - default */)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable MY    D_INTEGER;
declare variable ALIEN D_INTEGER;
declare variable WHICH D_VARCHAR1000;
begin
  MY = 0;
  ALIEN = 0;
  RESULT = 0;
  AUSER = upper(AUSER);
  for select
          upper(W.IBNAME)
        from REQUEST_EXECUTORS E
             inner join WORKER W on (E.EXEC_ID = W.WORKER_ID)
        where E.RQ_ID = :AREQUEST_ID
      into :WHICH
  do begin
    if (AUSER = WHICH) then
      MY = 1;
    else
      ALIEN = 1;
  end

  if (ALIEN = 0) then begin
    if (MY = 0) then begin
      -- возьмем
      select
          list(W.WORKER_ID)
        from WORKER W
        where W.IBNAME = :AUSER
      into :WHICH;
      execute procedure REQUESTGIVE(:AREQUEST_ID, localtimestamp, null, :WHICH, 1);
    end
    RESULT = 1;
  end
  else
    RESULT = 2;

  suspend;
end;


CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_DISCOUNT (
    CUSTOMER_ID UID,
    FACTOR_VALUE D_N15_4,
    DATE_FROM D_DATE_NOW = current_date,
    DATE_TO D_DATE_NOW = '2100-01-01',
    SERV_ID UID = -1,
    SRV_TYPE UID = -1,
    NOTICE D_NOTICE = null)
AS
begin
  execute procedure Discount_Iu(null, :Customer_Id, :Date_From, :Date_To, :Factor_Value, :Serv_Id, :Srv_Type, :Notice);
end;


CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_LAN (
    CUSTOMER_ID UID,
    MAC D_MAC,
    IP D_IP = null /* COLLATE UTF8 - default */,
    EQ_ID D_UID_NULL = null,
    PORT D_INTEGER = null,
    VLAN_ID D_UID_NULL = null,
    NOTICE D_NOTICE = null /* COLLATE UTF8 - default */,
    IPV6 D_IPV6 = null /* COLLATE UTF8 - default */,
    IP_ADD D_IP = null /* COLLATE UTF8 - default */,
    TAG D_INTEGER = null,
    TAG_STR D_VARCHAR50 = null /* COLLATE UTF8 - default */)
AS
declare variable Lan_Id type of Uid;
begin
  Lan_Id = null;

  if (ip = '0.0.0.0') then
    ip = null;

  if (ip is null) then begin
    if (not Vlan_Id is null) then begin
      select
          IP
        from GET_FREE_VLAN_IP(:Vlan_Id)
      into :ip;
    end
    else begin
      if (not Eq_Id is null) then begin
        select
            IP
          from GET_FREE_VLAN_IP((select
                                     e.vlan_id
                                   from equipment e
                                   where e.eid = :Eq_Id))
        into :ip;
      end
      else begin
        select
            Str_Ip
          from Int2ip((select
                           max(l.Ip_Bin)
                         from V_ALL_IP l) + 1)
        into :ip;
      end
    end
  end
  if (not ip is null) then begin
    select
        lan_id
      from Tv_Lan t
      where t.Ip = :ip
    into :Lan_Id;
  end

  if (Lan_Id is null) then begin
    Lan_Id = gen_id(gen_operations_uid, 1);
    insert into Tv_Lan (Lan_Id, Customer_Id, Ip, Ipv6, Mac, Ip_Add, Port, Notice, Tag, Tag_Str, Eq_Id, Vlan_Id)
    values (:Lan_Id, :Customer_Id, :Ip, :Ipv6, :Mac, :Ip_Add, :Port, :Notice, :Tag, :Tag_Str, :Eq_Id, :Vlan_Id);
  end
end;


CREATE OR ALTER PROCEDURE API_SET_CUSTOMER_SERVICE (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    SET_ON D_INTEGER = 1,
    SET_DATE D_DATE = current_date,
    SRV_ON_OFF TYPE OF UID = null)
AS
declare variable Units     d_integer;
declare variable AUTOBLOCK d_integer;
declare variable Debt      D_N15_2;

begin
  Set_On = coalesce(Set_On, 1);
  Set_Date = coalesce(Set_Date, current_date);
  Units = 1;
  if (SRV_ON_OFF is null) then begin
    select first 1
        won.Child
      from SERVICES_LINKS won
      where won.Parent = :SERVICE_ID
            and ((1 = :set_on
            and won.Link_Type = 7)
              or (0 = :set_on
            and won.Link_Type = 8))
    into :srv_on_off;
  end

  if (Set_On = 0) then
    execute procedure Onoff_Service_By_Id(:Customer_Id, :Service_Id, :srv_on_off, :Set_Date, 1, null, :Units);
  else begin
    -- если включаем услугу. то проверим баланс и тип услуги
    -- если баланс отрицательный и тип блокировать при недостатке, то такую услугу не включаем
    select (c.Prepay - c.Debt_Sum)
        , coalesce((select
                        s.Autooff
                      from services s
                      where s.Service_Id = :SERVICE_ID), 0)
      from customer c
      where c.Customer_Id = :Customer_Id
    into :DEBT, :AUTOBLOCK;

    if ((DEBT >= 0)
        or
        (AUTOBLOCK = 0)) then
      execute procedure Add_Subscr_Service(:Customer_Id, :Service_Id, :srv_on_off, :Set_Date, null, :Units, null, null);
  end
end;


CREATE OR ALTER PROCEDURE API_SET_PREPAY (
    CUSTOMER_ID INTEGER,
    PREPAY_SUM NUMERIC(15,2))
RETURNS (
    MSG VARCHAR(255),
    CODE SMALLINT)
AS
declare variable remain      D_N15_2;
declare variable prepay      D_N15_2;
declare variable max_prepay  D_N15_2;
declare variable prepay_time D_Timestamp;
declare variable dat         D_Varchar10;

begin
  select
      cast(s.var_value as numeric(15,2))
    from settings s
    where s.var_name = 'PREPAY_MAX'
  into :max_prepay;

  if (max_prepay is null) then begin
    max_prepay = 5;
    delete from settings s where s.var_name = 'PREPAY_MAX';
    insert into settings (var_name, var_value, var_notice)
    values ('PREPAY_MAX', :max_prepay, 'Максимальная сумма обещанного платежа');
  end

  code = -1;
  select
      c.debt_sum
    , c.prepay
    , c.prepay_time
    from customer c
    where c.customer_id = :customer_id
  into :remain, :prepay, :prepay_time;

  if ((prepay_sum <= 0)
      or
      (prepay_sum > max_prepay)) then
    msg = 'Значение суммы обещанного платежа ' || :prepay_sum || ' за рамками допустимого диапазона значений (0-' || :max_prepay || ' руб)';
  else
  if (:prepay_sum < :remain) then
    msg = 'Указанной суммы обещанного платежа недостаточно для погашения задолженности';
  else
  if (:prepay > 0) then begin
    msg = 'Не погашен предыдущий обещанный платеж на сумму ' || :prepay || ' руб. от ' || :prepay_time;
  end
  else begin
    execute procedure set_prepay(:customer_id, :prepay_sum);
    code = 0;
    msg = 'Операция успешно завершена';
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE API_SET_SWITCH_QUEUE (
    CUSTOMER_ID TYPE OF UID,
    LINK_ID TYPE OF UID)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable FROM_SRV   type of UID;
declare variable TO_SRV     type of UID;
declare variable SWITCH_SRV type of UID;
begin
  select
      Parent, Child, Add_Srv
    from SERVICES_LINKS sl
    where sl.LINK_TYPE = 6
          and sl.LINK_ID = :LINK_ID
  into :FROM_SRV, :TO_SRV, :Switch_Srv;

  select
      Result
    from Queue_Switch(:Customer_Id, :From_Srv, :To_Srv, :Switch_Srv)
  into :Result;
  suspend;
end;


CREATE OR ALTER PROCEDURE ATRIBUTES_LINE (
    CUST_ID TYPE OF UID)
RETURNS (
    A_LINE D_VARCHAR500)
AS
declare variable vStr  type of D_Varchar1000;
declare variable vAttr type of D_Varchar1000;
begin
  A_LINE = '';
  vStr = '';
  for select
          O.O_Dimension
        from Objects O
             inner join Customer_Attributes A on (O.O_Id = A.O_Id and
                   o.O_TYPE = 4)
        where not(o.O_Dimension is null)
              and (o.O_Dimension <> '')
              and a.Customer_Id = :Cust_Id
        order by o.O_Name
      into :vAttr
  do
    vStr = vStr || ' ' || vAttr;
  vStr = trim(vStr);
  if (char_length(vStr) > 500) then
    vStr = substring(vStr from 1 for 497) || '...';
  A_LINE = vStr;
  suspend;
end;


CREATE OR ALTER PROCEDURE ATTRIBUTE_CHECK_UNIQ (
    TYPE_ID TYPE OF COLUMN ATTRIBUTE.TYPE_ID,
    OBJECT_ID TYPE OF COLUMN ATTRIBUTE.OBJECT_ID,
    AID TYPE OF COLUMN ATTRIBUTE.AID,
    AVALUE TYPE OF COLUMN ATTRIBUTE.AVALUE)
RETURNS (
    RESULT VARCHAR(255))
AS
declare variable OID D_Uid_Null;
begin
  result = '';
  OID = null;

  select
      Object_Id
    from Attribute
    where (Type_Id = :Type_Id)
          and (Aid = :Aid)
          and (Object_Id <> :Object_Id)
          and (ADELETED = 0)
          and (upper(Avalue) = upper(:Avalue))
  into :OID;

  if (not OID is null) then begin
    -- 4  'Атрибуты абонента';
    if (Type_Id = 4) then
      select
          c.Account_No || ' код ' || c.Cust_Code || ' ФИО ' || c.Firstname || ' ' || c.Initials
        from customer c
        where c.Customer_Id = :OID
      into :result;

    -- 63 'Атрибуты сетей';
    if (Type_Id = 63) then
      select
          v.Name || ' / ' || coalesce(v.Ip_Begin, '') || '-' || coalesce(v.Ip_End, '')
        from vlans v
        where v.V_Id = :OID
      into :result;

    -- 25 'Атрибуты услуг';
    if (Type_Id = 25) then
      select
          v.Name
        from services v
        where v.Service_Id = :OID
      into :result;

    -- 37 'Атрибуты домов';
    if (Type_Id = 37) then
      select
          s.Street_Short || ' ' || s.Street_Name || ' ' || h.House_No
        from house h
             inner join street s on (h.Street_Id = s.Street_Id)
        where h.House_Id = :OID
      into :result;

    -- 39 'Атрибуты узлов';
    if (Type_Id = 39) then
      select
          n.Name
        from Nodes n
        where n.Node_Id = :OID
      into :result;

    -- 32 'Атрибуты IPTV групп';
    -- 6  'Атрибуты ТВ оборудования';
    -- 50 'Атрибуты для типа оборудования';
    -- 5  'Атрибуты сетевого оборудования';
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE ATTRIBUTES_IUD (
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR50,
    O_DESCRIPTION D_NOTICE,
    O_DIMENSION D_VARCHAR50,
    O_DELETED D_INTEGER,
    O_CHARFIELD D_VARCHAR1000,
    O_CHECK D_VARCHAR255,
    P_ACTION D_INTEGER,
    O_TYPE D_INTEGER,
    O_NUMERICFIELD D_INTEGER = null)
AS
begin
  -- P_ACTION -0 insert 1-update 2-delete
  if (P_ACTION = 1) then begin
    update OBJECTS
    set O_NAME = :O_NAME,
        O_DESCRIPTION = :O_DESCRIPTION,
        O_DIMENSION = :O_DIMENSION,
        O_CHARFIELD = :O_CHARFIELD,
        O_CHECK = :O_CHECK,
        O_Numericfield = :O_Numericfield,
        O_DELETED = coalesce(:O_DELETED, 0)
    where O_ID = :O_ID
          and O_TYPE = :O_TYPE;
  end
  else begin
    if (P_ACTION = 0) then begin
      insert into OBJECTS (O_ID, O_TYPE, O_NAME, O_DESCRIPTION, O_DELETED, O_DIMENSION, O_CHARFIELD, O_CHECK, O_Numericfield)
      values (:O_ID, :O_TYPE, :O_NAME, :O_DESCRIPTION, 0, :O_DIMENSION, :O_CHARFIELD, :O_CHECK, :O_Numericfield);
    end
    else
      update OBJECTS
      set O_DELETED = 1
      where O_ID = :O_ID
            and O_TYPE = :O_TYPE;
  end
end;


CREATE OR ALTER PROCEDURE AUTO_OFF_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERV_ID TYPE OF UID,
    P_DATE D_DATE,
    P_ACTSERVICE D_INTEGER,
    P_NOTICE D_NOTICE)
AS
declare P_SUBSCR_SERV_ID type of UID;
declare variable BUSINESS_TYPE    D_INTEGER;
declare variable D_ACT            D_INTEGER;
declare variable ACT_TIMESTAMP    type of D_TIMESTAMP;
declare variable SWITCH_TO_SRV    D_INTEGER;
declare variable srv_on_off       D_INTEGER;
begin
  if (P_ACTSERVICE is null) then
    P_ACTSERVICE = -3;
  -- Если отключаем услугу
  select
      SUBSCR_SERV_ID
    from SUBSCR_SERV
    where CUSTOMER_ID = :P_CUSTOMER_ID
          and SERV_ID = :P_SERV_ID
  into :P_SUBSCR_SERV_ID;

  select
      S.BUSINESS_TYPE
    from SERVICES S
    where S.service_id = :P_SERV_ID
  into :BUSINESS_TYPE;

  -- отключаем услугу
  update SUBSCR_HIST SH
  set SH.DATE_TO = (:P_DATE - 1),
      SH.DISACT_SERV_ID = :P_ACTSERVICE
  where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
        and SH.DISACT_SERV_ID = -1;

  update SUBSCR_SERV
  set STATE_SGN = 0,
      NOTICE = :P_NOTICE,
      STATE_DATE = :P_DATE,
      STATE_SRV = :P_ACTSERVICE
  where SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

  if (BUSINESS_TYPE >= 2) then begin
    D_ACT = 2;
    if (P_DATE = current_date) then
      ACT_TIMESTAMP = localtimestamp;
    else
      ACT_TIMESTAMP = P_DATE;
    execute procedure DIGITAL_EVENT(:D_ACT, :P_CUSTOMER_ID, null, :P_SERV_ID, :ACT_TIMESTAMP, null);
  end
  -- проверим, если есть услуга вклюячаемая при автоблокировке. то выключим ее
  select
      l.Child
    , l.Add_Srv
    from SERVICES_LINKS l
    where l.Link_Type = 6
          and l.Switch_Time = -1
          and l.Parent = :P_SERV_ID
  into :SWITCH_TO_SRV, :srv_on_off;

  if (not SWITCH_TO_SRV is null) then begin
    execute procedure Add_Subscr_Service(:P_CUSTOMER_ID, :SWITCH_TO_SRV, :srv_on_off, :P_DATE, null, 1, null, null, 0);
  end
end;


CREATE OR ALTER PROCEDURE AUTO_ON_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERV_ID TYPE OF UID,
    P_DATE D_DATE,
    P_ACTSERVICE D_INTEGER,
    P_NOTICE D_NOTICE)
RETURNS (
    RESULT D_INTEGER)
AS
declare P_SUBSCR_SERV_ID type of UID;
declare variable BUSINESS_TYPE    D_INTEGER;
declare variable D_ACT            D_INTEGER;
declare variable ACT_TIMESTAMP    type of D_TIMESTAMP;
declare variable fromd            d_date;
declare variable maxDateOff       d_date;
declare variable h_id             d_integer;
declare variable SWITCH_TO_SRV    D_INTEGER;
declare variable srv_on_off       D_INTEGER;
begin
  -- Если отключаем услугу
  result = 0;
  select
      SUBSCR_SERV_ID
    from SUBSCR_SERV
    where CUSTOMER_ID = :P_CUSTOMER_ID
          and SERV_ID = :P_SERV_ID
  into :P_SUBSCR_SERV_ID;

  select
      S.BUSINESS_TYPE
    from SERVICES S
    where S.SERVICE_ID = :P_SERV_ID
  into :BUSINESS_TYPE;

  select
      max(SH.DATE_TO)
    from SUBSCR_HIST SH
    where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
  into :maxDateOff;

  select
      max(SH.DATE_TO)
    from SUBSCR_HIST SH
    where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
          and sh.Disact_Serv_Id = -3
  into :FROMD;

  if (FROMD < P_DATE) then begin
    -- проверим, если есть услуга вклюячаемая при автоблокировке. то выключим ее
    select
        l.Child
      , l.Add_Srv
      from SERVICES_LINKS l
      where l.Link_Type = 6
            and l.Switch_Time = -1
            and l.Parent = :P_SERV_ID
    into :SWITCH_TO_SRV, :srv_on_off;

    if (not SWITCH_TO_SRV is null) then begin
      execute procedure Onoff_Service_By_Id(:P_Customer_Id, :SWITCH_TO_SRV, :srv_on_off, :P_Date, 1, null, 1, 0);
    end

    update SUBSCR_SERV
    set STATE_SGN = 1,
        NOTICE = :P_NOTICE,
        STATE_DATE = :P_DATE,
        STATE_SRV = :P_ACTSERVICE
    where CUSTOMER_ID = :P_CUSTOMER_ID
          and SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

    H_ID = gen_id(GEN_OPERATIONS_UID, 1);

    if (maxDateOff = FROMD) then
      maxDateOff = cast('2100-01-01' as date);

    insert into SUBSCR_HIST (SUBSCR_HIST_ID, CUSTOMER_ID, SERV_ID, SUBSCR_SERV_ID, DATE_FROM, DATE_TO, ACT_SERV_ID, DISACT_SERV_ID)
    values (:H_ID, :P_CUSTOMER_ID, :P_SERV_ID, :P_SUBSCR_SERV_ID, :P_DATE, :maxDateOff, :P_ACTSERVICE, -1);

    if (BUSINESS_TYPE >= 2) then begin
      D_ACT = 1;
      if (P_DATE = current_date) then
        ACT_TIMESTAMP = localtimestamp;
      else
        ACT_TIMESTAMP = P_DATE;
      execute procedure DIGITAL_EVENT(:D_ACT, :P_CUSTOMER_ID, null, :P_SERV_ID, :ACT_TIMESTAMP, null);
    end

    select
        cast(s.Var_Value as date)
      from settings s
      where s.Var_Name = 'CURRENT_DATE'
    into :fromd;

    execute procedure CLOSE_MONTH_PROC(:P_DATE, :P_CUSTOMER_ID);

  end
  else
    result = -2; -- E_WRONG_ONDATE;
end;


CREATE OR ALTER PROCEDURE BCISSUECH_ID (
    BI_ID TYPE OF COLUMN BCI_CHANNELS.BI_ID,
    CH_ID TYPE OF COLUMN BCI_CHANNELS.CH_ID,
    P_ACTION D_INTEGER = 0)
AS
begin
  -- P_ACTION -0 insert 1-update 2-delete
  if ((P_ACTION = 1)
      or
      (P_ACTION = 0)) then begin
    update or insert into Bci_Channels (Bi_Id,Ch_Id) values (:Bi_Id, :Ch_Id)
    matching (Bi_Id, Ch_Id);
  end
  else begin
    if (P_ACTION = 2) then
      Delete from Bci_Channels
      where (Bi_Id = :Bi_Id
            and Ch_Id = :Ch_Id);
  end
end;


CREATE OR ALTER PROCEDURE BONUS_ADD_AFTER_PAYMENT (
    P_CUSTOMER_ID UID,
    P_PAYMENT_ID UID,
    P_PAY_SUM D_N15_2)
AS
declare variable debt     D_N15_2;
declare variable rate     D_N15_2;
declare variable REAL_PAY D_N15_2;
declare variable vBT      D_Integer;
begin
  if (coalesce(P_PAY_SUM, -1) <= 0) then
    exit;

  /* могут быть бонус от суммы оплаты, т.е. если заплатил более Х рублей */

  -- проверим есть ли бонус за это
  select
      count(r.Rate)
    from Bonus_Rate r
    where current_date between r.Date_From and r.Date_To
  into :rate;

  if (rate > 0) then begin
    select
        c.Debt_Sum
      from customer c
      where c.Customer_Id = :P_CUSTOMER_ID
    into :debt;
    if (debt is null) then
      debt = 0;
    REAL_PAY = P_PAY_SUM;
    debt = debt + P_PAY_SUM; -- платеж уже учтен, дубавим его к сальдо
    if (debt > 0) -- если была задолженность, то уменьшим сумму платежа
    then
      REAL_PAY = P_PAY_SUM - debt;

    rate = null;
    select first 1
        r.Rate
      , r.Bt_Id
      from Bonus_Rate r
      where current_date between r.Date_From and r.Date_To
            and :REAL_PAY >= r.Units_From
            and :REAL_PAY < r.Units_To
            and r.Bt_Id in (1, 2, 3)
    into :rate, :vBT;
    if (rate is not null) then begin
      if (vBT = 1) then begin
        -- Процент от платежа
        rate = round(REAL_PAY * rate / 100, 2);
        if (Rate > 0) then
          insert into Customer_Bonuses (Customer_Id, Customer_Debt, Bt_Id, Bonus, Ext_Id, Units)
          values (:P_Customer_Id, :debt, :vBT, :rate, :P_PAYMENT_ID, :REAL_PAY);
      end
      else
      if (vBT = 2) then begin
        -- Баллы % от платежа
        rate = round(REAL_PAY * rate / 100, 2);
        if (Rate > 0) then
          insert into Customer_Bonuses (Customer_Id, Customer_Debt, Bt_Id, Bonus, Ext_Id, Units)
          values (:P_Customer_Id, :debt, :vBT, 0, :P_PAYMENT_ID, :rate);
      end
      else
      if (vBT = 3) then begin
        -- Баллы за платеж
        if (Rate > 0) then
          insert into Customer_Bonuses (Customer_Id, Customer_Debt, Bt_Id, Bonus, Ext_Id, Units)
          values (:P_Customer_Id, :debt, :vBT, 0, :P_PAYMENT_ID, :rate);
      end
    end
  end

  /* могут быть бонус от суммы оплаты, т.е. если оплатил более Х месяцев */
  -- не реализовано
end;


CREATE OR ALTER PROCEDURE BONUS_RATE_INS (
    ID UID,
    BT_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    UNITS_FROM NUMERIC(15,2),
    UNITS_TO NUMERIC(15,2),
    RATE NUMERIC(15,2),
    NOTICE VARCHAR(1000))
AS
begin
  insert into Bonus_Rate (
    ID,
    Bt_Id,
    Date_From,
    Date_To,
    Units_From,
    Units_To,
    Rate,
    Notice)
  values (
    :ID,
    :Bt_Id,
    :Date_From,
    :Date_To,
    :Units_From,
    :Units_To,
    :Rate,
    :Notice);
end;


CREATE OR ALTER PROCEDURE BONUS_RATE_UPD (
    ID UID,
    BT_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    UNITS_FROM NUMERIC(15,2),
    UNITS_TO NUMERIC(15,2),
    RATE NUMERIC(15,2),
    NOTICE VARCHAR(1000))
AS
begin
  update Bonus_Rate
  set Date_From = :Date_From,
      Date_To = :Date_To,
      Bt_Id = :BT_ID,
      Units_From = :Units_From,
      Units_To = :Units_To,
      Rate = :Rate,
      Notice = :Notice
  where Id = :Id;
end;


CREATE OR ALTER PROCEDURE CALC_DAY_INC_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
declare variable V_SERVICE_ID  D_INTEGER; -- declare variable DAYS_IN_MON   D_INTEGER;
declare variable V_S_MONTH     D_DATE;
declare variable V_E_MONTH     D_DATE;
declare variable V_UNITS       D_N15_2;
declare variable V_FEE         D_N15_2;
declare variable V_FEE_JUR     D_N15_2;
declare variable V_FEE_BEFORE  D_N15_2;
declare variable PERS_TAR      D_N15_2;
declare variable VAT           D_N15_2;
declare variable V_IS_JUR      D_SMALLINT;
declare variable AUTOOFF       D_SMALLINT;
declare variable V_VATG_ID     D_INTEGER;
declare variable Debt_Sum      D_N15_2;
declare variable hand_control  D_INTEGER;
declare variable POSITIVE_ONLY D_Iboolean;
declare variable SrvType       D_Integer;
begin
  if (P_CALC_TYPE is null) then
    P_CALC_TYPE = 5;

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  for select
          S.SERVICE_ID
        , s.Autooff
        , C.JURIDICAL
        , C.VATG_ID
        , s.BUSINESS_TYPE
        ,
          (-1 * c.Debt_Sum + coalesce(c.Prepay, 0))
        , coalesce(c.Hand_Control, 0)
        , coalesce(POSITIVE_ONLY, 0)
        from SERVICES S
             inner join Subscr_Serv ss on (s.Service_Id = ss.Serv_Id)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :P_CALC_TYPE
              and c.Customer_Id = :P_CUSTOMER_ID
        order by coalesce(s.Priority, 99)
      into :V_SERVICE_ID, :AUTOOFF, :V_IS_JUR, :V_VATG_ID, :SrvType, :Debt_Sum, :hand_control, :POSITIVE_ONLY
  do begin

    if (V_IS_JUR is null) then
      V_IS_JUR = 0;

    V_UNITS = null;
    if (AUTOOFF is null) then
      AUTOOFF = 0;
    if (P_MONTH <> current_date) then
      AUTOOFF = 0; -- автоотключение только текущим числом
    -- начало месяца
    V_S_MONTH = (P_MONTH - extract(day from P_MONTH) + 1);
    -- если текущий месяц, то считаем до текущего числа, иначе до конца месяца
    if (V_S_MONTH = (current_date - extract(day from current_date) + 1)) then
      V_E_MONTH = current_date;
    else
      V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

    select
        count(T_DAY)
      , sum(TARIF)
      , sum(Tarif_Jur)
      from (select distinct
                DT.T_DAY
              , DT.TARIF
              , DT.Tarif_Jur
              from SUBSCR_HIST S
                   inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
              where S.SERV_ID = :V_SERVICE_ID
                    and ((DT.T_DAY between S.DATE_FROM and dateadd(day, 1, S.DATE_TO))) -- or (DT.T_DAY = S.DATE_FROM))
                    and S.CUSTOMER_ID = :P_CUSTOMER_ID
                    and DT.T_DAY between :V_S_MONTH and :V_E_MONTH)
    into :V_UNITS, :V_FEE, :V_FEE_JUR;

    -- проверим есть ли персональный тариф
    if (V_UNITS <> 0) then begin
      if (V_IS_JUR = 1) then
        V_FEE = V_FEE_JUR; -- юр. по другому тарифу

      -- проверим есть ли персональный тариф
      PERS_TAR = iif(exists(select
                                P.TARIF_SUM
                              from PERSONAL_TARIF P
                              where P.SERVICE_ID = :V_SERVICE_ID
                                    and P.CUSTOMER_ID = :P_CUSTOMER_ID
                                    and ((:V_S_MONTH between P.DATE_FROM and P.DATE_TO)
                                      or (:V_E_MONTH between P.DATE_FROM and P.DATE_TO))), 1, 0);
      if (PERS_TAR = 1) then begin
        execute procedure Calc_Pers_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR);
        select
            sum(DT.TARIF)
          from SUBSCR_HIST S
               inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
          where S.SERV_ID = :V_SERVICE_ID
                and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                and S.CUSTOMER_ID = :P_CUSTOMER_ID
                and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
        into :V_FEE;
      end
      else begin
        if (exists(select
                       D.Discount_Id
                     from DISCOUNT_FACTOR D
                     where D.CUSTOMER_ID = :P_CUSTOMER_ID
                           and ((:V_S_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (:V_E_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (D.DATE_FROM between :V_S_MONTH and :V_E_MONTH)
                             or (D.DATE_TO between :V_S_MONTH and :V_E_MONTH))
                           and ((D.SERV_ID = :V_SERVICE_ID)
                             or ((D.SERV_ID = -1)
                           and ((D.Srv_Type = -1)
                             or (d.Srv_Type = :SrvType)))))) then begin
          execute procedure Calc_Koef_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR, :SrvType);
          select
              sum(DT.TARIF)
            from SUBSCR_HIST S
                 inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
            where S.SERV_ID = :V_SERVICE_ID
                  and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                  and S.CUSTOMER_ID = :P_CUSTOMER_ID
                  and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
          into :V_FEE;
        end
      end

      -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
      if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
        VAT = 0;
        select first 1
            T.TARIF_SUM
          from OBJECTS O
               inner join TARIF T on (O.O_ID = T.SERVICE_ID)
          where T.SERVICE_ID = :V_VATG_ID
                and O.O_TYPE = 13
                and :P_MONTH between T.DATE_FROM and T.DATE_TO
        into :VAT;
        VAT = coalesce(VAT, 0);
        V_FEE = V_FEE + V_FEE * VAT / 100;
      end
      V_FEE = round(V_FEE, FEE_ROUND);

      /* проверим автоблкировка услуги включена и разрешена ли автоблокировка пользователя */
      if ((AUTOOFF = 0)
          or
          (hand_control = 1)) then
        Debt_Sum = V_FEE + 1; -- если не отключать, то баланс должен быть больше начислений
      else begin
        /* Если нужно блокировать то посмотрим сколько за услугу уже начисленно в этом месяце и учтем это при блокировке */
        if (POSITIVE_ONLY = 1) then begin
          select
              sum(FEE)
            from MONTHLY_FEE
            where MONTH_ID = :V_S_MONTH
                  and CUSTOMER_ID = :P_CUSTOMER_ID
                  and SERVICE_ID = :V_SERVICE_ID
          into :V_FEE_BEFORE;
          if (V_FEE_BEFORE is not null) then
            Debt_Sum = Debt_Sum + V_FEE_BEFORE;
        end
      end

      if (((Debt_Sum >= V_FEE) and (POSITIVE_ONLY = 1)) -- не допускаем минус у абонента
          or
          ((Debt_Sum >= 0) and (POSITIVE_ONLY = 0))) -- Если баланс >= 0 не отключаем
      then
        update or insert into MONTHLY_FEE (MONTH_ID, SERVICE_ID, CUSTOMER_ID, UNITS, FEE)
        values (:V_S_MONTH, :V_SERVICE_ID, :P_CUSTOMER_ID, :V_UNITS, :V_FEE)
        matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
      else begin
        -- отключим если нет денег
        select
            count(*)
          from subscr_hist sh
          where sh.Customer_Id = :P_Customer_Id
                and sh.Serv_Id = :V_SERVICE_ID
                and current_date between sh.Date_From and sh.Date_To
        into :AUTOOFF;
        if (AUTOOFF > 0) then
          execute procedure Auto_Off_Service(:P_Customer_Id, :V_SERVICE_ID, current_date, null, null);
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_DAY_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
declare variable V_SERVICE_ID  D_INTEGER; -- declare variable DAYS_IN_MON   D_INTEGER;
declare variable V_S_MONTH     D_DATE;
declare variable V_E_MONTH     D_DATE;
declare variable V_UNITS       D_N15_2;
declare variable V_FEE         D_N15_2;
declare variable V_FEE_JUR     D_N15_2;
declare variable V_FEE_BEFORE  D_N15_2;
declare variable PERS_TAR      D_N15_2;
declare variable VAT           D_N15_2;
declare variable V_IS_JUR      D_SMALLINT;
declare variable AUTOOFF       D_SMALLINT;
declare variable V_VATG_ID     D_INTEGER;
declare variable Debt_Sum      D_N15_2;
declare variable hand_control  D_INTEGER;
declare variable POSITIVE_ONLY D_Iboolean;
declare variable SrvType       D_Integer;
begin
  if (P_CALC_TYPE is null) then
    P_CALC_TYPE = 2;

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  for select
          S.SERVICE_ID
        , s.Autooff
        , C.JURIDICAL
        , C.VATG_ID
        , s.BUSINESS_TYPE
        ,
          (-1 * c.Debt_Sum + coalesce(c.Prepay, 0))
        , coalesce(c.Hand_Control, 0)
        , coalesce(POSITIVE_ONLY, 0)
        from SERVICES S
             inner join Subscr_Serv ss on (s.Service_Id = ss.Serv_Id)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :P_CALC_TYPE
              and c.Customer_Id = :P_CUSTOMER_ID
        order by coalesce(s.Priority, 99)
      into :V_SERVICE_ID, :AUTOOFF, :V_IS_JUR, :V_VATG_ID, :SrvType, :Debt_Sum, :hand_control, :POSITIVE_ONLY
  do begin

    if (V_IS_JUR is null) then
      V_IS_JUR = 0;

    V_UNITS = null;
    if (AUTOOFF is null) then
      AUTOOFF = 0;
    if (P_MONTH <> current_date) then
      AUTOOFF = 0; -- автоотключение только текущим числом
    -- начало месяца
    V_S_MONTH = (P_MONTH - extract(day from P_MONTH) + 1);
    -- если текущий месяц, то считаем до текущего числа, иначе до конца месяца
    if (V_S_MONTH = (current_date - extract(day from current_date) + 1)) then
      V_E_MONTH = current_date;
    else
      V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

    select
        count(DT.T_DAY)
      , sum(DT.TARIF)
      , sum(DT.Tarif_Jur)
      from SUBSCR_HIST S
           inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
      where S.SERV_ID = :V_SERVICE_ID
            and DT.T_DAY between S.DATE_FROM and S.DATE_TO
            and S.CUSTOMER_ID = :P_CUSTOMER_ID
            and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
    into :V_UNITS, :V_FEE, :V_FEE_JUR;

    if (V_UNITS <> 0) then begin

      if (V_IS_JUR = 1) then
        V_FEE = V_FEE_JUR; -- юр. по другому тарифу

      -- проверим есть ли персональный тариф
      PERS_TAR = iif(exists(select
                                P.TARIF_SUM
                              from PERSONAL_TARIF P
                              where P.SERVICE_ID = :V_SERVICE_ID
                                    and P.CUSTOMER_ID = :P_CUSTOMER_ID
                                    and ((:V_S_MONTH between P.DATE_FROM and P.DATE_TO)
                                      or (:V_E_MONTH between P.DATE_FROM and P.DATE_TO))), 1, 0);
      if (PERS_TAR = 1) then begin
        execute procedure Calc_Pers_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR);
        select
            sum(DT.TARIF)
          from SUBSCR_HIST S
               inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
          where S.SERV_ID = :V_SERVICE_ID
                and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                and S.CUSTOMER_ID = :P_CUSTOMER_ID
                and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
        into :V_FEE;
      end
      else begin
        if (exists(select
                       D.Discount_Id
                     from DISCOUNT_FACTOR D
                     where D.CUSTOMER_ID = :P_CUSTOMER_ID
                           and ((:V_S_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (:V_E_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (D.DATE_FROM between :V_S_MONTH and :V_E_MONTH)
                             or (D.DATE_TO between :V_S_MONTH and :V_E_MONTH))
                           and ((D.SERV_ID = :V_SERVICE_ID)
                             or ((D.SERV_ID = -1)
                           and ((D.Srv_Type = -1)
                             or (d.Srv_Type = :SrvType)))))) then begin
          execute procedure Calc_Koef_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR, :SrvType);
          select
              sum(DT.TARIF)
            from SUBSCR_HIST S
                 inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
            where S.SERV_ID = :V_SERVICE_ID
                  and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                  and S.CUSTOMER_ID = :P_CUSTOMER_ID
                  and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
          into :V_FEE;
        end
      end

      -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
      if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
        VAT = 0;
        select first 1
            T.TARIF_SUM
          from OBJECTS O
               inner join TARIF T on (O.O_ID = T.SERVICE_ID)
          where T.SERVICE_ID = :V_VATG_ID
                and O.O_TYPE = 13
                and :P_MONTH between T.DATE_FROM and T.DATE_TO
        into :VAT;
        VAT = coalesce(VAT, 0);
        V_FEE = V_FEE + V_FEE * VAT / 100;
      end
      V_FEE = round(V_FEE, FEE_ROUND);
      /* проверим автоблкировка услуги включена и разрешена ли автоблокировка пользователя */
      if ((AUTOOFF = 0)
          or
          (hand_control = 1)) then
        Debt_Sum = V_FEE + 1; -- если не отключать, то баланс должен быть больше начислений
      else begin
        /* Если нужно блокировать то посмотрим сколько за услугу уже начисленно в этом месяце и учтем это при блокировке */
        if (POSITIVE_ONLY = 1) then begin
          select
              sum(FEE)
            from MONTHLY_FEE
            where MONTH_ID = :V_S_MONTH
                  and CUSTOMER_ID = :P_CUSTOMER_ID
                  and SERVICE_ID = :V_SERVICE_ID
          into :V_FEE_BEFORE;
          if (V_FEE_BEFORE is not null) then
            Debt_Sum = Debt_Sum + V_FEE_BEFORE;
        end
      end

      if (((Debt_Sum >= V_FEE) and (POSITIVE_ONLY = 1)) -- не допускаем минус у абонента
          or
          ((Debt_Sum >= 0) and (POSITIVE_ONLY = 0))) -- Если баланс >= 0 не отключаем
      then
        update or insert into MONTHLY_FEE (MONTH_ID, SERVICE_ID, CUSTOMER_ID, UNITS, FEE)
        values (:V_S_MONTH, :V_SERVICE_ID, :P_CUSTOMER_ID, :V_UNITS, :V_FEE)
        matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
      else begin
        -- отключим если нет денег
        select
            count(*)
          from subscr_hist sh
          where sh.Customer_Id = :P_Customer_Id
                and sh.Serv_Id = :V_SERVICE_ID
                and current_date between sh.Date_From and sh.Date_To
        into :AUTOOFF;
        if (AUTOOFF > 0) then
          execute procedure Auto_Off_Service(:P_Customer_Id, :V_SERVICE_ID, current_date, null, null);
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_DAY_TARIF (
    P_MONTH D_DATE,
    P_CALC_TYPE D_INTEGER)
AS
DECLARE VARIABLE VTARIF d_N15_5;
DECLARE VARIABLE JTARIF d_N15_5;
DECLARE VARIABLE LD D_INTEGER;
DECLARE VARIABLE I d_INTEGER;
DECLARE VARIABLE START_MONTH d_DATE;
DECLARE VARIABLE T_DAY d_DATE;
DECLARE VARIABLE p_serv_id d_INTEGER;
declare variable max_shift d_integer;
declare variable min_shift d_integer;
declare variable j d_integer;
BEGIN
  if (p_calc_type is null) then p_calc_type = 0;
  DELETE FROM days_tarif;

  select max(s.shift_months), min(s.shift_months) from services s
  into :max_shift, :min_shift;

  p_month = p_month - EXTRACT(DAY FROM p_month) + 1;
  START_MONTH = p_month;
  j = min_shift;
  while (j<=max_shift) do begin
    p_month = dateadd(j month to START_MONTH );

    -- кол-во дней в месяце
    ld  = extract(day from dateadd( -1 day to (dateadd(1 month to p_month))));

    i = 0;
    WHILE (i < ld) DO BEGIN
          t_day = :p_month + i;
          for
            select s.service_id, t.tarif_sum, t.tarif_sum_jur
              from tarif t inner join services s on (t.service_id = s.service_id)
              where s.srv_type_id = 0 and s.calc_type = :p_calc_type
                AND :t_day BETWEEN t.date_from AND t.date_to
            INTO :p_serv_id, :vtarif, :jtarif
          do begin
            IF (vtarif IS NOT NULL)
            THEN vtarif = round(vtarif/ld,5);
            else vtarif = 0;
            IF (jtarif IS NOT NULL)
            THEN jtarif = round(jtarif/ld,5);
            else jtarif = 0;
            INSERT INTO days_tarif VALUES (:p_serv_id,:t_day,:vtarif, :jtarif);
          end
          i = i+1;
    END
    j = j +1;
  end

END;


CREATE OR ALTER PROCEDURE CALC_DISCOUNT (
    FOR_MONTH TYPE OF D_DATE)
AS
declare variable DISCOUNT    D_N15_2;
declare variable MONTH_QUANT type of D_N15_2;
declare variable MONTH_SUM   type of D_N15_2; -- начислено за месяц
declare variable CUST_DEBT   type of D_N15_2; -- баланс абонента
declare variable CUST_MONTH  type of D_N15_2; -- начислено абоненту за месяц
declare variable B_DATE      type of D_DATE;
declare variable E_DATE      type of D_DATE;
declare variable CUSTOMER_ID type of UID;
declare variable min_tarif   type of D_N15_2; -- минимальный тариф на услугу
begin
  -- проверим, установлен ли признак расчета скидки
  MONTH_QUANT = 0;
  select
      coalesce(VAR_VALUE, '0')
    from SETTINGS
    where VAR_NAME = 'PAY_DISCOUNT'
  into :MONTH_QUANT;
  if (MONTH_QUANT <> '1') then
    exit; -- если не установлен выйдем из процедуры

  select
      cast(coalesce(VAR_VALUE, 1) as float)
    from SETTINGS
    where VAR_NAME = 'DISCOUNT_3'
  into :DISCOUNT;

  FOR_MONTH = FOR_MONTH - extract(day from FOR_MONTH) + 1;

  select
      min(t.tarif_sum)
    from tarif t
    where :for_month between t.date_from and t.date_to
  into :min_tarif;

  -- отсеем абонентов у которых не хватает скидки на три месяца
  min_tarif = min_tarif * 3 * DISCOUNT;

  for select
          c.customer_id
        , -1 * C.DEBT_SUM
        ,
          (select
               sum(TARIF_SUM)
             from TARIF T
             where :FOR_MONTH between T.DATE_FROM and T.DATE_TO
                   and exists(select
                                  SS.SERV_ID
                                from SUBSCR_SERV SS
                                where SS.SERV_ID = T.SERVICE_ID
                                      and SS.CUSTOMER_ID = c.CUSTOMER_ID
                                      and SS.STATE_SGN = 1))
        from CUSTOMER C
        where C.debt_sum < :min_tarif
              and not exists(select
                                 d.customer_id
                               from PERSONAL_TARIF d
                               where d.customer_id = c.customer_id
                                     and :FOR_MONTH between d.date_from and d.date_to)
      into :CUSTOMER_ID, :CUST_DEBT, :MONTH_SUM
  do begin
    MONTH_SUM = coalesce(MONTH_SUM, 0);
    if ((CUST_DEBT > (MONTH_SUM * 2)) and (MONTH_SUM > 0)) then begin

      DISCOUNT = 0;
      MONTH_QUANT = 0;

      select
          cast(coalesce(VAR_VALUE, 0) as float)
        from SETTINGS
        where VAR_NAME = 'DISCOUNT_12'
      into :DISCOUNT;

      -- высчитаем кол-во месяцев с учетом скидок
      if (CUST_DEBT >= (12 * MONTH_SUM * DISCOUNT) and (round(DISCOUNT, 4) > 0)) then
        MONTH_QUANT = round(CUST_DEBT / MONTH_SUM * DISCOUNT, 0);
      else begin
        select
            cast(coalesce(VAR_VALUE, 0) as float)
          from SETTINGS
          where VAR_NAME = 'DISCOUNT_6'
        into :DISCOUNT;

        if (CUST_DEBT >= (6 * MONTH_SUM * DISCOUNT) and (round(DISCOUNT, 4) > 0)) then
          MONTH_QUANT = round(CUST_DEBT / MONTH_SUM * DISCOUNT, 0);
        else begin
          select
              cast(coalesce(VAR_VALUE, 0) as float)
            from SETTINGS
            where VAR_NAME = 'DISCOUNT_3'
          into :DISCOUNT;

          if (CUST_DEBT >= (3 * MONTH_SUM * DISCOUNT) and (round(DISCOUNT, 4) > 0)) then
            MONTH_QUANT = round(CUST_DEBT / MONTH_SUM * DISCOUNT, 0);
          else
            DISCOUNT = 0;
        end
      end

      if (DISCOUNT > 0) then begin
        E_DATE = dateadd(-1 day to(dateadd(MONTH_QUANT + 1 month to FOR_MONTH)));
        -- попробуем установить персональный тариф
        insert into PERSONAL_TARIF (SERVICE_ID, CUSTOMER_ID, DATE_FROM, DATE_TO, TARIF_SUM, ADD_METHOD)
        select first 1
            ss.serv_id
          , SS.CUSTOMER_ID
          , :FOR_MONTH
          , :E_DATE
          , round(t.tarif_sum * :DISCOUNT, 2)
          , 1
          from SUBSCR_SERV SS, tarif t
          where SS.CUSTOMER_ID = :CUSTOMER_ID
                and SS.STATE_SGN = 1
                and SS.STATE_DATE <= :FOR_MONTH
                and :FOR_MONTH between t.date_from and t.date_to
                and ss.serv_id = t.service_id;
        execute procedure CLOSE_MONTH_PROC(:FOR_MONTH, :CUSTOMER_ID);
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_DISCOUNT_AFTER_PAY (
    VCUSTOMER_ID TYPE OF UID,
    VPAY_SUM TYPE OF D_N15_2,
    VPAY_DATE TYPE OF D_DATE)
AS
declare variable VMONTH_QUANT    type of D_N15_2;
declare variable VMONTH_QUANT_3  type of D_N15_2;
declare variable VMONTH_QUANT_6  type of D_N15_2;
declare variable VMONTH_QUANT_12 type of D_N15_2;
declare variable VMONTH_SUM      type of D_N15_2;
declare variable PAYED           type of D_N15_2;
declare variable B_DATE          type of D_DATE;
declare variable E_DATE          type of D_DATE;
declare variable DISCOUNT        type of D_N15_4;
declare variable DISCOUNT_3      type of D_N15_4;
declare variable DISCOUNT_6      type of D_N15_4;
declare variable DISCOUNT_12     type of D_N15_4;
declare variable DISC_KOEF       type of D_N15_4;
begin

  select
      cast(coalesce(VAR_VALUE, 0) as integer)
    from SETTINGS
    where VAR_NAME = 'PAY_DISCOUNT'
  into :DISCOUNT;

  if (DISCOUNT = 1) then begin

    DISCOUNT = 1;
    VMONTH_SUM = 0;
    select
        C.DEBT_SUM
      from CUSTOMER C
      where C.CUSTOMER_ID = :vCUSTOMER_ID
    into :VMONTH_SUM;

    -- учтем то что платеж уже списали
    PAYED = -1 * VMONTH_SUM;

    if (PAYED > 0) then begin

      select
          sum(TARIF_SUM)
        from TARIF T
        where exists(select
                         SS.SERV_ID
                       from SUBSCR_SERV SS
                       where SS.SERV_ID = T.SERVICE_ID
                             and SS.CUSTOMER_ID = :vCUSTOMER_ID
                             and SS.STATE_SGN = 1
                             and SS.STATE_DATE <= :vPAY_DATE)
              and :vPAY_DATE between T.DATE_FROM and T.DATE_TO
      into :VMONTH_SUM;

      DISCOUNT = 0;
      DISCOUNT_3 = 0;
      DISCOUNT_6 = 0;
      DISCOUNT_12 = 0;

      VMONTH_QUANT_3 = 0;
      VMONTH_QUANT_6 = 0;
      VMONTH_QUANT_12 = 0;

      -- получим скидки на месяца
      select
          cast(coalesce(VAR_VALUE, 0) as float)
        from SETTINGS
        where VAR_NAME = 'DISCOUNT_3'
      into :DISCOUNT_3;
      select
          cast(coalesce(VAR_VALUE, 0) as float)
        from SETTINGS
        where VAR_NAME = 'DISCOUNT_6'
      into :DISCOUNT_6;
      select
          cast(coalesce(VAR_VALUE, 0) as float)
        from SETTINGS
        where VAR_NAME = 'DISCOUNT_12'
      into :DISCOUNT_12;

      -- высчитаем кол-во месяцев с учетом скидок
      if (payed >= (3 * VMONTH_SUM * DISCOUNT_3)) then begin
        VMONTH_QUANT = round(payed / (VMONTH_SUM * DISCOUNT_3), 0);
        DISCOUNT = DISCOUNT_3;
      end

      if (payed >= (6 * VMONTH_SUM * DISCOUNT_6)) then begin
        VMONTH_QUANT = round(payed / (VMONTH_SUM * DISCOUNT_6), 0);
        DISCOUNT = DISCOUNT_6;
      end

      if (payed >= (12 * VMONTH_SUM * DISCOUNT_12)) then begin
        VMONTH_QUANT = round(payed / (VMONTH_SUM * DISCOUNT_3), 0);
        DISCOUNT = DISCOUNT_12;
      end

      B_DATE = vPAY_DATE - extract(day from vPAY_DATE) + 1;
      E_DATE = dateadd(-1 day to(dateadd(VMONTH_QUANT + 1 month to B_DATE)));

      if (DISCOUNT > 0) then begin
        insert into DISCOUNT_FACTOR (CUSTOMER_ID, DATE_FROM, DATE_TO, FACTOR_VALUE, SERV_ID, NOTICE)
        select
            SS.CUSTOMER_ID
          , :B_DATE
          , :E_DATE
          , :DISCOUNT
          , SS.SERV_ID
          , 'Скидка за оплату ' || :vPAY_SUM
          from SUBSCR_SERV SS
          where SS.CUSTOMER_ID = :vCUSTOMER_ID
                and SS.STATE_SGN = 1
                and SS.STATE_DATE <= :vPAY_DATE;
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_FIXED_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER)
AS
declare variable V_SERVICE_ID D_INTEGER;
declare variable V_E_MONTH    D_DATE;
declare variable V_S_MONTH    D_DATE;
begin
  V_S_MONTH = :P_MONTH - extract(day from :P_MONTH) + 1;
  V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

  insert into MONTHLY_FEE (MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
  select
      SS.SERV_DATE
    , SS.CUSTOMER_ID
    , SS.SERVICE_ID
    , 1
    , SS.UNITS
    from SINGLE_SERV SS
         inner join SERVICES S on (SS.SERVICE_ID = S.SERVICE_ID)
    where S.SRV_TYPE_ID = 2
          and SS.SERV_DATE between :V_S_MONTH and :V_E_MONTH
          and SS.CUSTOMER_ID = :P_CUSTOMER_ID;
end;


CREATE OR ALTER PROCEDURE CALC_KOEF_TARIF (
    P_CUSTOMER_ID UID,
    P_SERV_ID D_INTEGER,
    P_MONTH D_DATE,
    P_IS_J D_INTEGER = 0,
    P_SRVTYPE D_INTEGER = null)
AS
declare variable vKoef  D_DAY_TARIF;
declare variable vTarif D_DAY_TARIF;
declare variable jTarif d_N15_5;
declare variable LD     D_INTEGER;
declare variable I      d_INTEGER;
declare variable T_DAY  d_DATE;
begin
  delete from PERS_TARIF_TMP;
  p_month = p_month - extract(day from p_month) + 1;
  ld = extract(day from dateadd(-1 day to(dateadd(1 month to p_month))));
  i = 0;
  while (i < ld) do begin
    t_day = :p_month + i;
    select
        t.Tarif_Sum
      , t.Tarif_Sum_Jur
      from tarif t
      where t.Service_Id = :P_SERV_ID
            and :t_day between t.date_from and t.date_to
    into :vTarif, :jTarif;
    if (P_IS_J = 1) then
      vTarif = coalesce(jTarif, 0);
    vKoef = null;
    select
        avg(D.FACTOR_VALUE)
      from DISCOUNT_FACTOR D
      where D.CUSTOMER_ID = :P_CUSTOMER_ID
            and :t_day between D.DATE_FROM and D.DATE_TO
            and ((D.SERV_ID = :P_SERV_ID)
              or ((D.SERV_ID = -1)
            and ((D.Srv_Type = -1)
              or (d.Srv_Type = :P_SrvType))))
    into :vKoef;
    vKoef = coalesce(vKoef, 1);
    vTarif = round(vTarif * vKoef / ld, 5);
    insert into PERS_TARIF_TMP
    values (:p_serv_id, :t_day, :vTarif);
    i = i + 1;
  end
end;


CREATE OR ALTER PROCEDURE CALC_MONTH_DAY_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER)
AS
declare variable V_SERVICE_ID  D_INTEGER;
declare variable V_S_MONTH     D_DATE;
declare variable V_E_MONTH     D_DATE;
declare variable V_MONTH_SHIFT D_INTEGER;
declare variable V_UNITS       D_N15_2;
declare variable V_FEE         D_N15_2;
declare variable V_FEE_JUR     D_N15_2;
declare variable PERS_TAR      D_N15_2;
declare variable VAT           D_N15_2;
declare variable V_IS_JUR      D_SMALLINT;
declare variable AUTOOFF       D_SMALLINT;
declare variable V_VATG_ID     D_INTEGER;
declare variable Debt_Sum      D_N15_2;
declare variable SrvType       D_Integer;
declare variable hand_control  D_INTEGER;
declare variable POSITIVE_ONLY D_Iboolean; --declare variable V_FEE_BEFORE  D_N15_2;
begin
  if (P_CALC_TYPE is null) then
    P_CALC_TYPE = 0;

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  for select
          S.SERVICE_ID
        , S.SHIFT_MONTHS
        , coalesce(s.Autooff, 0)
        , s.BUSINESS_TYPE
        ,
          (-1 * c.Debt_Sum + coalesce(c.Prepay, 0))
        , coalesce(c.Hand_Control, 0)
        , coalesce(POSITIVE_ONLY, 0)
        , coalesce(C.JURIDICAL, 0)
        , C.VATG_ID
        , c.Debt_Sum
        from SERVICES S
             inner join Subscr_Serv ss on (ss.Serv_Id = s.Service_Id)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :P_CALC_TYPE
              and ss.Customer_Id = :P_CUSTOMER_ID
      into :V_SERVICE_ID, :V_MONTH_SHIFT, :AUTOOFF, :SrvType, :Debt_Sum, :hand_control, :POSITIVE_ONLY, :V_IS_JUR, :V_VATG_ID, :Debt_Sum
  do begin
    V_UNITS = null;

    -- начало месяца и конец месяца
    V_S_MONTH = dateadd(V_MONTH_SHIFT month to P_MONTH);
    V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

    if (V_S_MONTH <> (current_date - extract(day from current_date) + 1)) then
      AUTOOFF = 0; -- автоотключение только текущим числом
    -- начало месяца

    select
        count(DT.T_DAY)
      , sum(DT.TARIF)
      , sum(DT.TARIF_JUR)
      from SUBSCR_HIST S
           inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
      where S.SERV_ID = :V_SERVICE_ID
            and DT.T_DAY >= :V_S_MONTH
            and DT.T_DAY <= :V_E_MONTH
            and DT.T_DAY between S.DATE_FROM and S.DATE_TO
            and S.CUSTOMER_ID = :P_CUSTOMER_ID
    into :V_UNITS, :V_FEE, :V_FEE_JUR;

    -- проверим есть ли персональный тариф
    if (V_UNITS > 0) then begin
      if (V_IS_JUR = 1) then
        V_FEE = V_FEE_JUR; -- юр. по другому тарифу

      -- проверим есть ли персональный тариф
      PERS_TAR = iif(exists(select
                                P.TARIF_SUM
                              from PERSONAL_TARIF P
                              where P.SERVICE_ID = :V_SERVICE_ID
                                    and P.CUSTOMER_ID = :P_CUSTOMER_ID
                                    and ((:V_S_MONTH between P.DATE_FROM and P.DATE_TO)
                                      or (:V_E_MONTH between P.DATE_FROM and P.DATE_TO))), 1, 0);
      if (PERS_TAR = 1) then begin
        execute procedure Calc_Pers_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR);
        select
            sum(DT.TARIF)
          from SUBSCR_HIST S
               inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
          where S.SERV_ID = :V_SERVICE_ID
                and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                and S.CUSTOMER_ID = :P_CUSTOMER_ID
                and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
        into :V_FEE;
      end
      else begin
        if (exists(select
                       D.Discount_Id
                     from DISCOUNT_FACTOR D
                     where D.CUSTOMER_ID = :P_CUSTOMER_ID
                           and ((:V_S_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (:V_E_MONTH between D.DATE_FROM and D.DATE_TO)
                             or (D.DATE_FROM between :V_S_MONTH and :V_E_MONTH)
                             or (D.DATE_TO between :V_S_MONTH and :V_E_MONTH))
                           and ((D.SERV_ID = :V_SERVICE_ID)
                             or ((D.SERV_ID = -1)
                           and ((D.Srv_Type = -1)
                             or (d.Srv_Type = :SrvType)))))) then begin
          execute procedure Calc_Koef_Tarif(:P_CUSTOMER_ID, :V_SERVICE_ID, :V_S_MONTH, :V_IS_JUR, :SrvType);
          select
              sum(DT.TARIF)
            from SUBSCR_HIST S
                 inner join Pers_Tarif_Tmp DT on (DT.SERV_ID = S.SERV_ID)
            where S.SERV_ID = :V_SERVICE_ID
                  and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                  and S.CUSTOMER_ID = :P_CUSTOMER_ID
                  and DT.T_DAY between :V_S_MONTH and :V_E_MONTH
          into :V_FEE;
        end
      end

      -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
      if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
        VAT = 0;
        select first 1
            T.TARIF_SUM
          from OBJECTS O
               inner join TARIF T on (O.O_ID = T.SERVICE_ID)
          where T.SERVICE_ID = :V_VATG_ID
                and O.O_TYPE = 13
                and :P_MONTH between T.DATE_FROM and T.DATE_TO
        into :VAT;
        VAT = coalesce(VAT, 0);
        V_FEE = V_FEE + V_FEE * VAT / 100;
      end
      V_FEE = round(V_FEE, FEE_ROUND);
      /* проверим автоблкировка услуги включена и разрешена ли автоблокировка пользователя */
      if ((AUTOOFF = 0)
          or
          (hand_control = 1)) then
        Debt_Sum = V_FEE + 1; -- если не отключать, то баланс должен быть больше начислений
      /* else begin
          -- Если нужно блокировать то посмотрим сколько за услугу уже начисленно
          -- в этом месяце и учтем это при блокировке
          if (POSITIVE_ONLY = 1) then begin
            select
                sum(FEE)
              from MONTHLY_FEE
              where MONTH_ID = :V_S_MONTH
                    and CUSTOMER_ID = :P_CUSTOMER_ID
                    and SERVICE_ID = :V_SERVICE_ID
            into :V_FEE_BEFORE;
            if (V_FEE_BEFORE is not null) then
              Debt_Sum = Debt_Sum + V_FEE_BEFORE;
          end
        end
        */

      if (((Debt_Sum >= V_FEE) and (POSITIVE_ONLY = 1)) -- не допускаем минус у абонента
          or
          ((Debt_Sum >= 0) and (POSITIVE_ONLY = 0))) -- Если баланс >= 0 не отключаем
      then
        update or insert into MONTHLY_FEE (MONTH_ID, SERVICE_ID, CUSTOMER_ID, UNITS, FEE)
        values (:P_MONTH, :V_SERVICE_ID, :P_CUSTOMER_ID, :V_UNITS, :V_FEE)
        matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
      else begin
        -- отключим если нет денег
        select
            count(*)
          from subscr_hist sh
          where sh.Customer_Id = :P_Customer_Id
                and sh.Serv_Id = :V_SERVICE_ID
                and current_date between sh.Date_From and sh.Date_To
        into :AUTOOFF;
        if (AUTOOFF > 0) then
          execute procedure Auto_Off_Service(:P_Customer_Id, :V_SERVICE_ID, current_date, null, null);
      end

    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_MONTH_FIX_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER = null)
AS
declare variable V_SERVICE_ID  type of UID;
declare variable V_S_MONTH     D_DATE;
declare variable V_E_MONTH     D_DATE;
declare variable V_MONTH_SHIFT D_INTEGER;
declare variable V_UNITS       D_N15_2;
declare variable V_FEE         D_N15_2;
declare variable V_DISCOUNT    D_N15_4;
declare variable V_TARIF       D_N15_2;
declare variable V_TARIF_JUR   D_N15_2;
declare variable PERS_TAR      D_N15_2;
declare variable VAT           D_N15_2;
declare variable V_IS_JUR      D_SMALLINT;
declare variable V_CUR_MONTH   D_DATE;
declare variable AUTOOFF       D_SMALLINT;
declare variable Debt_Sum      D_N15_2;
declare variable hand_control  D_INTEGER;
declare variable POSITIVE_ONLY D_Iboolean;
declare variable SrvType       D_Integer;
declare variable V_EXTRA       D_INTEGER;
declare variable DAYS_IN_MON   D_INTEGER;
declare variable V_VATG_ID     D_INTEGER;
begin
  if (P_CALC_TYPE is null) then
    P_CALC_TYPE = 3;

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  V_CUR_MONTH = current_date - extract(day from current_date) + 1;

  for select
          S.SERVICE_ID
        , S.SHIFT_MONTHS
        , coalesce(s.Autooff, 0) Autooff
        , s.BUSINESS_TYPE
        , coalesce(s.POSITIVE_ONLY, 0) POSITIVE_ONLY
        ,
          (-1 * c.Debt_Sum + coalesce(c.Prepay, 0))
        , C.VATG_ID
        , coalesce(C.JURIDICAL, 0)
        , coalesce(c.Hand_Control, 0)
        from SERVICES S
             inner join Subscr_Serv ss on (s.Service_Id = ss.Serv_Id)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :P_CALC_TYPE
              and c.Customer_Id = :P_CUSTOMER_ID
      into :V_SERVICE_ID, :V_MONTH_SHIFT, :AUTOOFF, :SrvType, :POSITIVE_ONLY, :Debt_Sum, :V_VATG_ID, :V_IS_JUR, :hand_control
  do begin

    if (P_MONTH <> V_CUR_MONTH) then
      AUTOOFF = 0; -- автоотключение только текущим числом

    select
        count(*)
      from subscr_hist sh
      where sh.Customer_Id = :P_CUSTOMER_ID
            and sh.Serv_Id = :V_SERVICE_ID
            and sh.Date_From < :P_MONTH
    into :V_EXTRA;

    if (V_EXTRA > 0) then begin
      -- Считаем по полной если месяц подключения не первый
      V_TARIF = null;
      V_UNITS = null;
      V_DISCOUNT = null;
      -- начало месяца и конец месяца
      V_S_MONTH = dateadd(V_MONTH_SHIFT month to P_MONTH);
      V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

      select
          count(SH.CUSTOMER_ID)
        from SUBSCR_HIST SH
        where SH.SERV_ID = :V_SERVICE_ID
              and SH.CUSTOMER_ID = :P_CUSTOMER_ID
              and ((SH.DATE_FROM <= :V_E_MONTH)
              and (SH.DATE_TO >= :V_S_MONTH))
      into :V_UNITS;
      /*
      так как либо полная абонплата либо 0, то
      нет смысла проверять персональный тариф по дням или коэф по дням
      берем только на первое число.
      */
      if (V_UNITS > 0) then begin
        -- проверим есть ли персональный тариф
        select first 1
            P.TARIF_SUM
          from PERSONAL_TARIF P
          where P.SERVICE_ID = :V_SERVICE_ID
                and P.CUSTOMER_ID = :P_CUSTOMER_ID
                and ((:V_S_MONTH between P.DATE_FROM and P.DATE_TO)
                  or (:V_E_MONTH between P.DATE_FROM and P.DATE_TO))
        into :V_TARIF;

        if (V_TARIF is null) then begin
          -- физ лица по одному тарифу
          select first 1
              T.TARIF_SUM
            , T.TARIF_SUM_JUR
            from TARIF T
            where T.SERVICE_ID = :V_SERVICE_ID
                  and :V_S_MONTH between T.DATE_FROM and T.DATE_TO
          into :V_TARIF, :V_TARIF_JUR;
          if (V_IS_JUR = 1) then
            V_TARIF = coalesce(V_TARIF_JUR, 0);
        end

        select
            avg(D.FACTOR_VALUE)
          from DISCOUNT_FACTOR D
          where D.CUSTOMER_ID = :P_CUSTOMER_ID
                and :V_S_MONTH between D.DATE_FROM and D.DATE_TO
                and ((D.SERV_ID = :V_SERVICE_ID)
                  or ((D.SERV_ID = -1)
                and ((D.Srv_Type = -1)
                  or (d.Srv_Type = :SrvType))))
        into :V_DISCOUNT;

        V_DISCOUNT = coalesce(V_DISCOUNT, 1);
        V_TARIF = coalesce(V_TARIF, 0);

        for select
                sum((datediff(day from iif(SH.DATE_FROM < :V_E_MONTH, iif(SH.DATE_FROM > :V_E_MONTH, :V_E_MONTH, iif(:V_S_MONTH > SH.DATE_FROM, :V_S_MONTH, SH.DATE_FROM)), :V_E_MONTH) to iif(SH.DATE_TO > :V_S_MONTH, iif(SH.DATE_TO < :V_E_MONTH, SH.DATE_TO, :V_E_MONTH), :V_S_MONTH)) + 1)) as DAYS
              from SUBSCR_HIST SH
              where (SH.DATE_FROM <= :V_E_MONTH)
                    and (SH.DATE_TO >= :V_S_MONTH)
                    and SH.SERV_ID = :V_SERVICE_ID
                    and SH.CUSTOMER_ID = :P_CUSTOMER_ID
            into :V_UNITS
        do begin
          if (V_UNITS >= 1) then begin
            V_FEE = V_TARIF * V_DISCOUNT;
            -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
            if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
              VAT = 0;
              select first 1
                  T.TARIF_SUM
                from OBJECTS O
                     inner join TARIF T on (O.O_ID = T.SERVICE_ID)
                where T.SERVICE_ID = :V_SERVICE_ID
                      and O.O_TYPE = 13
                      and :P_MONTH between T.DATE_FROM and T.DATE_TO
              into :VAT;
              VAT = coalesce(VAT, 0);
              V_FEE = V_FEE + V_FEE * VAT / 100;
            end
            V_FEE = round(V_FEE, FEE_ROUND);

            /* проверим автоблкировка услуги включена и разрешена ли автоблокировка пользователя */
            if ((AUTOOFF = 0)
                or
                (hand_control = 1)) then
              Debt_Sum = V_FEE + 1; -- если не отключать, то баланс должен быть больше начислений
            /*
            else begin
              -- Если нужно блокировать то посмотрим сколько за услугу уже начисленно в этом месяце и учтем это при блокировке
              if (POSITIVE_ONLY = 1) then begin

                зачем смотреть сколько начисленно за месяц, если мы v_fee имеем начисления за месяц
                select
                    sum(FEE)
                  from MONTHLY_FEE
                  where MONTH_ID = :V_S_MONTH
                        and CUSTOMER_ID = :P_CUSTOMER_ID
                        and SERVICE_ID = :V_SERVICE_ID
                into :V_FEE_BEFORE;
                if (V_FEE_BEFORE is not null) then
                  Debt_Sum = Debt_Sum + V_FEE_BEFORE;

              end
            end
            */

            if (current_date <> P_MONTH) then begin
              -- Если не первое число, то не отключаем услугу и начисляем ее
              POSITIVE_ONLY = 0;
            end

            if (((Debt_Sum >= V_FEE) and (POSITIVE_ONLY = 1)) -- не допускаем минус у абонента
                or
                ((Debt_Sum >= 0) and (POSITIVE_ONLY = 0))) -- Если баланс >= 0 не отключаем
            then
              update or insert into MONTHLY_FEE (MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
              values (:P_MONTH, :P_CUSTOMER_ID, :V_SERVICE_ID, :V_UNITS, :V_FEE)
              matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
            else begin
              -- отключим если нет денег
              select
                  count(*)
                from subscr_hist sh
                where sh.Customer_Id = :P_Customer_Id
                      and sh.Serv_Id = :V_SERVICE_ID
                      and ((:V_S_MONTH between sh.Date_From and sh.Date_To)
                        or (:V_E_MONTH between sh.Date_From and sh.Date_To))
              into :AUTOOFF;
              if (AUTOOFF > 0) then
                execute procedure Auto_Off_Service(:P_Customer_Id, :V_SERVICE_ID, :P_MONTH, null, null);
            end
          end
        end
      end
    end
    else begin
      -- Считаем пропрорционально дням если месяц подключения первый
      V_UNITS = null;

      -- начало месяца и конец месяца
      V_S_MONTH = dateadd(V_MONTH_SHIFT month to P_MONTH);
      V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));
      DAYS_IN_MON = extract(day from V_E_MONTH);

      select
          count(DT.T_DAY)
        , sum(DT.TARIF)
        from SUBSCR_HIST S
             inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
        where S.SERV_ID = :V_SERVICE_ID
              and DT.T_DAY >= :V_S_MONTH
              and DT.T_DAY <= :V_E_MONTH
              and DT.T_DAY between S.DATE_FROM and S.DATE_TO
              and S.CUSTOMER_ID = :P_CUSTOMER_ID
      into :V_UNITS, :V_FEE;

      -- проверим есть ли персональный тариф
      if (V_UNITS > 0) then begin
        PERS_TAR = null;
        select first 1
            P.TARIF_SUM
          from PERSONAL_TARIF P
          where P.SERVICE_ID = :V_SERVICE_ID
                and P.CUSTOMER_ID = :P_CUSTOMER_ID
                and :V_S_MONTH between P.DATE_FROM and P.DATE_TO
        into :PERS_TAR;

        if (V_IS_JUR = 1) then begin
          V_UNITS = 0;
          V_FEE = 0;
          -- юр. по другому тарифу
          select
              count(DT.T_DAY)
            , sum(DT.TARIF_JUR)
            from SUBSCR_HIST S
                 inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
            where S.SERV_ID = :V_SERVICE_ID
                  and DT.T_DAY >= :V_S_MONTH
                  and DT.T_DAY <= :V_E_MONTH

                  and DT.T_DAY between S.DATE_FROM and S.DATE_TO
                  and S.CUSTOMER_ID = :P_CUSTOMER_ID
          into :V_UNITS, :V_FEE;
        end

        if (V_UNITS <> 0) then begin
          V_DISCOUNT = null;
          select first 1
              D.FACTOR_VALUE
            from DISCOUNT_FACTOR D
            where D.CUSTOMER_ID = :P_CUSTOMER_ID
                  and :V_S_MONTH between D.DATE_FROM and D.DATE_TO
                  and ((D.SERV_ID = :V_SERVICE_ID)
                    or ((D.SERV_ID = -1)
                  and ((D.Srv_Type = -1)
                    or (d.Srv_Type = :SrvType))))
            order by D.SERV_ID desc
          into :V_DISCOUNT;
          if (V_DISCOUNT is null) then
            V_DISCOUNT = 1;
          -- если есть персональный тариф, посчитаем его
          if (not PERS_TAR is null) then
            V_FEE = V_UNITS * PERS_TAR / DAYS_IN_MON;

          V_FEE = round(V_FEE * V_DISCOUNT, FEE_ROUND);
          -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
          if (V_FEE >= 0) then begin
            if (V_IS_JUR <> 0) then begin
              select first 1
                  T.TARIF_SUM
                from OBJECTS O
                     inner join TARIF T on (O.O_ID = T.SERVICE_ID)
                where T.SERVICE_ID = :V_VATG_ID
                      and O.O_TYPE = 13
                      and :P_MONTH between T.DATE_FROM and T.DATE_TO
              into :VAT;
              if (not VAT is null) then
                V_FEE = round(V_FEE + V_FEE * VAT / 100, FEE_ROUND);
            end
          end
          update or insert into MONTHLY_FEE (MONTH_ID, SERVICE_ID, CUSTOMER_ID, UNITS, FEE)
          values (:P_MONTH, :V_SERVICE_ID, :P_CUSTOMER_ID, :V_UNITS, :V_FEE)
          matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
        end
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CALC_MONTH_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER,
    P_CALC_TYPE D_INTEGER = null)
AS
declare variable V_SERVICE_ID  type of UID;
declare variable V_S_MONTH     D_DATE;
declare variable V_E_MONTH     D_DATE;
declare variable V_MONTH_SHIFT D_INTEGER;
declare variable V_UNITS       D_N15_2;
declare variable V_FEE         D_N15_2;
declare variable V_DISCOUNT    D_N15_4;
declare variable V_EXTRA       D_INTEGER;
declare variable V_TARIF       D_N15_2;
declare variable V_TARIF_JUR   D_N15_2;
declare variable VAT           D_N15_2;
declare variable V_IS_JUR      D_SMALLINT;
declare variable V_CUR_MONTH   D_DATE;
declare variable AUTOOFF       D_SMALLINT;
declare variable Debt_Sum      D_N15_2;
declare variable hand_control  D_INTEGER;
declare variable POSITIVE_ONLY D_Iboolean;
declare variable V_FEE_BEFORE  D_N15_2;
declare variable SrvType       D_Integer;
begin
  if (P_CALC_TYPE is null) then
    P_CALC_TYPE = 1;

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  V_CUR_MONTH = current_date - extract(day from current_date) + 1;

  for select
          S.SERVICE_ID
        , S.SHIFT_MONTHS
        , S.EXTRA
        , coalesce(s.Autooff, 0) Autooff
        , s.BUSINESS_TYPE
        , coalesce(s.POSITIVE_ONLY, 0) POSITIVE_ONLY
        ,
          (-1 * c.Debt_Sum + coalesce(c.Prepay, 0))
        , coalesce(C.JURIDICAL, 0)
        , coalesce(c.Hand_Control, 0)
        from SERVICES S
             inner join Subscr_Serv ss on (s.Service_Id = ss.Serv_Id)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 0
              and S.EXTRA > 0
              and S.CALC_TYPE = :P_CALC_TYPE
              and c.Customer_Id = :P_CUSTOMER_ID
      into :V_SERVICE_ID, :V_MONTH_SHIFT, :V_EXTRA, :AUTOOFF, :SrvType, :POSITIVE_ONLY, :Debt_Sum, :V_IS_JUR, :hand_control
  do begin

    if (P_MONTH <> V_CUR_MONTH) then
      AUTOOFF = 0; -- автоотключение только текущим числом

    V_TARIF = null;
    V_UNITS = null;
    V_DISCOUNT = null;
    -- начало месяца и конец месяца
    V_S_MONTH = dateadd(V_MONTH_SHIFT month to P_MONTH);
    V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

    select
        count(SH.CUSTOMER_ID)
      from SUBSCR_HIST SH
      where SH.SERV_ID = :V_SERVICE_ID
            and SH.CUSTOMER_ID = :P_CUSTOMER_ID
            and ((SH.DATE_FROM <= :V_E_MONTH)
            and (SH.DATE_TO >= :V_S_MONTH))
    into :V_UNITS;
    /*
    так как либо полная абонплата либо 0, то
    нет смысла проверять персональный тариф по дням или коэф по дням
    берем только на первое число.
    */
    if (V_UNITS > 0) then begin
      -- проверим есть ли персональный тариф
      select first 1
          P.TARIF_SUM
        from PERSONAL_TARIF P
        where P.SERVICE_ID = :V_SERVICE_ID
              and P.CUSTOMER_ID = :P_CUSTOMER_ID
              and ((:V_S_MONTH between P.DATE_FROM and P.DATE_TO)
                or (:V_E_MONTH between P.DATE_FROM and P.DATE_TO))
      into :V_TARIF;

      if (V_TARIF is null) then begin
        select first 1
            T.TARIF_SUM
          , T.TARIF_SUM_JUR
          from TARIF T
          where T.SERVICE_ID = :V_SERVICE_ID
                and :V_S_MONTH between T.DATE_FROM and T.DATE_TO
        into :V_TARIF, :V_TARIF_JUR;

        -- юр. по другому тарифу
        if (V_IS_JUR = 1) then
          V_TARIF = coalesce(V_TARIF_JUR, 0);
      end

      select
          avg(D.FACTOR_VALUE)
        from DISCOUNT_FACTOR D
        where D.CUSTOMER_ID = :P_CUSTOMER_ID
              and :V_S_MONTH between D.DATE_FROM and D.DATE_TO
              and ((D.SERV_ID = :V_SERVICE_ID)
                or ((D.SERV_ID = -1)
              and ((D.Srv_Type = -1)
                or (d.Srv_Type = :SrvType))))
      into :V_DISCOUNT;

      V_DISCOUNT = coalesce(V_DISCOUNT, 1);
      V_TARIF = coalesce(V_TARIF, 0);

      for select
              sum((datediff(day from iif(SH.DATE_FROM < :V_E_MONTH, iif(SH.DATE_FROM > :V_E_MONTH, :V_E_MONTH, iif(:V_S_MONTH > SH.DATE_FROM, :V_S_MONTH, SH.DATE_FROM)), :V_E_MONTH) to iif(SH.DATE_TO > :V_S_MONTH, iif(SH.DATE_TO < :V_E_MONTH, SH.DATE_TO, :V_E_MONTH), :V_S_MONTH)) + 1)) as DAYS
            from SUBSCR_HIST SH
            where (SH.DATE_FROM <= :V_E_MONTH)
                  and (SH.DATE_TO >= :V_S_MONTH)
                  and SH.SERV_ID = :V_SERVICE_ID
                  and SH.CUSTOMER_ID = :P_CUSTOMER_ID
          into :V_UNITS
      do begin
        if (V_UNITS >= V_EXTRA) then begin
          V_FEE = V_TARIF * V_DISCOUNT;
          -- если ессть начисления, проверим юрик это или нет и если юрик посчитаем НДС
          if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
            VAT = 0;
            select first 1
                T.TARIF_SUM
              from OBJECTS O
                   inner join TARIF T on (O.O_ID = T.SERVICE_ID)
              where T.SERVICE_ID = :V_SERVICE_ID
                    and O.O_TYPE = 13
                    and :P_MONTH between T.DATE_FROM and T.DATE_TO
            into :VAT;
            VAT = coalesce(VAT, 0);
            V_FEE = V_FEE + V_FEE * VAT / 100;
          end
          V_FEE = round(V_FEE, FEE_ROUND);

          /* проверим автоблкировка услуги включена и разрешена ли автоблокировка пользователя */
          if ((AUTOOFF = 0)
              or
              (hand_control = 1)) then
            Debt_Sum = V_FEE + 1; -- если не отключать, то баланс должен быть больше начислений
          else begin
            /* Если нужно блокировать то посмотрим сколько за услугу уже начисленно в этом месяце и учтем это при блокировке */
            if (POSITIVE_ONLY = 1) then begin
              select
                  sum(FEE)
                from MONTHLY_FEE
                where MONTH_ID = :V_S_MONTH
                      and CUSTOMER_ID = :P_CUSTOMER_ID
                      and SERVICE_ID = :V_SERVICE_ID
              into :V_FEE_BEFORE;
              if (V_FEE_BEFORE is not null) then
                Debt_Sum = Debt_Sum + V_FEE_BEFORE;
            end
          end

          if (((Debt_Sum >= V_FEE) and (POSITIVE_ONLY = 1)) -- не допускаем минус у абонента
              or
              ((Debt_Sum >= 0) and (POSITIVE_ONLY = 0))) -- Если баланс >= 0 не отключаем
          then
            update or insert into MONTHLY_FEE (MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
            values (:P_MONTH, :P_CUSTOMER_ID, :V_SERVICE_ID, :V_UNITS, :V_FEE)
            matching (MONTH_ID, CUSTOMER_ID, SERVICE_ID);
          else begin
            -- отключим если нет денег
            select
                count(*)
              from subscr_hist sh
              where sh.Customer_Id = :P_Customer_Id
                    and sh.Serv_Id = :V_SERVICE_ID
                    and :P_MONTH between sh.Date_From and sh.Date_To
            into :AUTOOFF;
            if (AUTOOFF > 0) then
              execute procedure Auto_Off_Service(:P_Customer_Id, :V_SERVICE_ID, :P_MONTH, null, null);
          end
        end
      end
    end

  end

end;


CREATE OR ALTER PROCEDURE CALC_PERS_TARIF (
    P_CUSTOMER_ID UID,
    P_SERV_ID D_INTEGER,
    P_MONTH D_DATE,
    P_IS_J D_INTEGER = 0)
AS
declare variable VTARIF d_N15_5;
declare variable jtarif d_N15_5;
declare variable LD     D_INTEGER;
declare variable I      d_INTEGER;
declare variable T_DAY  d_DATE;
begin
  delete from PERS_TARIF_TMP;

  p_month = p_month - extract(day from p_month) + 1;
  ld = extract(day from dateadd(-1 day to(dateadd(1 month to p_month))));
  i = 0;
  while (i < ld) do begin
    t_day = :p_month + i;
    vtarif = null;
    select first 1
        t.Tarif_Sum
      from Personal_Tarif t
      where t.Service_Id = :P_SERV_ID and t.Customer_Id = :P_CUSTOMER_ID
            and :t_day between t.date_from and t.date_to
    into :vtarif;

    if (vtarif is null) then begin
      select
          t.Tarif_Sum
        , t.Tarif_Sum_Jur
        from tarif t
        where t.Service_Id = :P_SERV_ID
              and :t_day between t.date_from and t.date_to
      into :vtarif, :jtarif;
      if (P_IS_J = 1) then
        vtarif = jtarif;
    end

    if (vtarif is not null) then
      vtarif = round(vtarif / ld, 5);
    else
      vtarif = 0;

    insert into PERS_TARIF_TMP
    values (:p_serv_id, :t_day, :vtarif);

    i = i + 1;
  end
end;


CREATE OR ALTER PROCEDURE CALC_SINGLE_SRV_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_MONTH D_DATE,
    FEE_ROUND D_INTEGER)
AS
declare variable V_SERVICE_ID D_INTEGER;
declare variable V_S_MONTH    D_DATE;
declare variable V_E_MONTH    D_DATE;
declare variable V_DATE       D_DATE;
declare variable V_DISCOUNT   D_N15_4;
declare variable V_UNITS      D_N15_2;
declare variable V_FEE        D_N15_2;
declare variable V_FEE_JUR    D_N15_2;
declare variable VAT          D_N15_2;
declare variable V_IS_JUR     D_SMALLINT;
declare variable V_VATG_ID    D_INTEGER;
declare variable SrvType      D_Integer;
begin
  /*---------------------------------------------------------------------------------*/
  /*                     расчитываем разовые услуги                                  */
  /*---------------------------------------------------------------------------------*/

  if (FEE_ROUND is null) then begin
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :FEE_ROUND;
  end

  -- начало месяца и конец месяца
  V_S_MONTH = :P_MONTH - extract(day from :P_MONTH) + 1;
  V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

  for select
          S.SERVICE_ID
        , SS.SERV_DATE
        , SS.UNITS
        , T.TARIF_SUM
        , T.TARIF_SUM_JUR
        , s.BUSINESS_TYPE
        , coalesce(C.JURIDICAL, 0)
        , C.VATG_ID
        from TARIF T
             inner join SERVICES S on (T.SERVICE_ID = S.SERVICE_ID)
             inner join SINGLE_SERV SS on (S.SERVICE_ID = SS.SERVICE_ID)
             inner join customer c on (c.Customer_Id = ss.Customer_Id)
        where S.SRV_TYPE_ID = 1
              and SS.SERV_DATE between T.DATE_FROM and T.DATE_TO
              and T.TARIF_SUM <> 0
              and SS.SERV_DATE between :V_S_MONTH and :V_E_MONTH
              and SS.CUSTOMER_ID = :P_CUSTOMER_ID
      into :V_SERVICE_ID, :V_DATE, :V_UNITS, :V_FEE, :V_FEE_JUR, :SrvType, :V_IS_JUR, :V_VATG_ID
  do begin
    V_DISCOUNT = null;
    select first 1
        D.FACTOR_VALUE
      from DISCOUNT_FACTOR D
      where D.CUSTOMER_ID = :P_CUSTOMER_ID
            and :V_DATE between D.DATE_FROM and D.DATE_TO
            and ((D.SERV_ID = :V_SERVICE_ID)
              or ((D.SERV_ID = -1)
            and ((D.Srv_Type = -1)
              or (d.Srv_Type = :SrvType))))
      order by D.SERV_ID desc
    into :V_DISCOUNT;
    V_DISCOUNT = coalesce(V_DISCOUNT, 1);

    if (V_IS_JUR <> 0) then
      V_FEE = V_FEE_JUR;

    V_FEE = V_FEE * V_UNITS * V_DISCOUNT;
    if (V_FEE <> 0) then begin
      if ((V_FEE >= 0) and (V_IS_JUR <> 0)) then begin
        VAT = 0;
        select first 1
            T.TARIF_SUM
          from OBJECTS O
               inner join TARIF T on (O.O_ID = T.SERVICE_ID)
          where T.SERVICE_ID = :V_VATG_ID
                and O.O_TYPE = 13
                and :P_MONTH between T.DATE_FROM and T.DATE_TO
        into :VAT;
        VAT = coalesce(VAT, 0);
        V_FEE = V_FEE + V_FEE * VAT / 100;
      end
      V_FEE = round(V_FEE, FEE_ROUND);
      insert into MONTHLY_FEE (MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
      values (:V_DATE, :P_CUSTOMER_ID, :V_SERVICE_ID, :V_UNITS, :V_FEE);
    end
  end
end;


CREATE OR ALTER PROCEDURE CALCULATE_FINE (
    CUSTOMER_ID TYPE OF UID,
    DATE_PAYMENT D_DATE = null,
    FINE_PERCENT D_N15_2 = null,
    FINE_MONTH D_INTEGER = null,
    FINE_DAY D_INTEGER = null)
RETURNS (
    SERVICE_ID TYPE OF UID,
    DOLG_SUM D_N15_2,
    DOLG_DATE D_DATE,
    FINE_SUM D_N15_2,
    FINE_DAYS D_INTEGER)
AS
declare variable vDATE_FROM  d_date;
declare variable vDATE       d_date;
declare variable vDATE_TMP   d_date;
declare variable vDATE_FINE  d_date;
declare variable vSUM        D_N15_2;
declare variable V_FEE_ROUND d_INTEGER;
declare variable vTypeSRV    d_integer;
declare variable vPAYED      D_N15_2;
declare variable vNUMBER_TMP D_N15_2;
begin
  if (DATE_PAYMENT is null) then
    DATE_PAYMENT = current_date;

  select
      c.Debt_Sum
    from customer c
    where c.customer_id = :customer_id
  into :vSUM;
  -- если переплата, то какая пеня?
  if (vSUM >= 0) then begin
    /* получим значение число знаков после запятой для округления*/
    select
        cast(VAR_VALUE as integer)
      from SETTINGS
      where VAR_NAME = 'FEE_ROUND'
    into :V_FEE_ROUND;

    if (fine_day is null) then
      select
          s.var_value
        from settings s
        where s.var_name = 'FINE_DAYS'
      into :fine_day;

    if (fine_month is null) then
      select
          s.var_value
        from settings s
        where s.var_name = 'FINE_MONTH'
      into :fine_month;

    if (fine_percent is null) then
      select
          cast(s.var_value as float)
        from settings s
        where s.var_name = 'FINE_PERCENT'
      into :fine_percent;

    if (FINE_PERCENT is null) then
      FINE_PERCENT = 0;

    if (fine_day is null) then
      fine_day = 0;
    else
      fine_day = fine_day - 1;

    if (fine_month is null) then
      fine_month = 1;

    select
        Debt_Date
      from Get_Debt_Start_Date_CID(:CUSTOMER_ID)
    into :vDATE_FROM;

    if (not vDATE_FROM is null) then begin

      -- посчитаем все начисления абонента до
      vDATE_FROM = (vDATE_FROM - extract(day from vDATE_FROM) + 1);

      select
          sum(Fee)
        from Monthly_Fee f
             inner join services s on (f.Service_Id = s.Service_Id)
        where f.customer_id = :customer_id
              and f.Month_Id < :vDATE_FROM -- dateadd(month, coalesce(s.Shift_Months, 0), f.Month_Id) < :vDATE_FROM
      into :vSUM;
      select
          sum(coalesce(fee, 0))
        from Other_Fee
        where Customer_Id = :customer_id
              and Fee_Date < :vDATE_FROM
      into :vPAYED;
      vSUM = coalesce(vSUM, 0) + coalesce(vPAYED, 0);

      -- посчитаем все платежи абонента до
      select
          coalesce(sum(p.Pay_Sum), 0)
        from payment p
        where p.customer_id = :customer_id
      into :vPAYED;
      -- выясним. была ли переплата
      vPAYED = coalesce(vPAYED, 0) - vSUM;
      if (vPAYED < 0) then
        vPAYED = 0;

      for select
              service_id
            , month_id
            , fee
            , Srv_Type_Id
            from (select
                      m.service_id
                    , dateadd(month, coalesce(s.Shift_Months, 0), m.Month_Id) month_id
                    , m.fee
                    , s.Srv_Type_Id
                    , s.SHIFT_MONTHS
                    from monthly_fee m
                         inner join Services s on (m.Service_Id = s.Service_Id)
                    where m.Month_Id >= :vDATE_FROM
                          and m.customer_id = :customer_id
                  union
                  select
                      -1
                    , Fee_Date
                    , Fee
                    , -1
                    , 0
                    from Other_Fee
                    where Customer_Id = :customer_id
                          and Fee_Date >= :vDATE_FROM
                          and coalesce(fee, 0) <> 0)
            order by coalesce(SHIFT_MONTHS, 0), month_id
          into :SERVICE_ID, :DOLG_DATE, :DOLG_SUM, :vTypeSRV
      do begin
        fine_sum = 0;
        FINE_DAYS = 0;
        vDATE = DOLG_DATE;

        if (DOLG_SUM > 0) then begin
          -- проверим есть ли остаток и если есть учтем его
          -- отнимем переплату
          if (vPAYED > 0) then begin
            if (DOLG_SUM > vPAYED) then begin
              DOLG_SUM = DOLG_SUM - vPAYED;
              vPAYED = 0;
            end
            else begin
              vPAYED = vPAYED - DOLG_SUM;
              DOLG_SUM = 0;
            end
          end
          vSUM = DOLG_SUM;

          vDATE_TMP = dateadd(fine_month month to vDATE);
          vDATE_TMP = vDATE_TMP - extract(day from vDATE_TMP) + 1;
          vDATE_FINE = dateadd(fine_day day to vDATE_TMP);

          fine_days = datediff(day from vDATE_FINE to date_payment);
          if (fine_days < 0) then
            fine_days = 0;
          -- если это не периодическая услуг. берем сумму полностью
          if (vTypeSRV <> 0) then begin
            fine_sum = fine_days * fine_percent * vSUM / 100;
          end
          else begin
            -- если периодическая, вычислим за какой месяц начисление
            vDATE_TMP = cast((extract(year from DATE_PAYMENT) || '-' || extract(month from DATE_PAYMENT) || '-1') as date);
            if (vDATE_TMP = vDATE) then begin
              -- если месяц платежа и месяц начислений одинаковы.
              -- то высчитаем реальное кол-во дней начислений
              --vSUM = DOLG_SUM;
              --vPAYED = vPREVPAY;
              vDATE_TMP = dateadd(-1 day to(dateadd(1 month to vDATE_TMP)));
              vSUM = vSUM / extract(day from vDATE_TMP) * (fine_days);
              fine_sum = fine_days * fine_percent * vSUM / 100;
            end
            else begin -- иначе это целый месяц
              -- если был оплачен не полностью месяц
              -- то высчитаем кол-во оплачены дней и уменьшим
              vDATE_TMP = dateadd(-1 day to(dateadd(1 month to DOLG_DATE)));
              -- кол-во дней в месяце
              vNUMBER_TMP = extract(day from vDATE_TMP);
              -- сколько дней было оплачено
              if (DOLG_SUM <> 0) then
                vNUMBER_TMP = (vNUMBER_TMP - round(vSUM * Vnumber_Tmp / DOLG_SUM, 0));
              else
                vNUMBER_TMP = 0;
              -- уменьшим кол-во дней пени на оплаченные дни
              Fine_Days = Fine_Days - vNUMBER_TMP;
              if (Fine_Days < 0) then
                Fine_Days = 0;

              fine_sum = fine_days * fine_percent * vSUM / 100;
            end
          end
        end
        fine_sum = round(fine_sum, V_FEE_ROUND);
        if ((fine_sum > DOLG_SUM) and (DOLG_SUM > 0)) then
          fine_sum = DOLG_SUM;
        suspend;
      end
    end
    else
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE CALCULATE_SRV_TYPE_0 (
    ACUSTOMER TYPE OF UID)
AS
begin
  /* Procedure Text */
  suspend;
end;


CREATE OR ALTER PROCEDURE CAN_USER_VIEW_ADDRESS (
    HOUSE_ID D_UID_NULL = null,
    STREET_ID D_UID_NULL = null,
    USER_NAME D_VARCHAR30 = current_user)
RETURNS (
    CAN_VIEW D_IBOOLEAN)
AS
declare variable USER_ID D_Uid_Null;
begin
  if (USER_NAME is null) then
    USER_NAME = current_user;

  select
      u.Id
    , u.All_Areas
    from sys$user u
    where u.Ibname = :USER_NAME
          and u.Lockedout = 0
  into :USER_ID, :CAN_VIEW;

  CAN_VIEW = coalesce(CAN_VIEW, 0);
  -- если пользователь есть, но не видит все участки, то пройдем по участкам
  if ((not(USER_ID is null))
      or
      (CAN_VIEW = 0)) then begin

    if (not HOUSE_ID is null) then begin
      if (exists(select
                     ua.User_Id
                   from house h
                        inner join Workgroups z on (h.Wg_Id = z.Wg_Id)
                        inner join Sys$User_Areas ua on (ua.Area_Id = z.Wa_Id)
                   where h.House_Id = :HOUSE_ID
                         and ua.User_Id = :USER_ID)) then
        CAN_VIEW = 1;
    end
    else begin
      if (not Street_ID is null) then begin
        if (exists(select
                       ua.User_Id
                     from street s
                          inner join house h on (s.Street_Id = h.Street_Id)
                          inner join Workgroups z on (h.Wg_Id = z.Wg_Id)
                          inner join Sys$User_Areas ua on (ua.Area_Id = z.Wa_Id)
                     where s.Street_Id = :Street_ID
                           and ua.User_Id = :USER_ID)) then
          CAN_VIEW = 1;
      end
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE CANCEL_CONTRACT (
    PCUSTOMER_ID TYPE OF UID,
    PCANCEL_DATE D_DATE,
    POFF_SRV_ID TYPE OF UID)
AS
declare variable Srv_Id D_Integer;
begin
  if (not(POFF_SRV_Id is null)) then begin
    update CUSTOMER
    set VALID_TO = :PCANCEL_DATE
    where (CUSTOMER_ID = :pCUSTOMER_ID);

    for select
            ss.Serv_Id
          from SUBSCR_SERV ss
          where ss.Customer_Id = :PCUSTOMER_ID
                and ss.State_Srv = -3
        into :SRV_ID
    do
      execute procedure Change_Autoblock_Off(:PCUSTOMER_ID, :SRV_ID, :POFF_SRV_Id, 0);

    update SUBSCR_HIST
    set DATE_TO = dateadd(day, -1, :PCANCEL_DATE),
        DISACT_SERV_ID = :POFF_SRV_Id
    where (CUSTOMER_ID = :pCUSTOMER_ID
          and DISACT_SERV_ID = -1);

    update SUBSCR_SERV
    set STATE_SGN = 0,
        STATE_DATE = :PCANCEL_DATE,
        STATE_SRV = :POFF_SRV_Id
    where (CUSTOMER_ID = :pCUSTOMER_ID
          and STATE_SGN = 1);

    if (PCANCEL_DATE < localtimestamp) then
      execute procedure DIGITAL_EVENT(2, :pCUSTOMER_ID, null, null, localtimestamp, null);
    else
      execute procedure DIGITAL_EVENT(2, :pCUSTOMER_ID, null, null, :PCANCEL_DATE, null);
    execute procedure FULL_RECALC_CUSTOMER(:PCUSTOMER_ID);
  end
end;


CREATE OR ALTER PROCEDURE CANCEL_LAST_SUBSCRIBE_ACTION (
    SUBSCR_SERV_ID TYPE OF UID)
RETURNS (
    RESULT TYPE OF D_INTEGER)
AS
declare variable Customer_Id type of Uid;
declare variable Serv_Id     type of Uid;
declare variable State_Sgn   type of D_Integer;
declare variable State_Date  type of D_Date;
declare variable State_Srv   type of D_Uid_Null;
begin
  result = 1;
  select
      Customer_Id
    , Serv_Id
    , State_Sgn
    , State_Date
    , State_Srv
    from Subscr_Serv s
    where s.Subscr_Serv_Id = :SUBSCR_SERV_ID
  into :Customer_Id, :Serv_Id, :State_Sgn, :State_Date, :State_Srv;

  -- нужно разобраться с переключением
  delete from Single_Serv s
      where s.Serv_Date = :State_Date
            and s.Customer_Id = :Customer_Id
            and s.Service_Id = :State_Srv
            and s.History_Id = :SUBSCR_SERV_ID;

  if (State_Sgn = 0) then begin
    -- если отменяем отключение
    State_Date = dateadd(day, -1, State_Date);

    update Subscr_Hist h
    set h.Date_To = '2100-1-1',
        h.Disact_Serv_Id = -1
    where h.Subscr_Serv_Id = :SUBSCR_SERV_ID
          and h.Disact_Serv_Id = :State_Srv
          and h.Date_To = :State_Date;

    select first 1
        h.Act_Serv_Id
      , h.Date_From
      from Subscr_hist h
      where h.Subscr_Serv_Id = :SUBSCR_SERV_ID
      order by h.Date_From desc
    into :State_Srv, :State_Date;

    update Subscr_Serv s
    set s.State_Sgn = 1,
        s.State_Date = :State_Date,
        s.State_Srv = :State_Srv
    where s.Subscr_Serv_Id = :SUBSCR_SERV_ID;

  end
  else begin
    -- если отменяем подключение
    delete from Subscr_Hist h
        where h.Subscr_Serv_Id = :SUBSCR_SERV_ID
              and h.Act_Serv_Id = :State_Srv
              and h.Date_from = :State_Date;

    State_Srv = null;
    select first 1
        h.Disact_Serv_Id
      , h.Date_to
      from Subscr_hist h
      where h.Subscr_Serv_Id = :SUBSCR_SERV_ID
      order by h.Date_From desc
    into :State_Srv, :State_Date;

    if (State_Srv is not null) then
      update Subscr_Serv s
      set s.State_Sgn = 0,
          s.State_Date = dateadd(day, 1, :State_Date),
          s.State_Srv = :State_Srv
      where s.Subscr_Serv_Id = :SUBSCR_SERV_ID;
    else
      delete from Subscr_Serv s
          where s.Subscr_Serv_Id = :SUBSCR_SERV_ID;

  end

  -- тут еще проверку на цифровую услуг
  select
      s.business_type
    from services s
    where s.service_id = :Serv_Id
  into :State_Srv;

  if (State_Srv >= 2) then begin -- digital service
    if (State_Sgn = 0) then
      State_Sgn = 2;
    execute procedure DIGITAL_EVENT(:State_Sgn, :CUSTOMER_ID, null, :SERV_ID, localtimestamp, null);
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE CARDS_PREPAY_ACTIVATE (
    CARD_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE D_DATE)
RETURNS (
    PAYMENT_ID TYPE OF UID)
AS
declare variable PAY_DOC_ID      d_integer;
declare variable PAY_SUM         D_N15_2;
declare variable NOTICE          D_NOTICE;
declare variable PAYSOURCE_ID    D_integer;
declare variable EXPIRATION_DATE D_date;
begin
  select
      Card_Nominal, Expiration_Date, 'Карта оплаты №' || coalesce(cs.Cs_Serial, '') || ' ' || cp.Card_Number, coalesce(Cs.Cs_Source_Id, 0)
    from Cards_Prepay cp
         left outer join Cards_Serials cs on (cp.Card_Serial = cs.Cs_Id)
    where Card_ID = :Card_ID
          and cp.Card_State = 0 -- проверим не активирована ли карта
          and cp.Expiration_Date >= :Pay_Date -- проверим не прошла ли дата карточки
          and cp.Added_On <= :Pay_Date -- проверим чтоб активация не была раньше чем создание карты
  into :Pay_Sum, :Expiration_Date, :Notice, :Paysource_Id;

  if (Pay_sum is null) then
    Pay_Sum = 0;

  -- если не установлена дата сгорания, то поставим дату платежа
  if (EXPIRATION_DATE is null) then
    EXPIRATION_DATE = PAY_DATE;

  if ((Pay_Sum > 0) -- если карта активирована или на ней 0, то не будем добавлять
      and (Expiration_Date >= PAY_DATE)) -- не просрочена ли карта
      then begin

    select
        Pay_Doc_Id
      from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
    into :Pay_Doc_Id;

    PAYMENT_ID = gen_id(gen_payment, 1);

    insert into Payment (Payment_Id, Pay_Doc_Id, Customer_Id, Pay_Date, Pay_Sum, Notice)
    values (:Payment_Id, :Pay_Doc_Id, :Customer_Id, :Pay_Date, :Pay_Sum, :Notice);

    update Cards_Prepay
    set Payment_Id = :Payment_Id
    where (Card_Id = :Card_Id);
  end

end;


CREATE OR ALTER PROCEDURE CARDS_PREPAY_GENERATE (
    CP_COUNT D_INTEGER,
    CP_NOMINAL D_N15_2,
    CP_SERIAL D_INTEGER,
    CP_EXP_DATE D_DATE)
AS
declare variable I         D_INTEGER;
declare variable V_Length  D_INTEGER;
declare variable V_Number  D_VARCHAR20;
declare variable V_PIN_LEN D_INTEGER;
declare variable V_Pin     D_VARCHAR20;
begin
  select
      Var_Value
    from Settings
    where Var_Name = 'CP_NUMBER_LEN'
  into :V_LENGTH;
  if (V_LENGTH is null) then
    V_LENGTH = 10;

  select
      Var_Value
    from Settings
    where Var_Name = 'CP_PIN_LEN'
  into :V_PIN_LEN;
  if (V_PIN_LEN is null) then
    V_PIN_LEN = 0;

  while (CP_COUNT > 0) do begin
    V_number = '';
    I = 0;

    while (I < v_length) do begin
      V_number = V_number ||(round(rand() * 10, 0));
      I = char_length(V_number);
    end

    V_PIN = '';
    I = 0;
    while (I < V_PIN_LEN) do begin
      V_PIN = V_PIN ||(round(rand() * 10, 0));
      I = char_length(V_PIN);
    end

    insert into Cards_Prepay (Card_Serial, Card_Number, Card_Nominal, Card_Pin, Expiration_Date, Card_State)
    values (:CP_Serial, :v_Number, :CP_Nominal, :v_Pin, :CP_Exp_Date, 0);
    Cp_Count = Cp_Count - 1;
  end
end;


CREATE OR ALTER PROCEDURE CHANGE_AUTOBLOCK_OFF (
    CUSTOMER_ID TYPE OF UID,
    SERVICE_ID TYPE OF UID,
    OFF_SERVICE TYPE OF UID,
    UNITS D_N15_2)
AS
declare variable Id     D_Integer;
declare variable P_DATE D_DATE;
begin
  if (UNITS is null) then
    UNITS = 0;
  select
      SS.SUBSCR_SERV_ID, ss.State_Date
    from SUBSCR_SERV SS
         inner join SERVICES S on (S.SERVICE_ID = SS.SERV_ID)
    where SS.CUSTOMER_ID = :CUSTOMER_ID
          and SS.SERV_ID = :Service_Id
  into :ID, :P_DATE;
  update SUBSCR_HIST SH
  set SH.DISACT_SERV_ID = :OFF_SERVICE
  where SH.SUBSCR_SERV_ID = :ID
        and SH.DISACT_SERV_ID = -3 -- srv AutoBlock;
        and sh.Date_To = dateadd(day, -1, :P_DATE);
  update SUBSCR_SERV
  set STATE_SRV = :OFF_SERVICE
  where SUBSCR_SERV_ID = :ID;
  execute procedure ADD_SINGLE_SERVICE(:CUSTOMER_ID, :OFF_SERVICE, :UNITS, :P_DATE, null, :ID);
end;


CREATE OR ALTER PROCEDURE CHANGE_CH_TO_CH (
    FROM_CH D_UID_NULL,
    TO_CH D_UID_NULL,
    ANALOG D_IBOOLEAN = null,
    DVB D_IBOOLEAN = null,
    IPTV D_IBOOLEAN = null)
AS
declare variable Ch_Number       D_Integer;
declare variable Ch_Freq         D_N15_3;
declare variable Ch_Coded        D_Iboolean;
declare variable Ch_Trunk        D_Integer;
declare variable Ch_Trunk_Number D_Integer;
begin
  select
      Ch_Number
    , Ch_Freq
    , Ch_Coded
    , Ch_Trunk
    , Ch_Trunk_Number
    from Channels o
    where o.Ch_Id = :From_Ch
  into :Ch_Number, :Ch_Freq, :Ch_Coded, :Ch_Trunk, :Ch_Trunk_Number;

  if (Analog = 1) then begin
    update Channels n
    set n.Ch_Number = :Ch_Number,
        n.Ch_Freq = :Ch_Freq
    where n.Ch_Id = :To_Ch;

    update Channels o
    set o.Ch_Number = null,
        o.Ch_Freq = null
    where o.Ch_Id = :From_Ch;
  end
  if (Dvb = 1) then begin
    -- DVB
    update Dvb_Stream_Channels n
    set n.Ch_Id = :To_Ch
    where n.Ch_Id = :From_Ch;
    -- каналы услуги
    update Channels_In_Servce n
    set n.Ch_Id = :To_Ch
    where n.Ch_Id = :From_Ch;
    -- кодировка STV
    update Channels n
    set n.Ch_Trunk = :Ch_Trunk,
        n.Ch_Trunk_Number = :Ch_Trunk_Number,
        n.Ch_Coded = :Ch_Coded
    where n.Ch_Id = :To_Ch;

    update Channels o
    set o.Ch_Trunk = null,
        o.Ch_Trunk_Number = null
    where o.Ch_Id = :From_Ch;
  end
end;


CREATE OR ALTER PROCEDURE CHANGE_TO_POSITIVE (
    CUSTOMER_ID UID,
    OLD_DEBT D_N15_2 = null,
    NEW_DEBT D_N15_2 = null,
    HOUSE_ID D_UID_NULL = null,
    FLAT D_FLAT = null /* COLLATE UTF8 - default */)
AS
declare variable V      D_Varchar50;
declare variable RT     D_Uid_Null;
declare variable SUM_RQ D_N15_2;
begin
  NEW_DEBT = -1 * NEW_DEBT;
  OLD_DEBT = -1 * OLD_DEBT;

  -- проверим нужно ли создавать заявку
  select
      s.Var_Value
    from Settings s
    where s.Var_Name = 'RQ_TO_POSITIVE'
  into :V;
  V = coalesce(V, '');
  if (V <> '') then begin
    RT = cast(V as integer);
    -- сумма при какой создавать заявку
    V = null;
    select
        s.Var_Value
      from Settings s
      where s.Var_Name = 'RQ_SUM_POSITIVE'
    into :V;
    V = coalesce(V, '');
    begin
      SUM_RQ = cast(V as numeric(15,2));
      when gdscode convert_error do
      begin
        SUM_RQ = null;
      end
    end
    if ((V<>'') and (NEW_DEBT >= SUM_RQ)) then begin
      -- добавим заявку только если абонент отключен и у него нет услуг с автовключением
      if (not exists(select
                         h.Customer_Id
                       from Subscr_Hist h
                       where current_date between h.Date_From and h.Date_To
                             and h.Customer_Id = :Customer_Id)) then begin
        if (not exists(select
                           h.Customer_Id
                         from Subscr_serv h
                         where h.Customer_Id = :Customer_Id
                               and h.State_Srv = -3)) then begin

          if ((HOUSE_ID is null)
              or
              (FLAT is null)) then begin
            select
                c.House_Id
              , c.Flat_No
              from customer c
              where c.Customer_Id = :CUSTOMER_ID
            into :HOUSE_ID, :FLAT;
          end
          V = coalesce(:OLD_DEBT, '') || ' -> ' || coalesce(:NEW_DEBT, '');
          insert into Request (Rq_Type, Rq_Customer, Rq_Content, Rq_Plan_Date, House_Id, Flat_No)
          values (:RT, :CUSTOMER_ID, :V, current_date, :House_Id, :Flat);
        end
      end
    end
    when gdscode convert_error do
    begin
      V = 'N';
    end
  end
end;


CREATE OR ALTER PROCEDURE CHANNELS_DEL (
    CH_ID TYPE OF COLUMN CHANNELS.CH_ID)
AS
begin
  delete from Channels c where c.Ch_Id = :Ch_Id
        and not exists(select
                           s.Ch_Id
                         from CHANNELS_IN_SERVCE s
                         where s.Ch_Id = c.Ch_Id)
        and not exists(select
                           s.Ch_Id
                         from DVB_STREAM_CHANNELS s
                         where s.Ch_Id = c.Ch_Id);
end;


CREATE OR ALTER PROCEDURE CHANNELS_FOR_ALL_CUSTOMER (
    CHECK_DATE D_DATE)
RETURNS (
    CUSTOMER_ID TYPE OF UID,
    DECODER_ID TYPE OF UID,
    CHANNEL_ID TYPE OF UID,
    DECODER_N TYPE OF D_DECODER,
    CHANNEL_STATE D_INTEGER)
AS
begin
  if (CHECK_DATE is null) then
    CHECK_DATE = current_date;

  for select
          D.CUSTOMER_ID
        from CUSTOMER_DECODERS D
      into :CUSTOMER_ID
  do begin
    for select
            Decoder_Id, Channel_Id, Decoder_N, Channel_State
          from Get_Customer_Channels(:Check_Date, :Customer_Id)
        into :Decoder_Id, :Channel_Id, :Decoder_N, :Channel_State
    do
      suspend;
  end

end;


CREATE OR ALTER PROCEDURE CHANNELS_FOR_CUSTOMER (
    CUSTOMER_ID TYPE OF UID,
    CHECK_DATE D_DATE)
RETURNS (
    C_CHANNEL D_INTEGER,
    C_CHANNEL_ON D_INTEGER)
AS
DECLARE VARIABLE vOn d_INTEGER;
begin
vOn = 0;
-- если включены пакеты
FOR
  SELECT distinct Cs.Ch_Id, Cs.On_Off
  FROM Subscr_Hist Sh
    INNER JOIN Channels_In_Servce Cs ON (Sh.Serv_Id = Cs.Srv_Id)
  WHERE
    :CHECK_DATE BETWEEN Sh.Date_From AND Sh.Date_To
    AND Cs.On_Off = 1
    AND Sh.Customer_Id = :CUSTOMER_ID
  order by 1
INTO :C_CHANNEL, :C_CHANNEL_ON
DO BEGIN
  vOn = 1;
  SUSPEND;
END
-- если отключены пакеты
if (0 = vOn) then
begin
  FOR
    SELECT DISTINCT
      Cs.Ch_Id,
      Cs.On_Off
    FROM Subscr_Serv Ss
         INNER JOIN Channels_In_Servce Cs ON (Ss.Serv_Id = Cs.Srv_Id)
      WHERE
        (ss.Customer_Id = :CUSTOMER_ID) and cs.On_Off = 0
      order by 1
    INTO :C_CHANNEL, :C_CHANNEL_ON
  DO BEGIN
    vOn = 1;
    SUSPEND;
  END
end

-- персональные каналы

FOR
  SELECT cc.Ch_Id, 1
  FROM Customer_Channels cc inner join Customer_Decoders cd on (cd.Dec_Id = cc.Decoder_Id)
  where
    cd.Customer_Id = :CUSTOMER_ID
    and :CHECK_DATE BETWEEN cc.Date_ON AND cc.Date_OFF
  order by 1
INTO :C_CHANNEL, :C_CHANNEL_ON
DO BEGIN
  SUSPEND;
END


end;


CREATE OR ALTER PROCEDURE CHECK_FOR_UNBLOCK (
    CUSTOMER_ID UID)
AS
declare variable SERVICE_ID    type of UID;
declare variable VTARIF        D_N15_2;
declare variable MTARIF        D_N15_2;
declare variable DEBT          D_N15_2;
declare variable FEE_ROUND     D_INTEGER;
declare variable CALC_TYPE     D_INTEGER;
declare variable V_DAYS        D_INTEGER;
declare variable V_MONTH       D_DATE;
declare variable JUR           D_IBOOLEAN;
declare variable VDISCOUNT     D_N15_4;
declare variable vResult       D_INTEGER;
declare variable POSITIVE_ONLY D_IBOOLEAN;
declare variable SrvType       D_Integer;
declare variable UnblMeth      D_Integer;
begin
  select -- баланс и юрик
  (C.DEBT_SUM - coalesce(C.PREPAY, 0))
    , coalesce(C.JURIDICAL, 0)
    from CUSTOMER C
    where C.CUSTOMER_ID = :CUSTOMER_ID
  into :DEBT, :JUR;
  DEBT = -1.00 * DEBT;

  select
      cast(VAR_VALUE as integer)
    from SETTINGS
    where VAR_NAME = 'FEE_ROUND'
  into :FEE_ROUND;

  for select
          SERVICE_ID
        , S.CALC_TYPE
        , coalesce(POSITIVE_ONLY, 0)
        , s.BUSINESS_TYPE
        , coalesce(s.Unbl_Meth, 0)
        from SERVICES S
             inner join SUBSCR_SERV SS on (SS.SERV_ID = S.SERVICE_ID)
        where S.SRV_TYPE_ID = 0
              and SS.STATE_SGN = 0
              and SS.STATE_SRV < -1
              and S.AUTOOFF = 1
              and SS.CUSTOMER_ID = :CUSTOMER_ID
      into :SERVICE_ID, :CALC_TYPE, :POSITIVE_ONLY, :SrvType, :UnblMeth
  do begin
    VTARIF = null;
    VDISCOUNT = null;

    select first 1
        TARIF_SUM
      from PERSONAL_TARIF
      where current_date between DATE_FROM and DATE_TO
            and SERVICE_ID = :SERVICE_ID
            and CUSTOMER_ID = :CUSTOMER_ID
    into :VTARIF;
    /* если нет персонального тарифа берем общий тариф*/
    if (VTARIF is null) then begin
      select first 1
          D.FACTOR_VALUE
        from DISCOUNT_FACTOR D
        where D.CUSTOMER_ID = :CUSTOMER_ID
              and current_date between D.DATE_FROM and D.DATE_TO
              and ((D.SERV_ID = :SERVICE_ID)
                or ((D.SERV_ID = -1)
              and ((D.Srv_Type = -1)
                or (d.Srv_Type = :SrvType))))
        order by D.SERV_ID desc
      into :VDISCOUNT;
      if (VDISCOUNT is null) then
        VDISCOUNT = 1;
      select first 1
          coalesce(iif(:JUR = 1, T.TARIF_SUM_JUR, T.TARIF_SUM), 0)
        from TARIF T
        where current_date between T.DATE_FROM and T.DATE_TO
              and T.SERVICE_ID = :SERVICE_ID
      into :VTARIF;
      VTARIF = VTARIF * VDISCOUNT;
    end
    MTARIF = VTARIF;

    -- 2 - ежедневное начисление
    if (CALC_TYPE = 2) then begin
      V_MONTH = current_date - extract(day from current_date) + 1;
      V_DAYS = extract(day from (dateadd(-1 day to(dateadd(1 month to V_MONTH)))));
      VTARIF = round(VTARIF / V_DAYS, FEE_ROUND);
    end

    if ((DEBT >= VTARIF)
        or
        ((DEBT >= 0) and (POSITIVE_ONLY = 0))) then begin
      -- при оплате на месяц
      if (UnblMeth = 2) then begin
        if (DEBT >= MTARIF) then
          execute procedure AUTO_ON_SERVICE(:CUSTOMER_ID, :SERVICE_ID, current_date, -2, '')
              returning_values :vResult;
      end
      else begin
        -- при оплате на день
        if (UnblMeth = 1) then begin
          V_MONTH = current_date - extract(day from current_date) + 1;
          V_DAYS = extract(day from (dateadd(-1 day to(dateadd(1 month to V_MONTH)))));
          MTARIF = round(MTARIF / V_DAYS, FEE_ROUND);
          if (DEBT >= MTARIF) then
            execute procedure AUTO_ON_SERVICE(:CUSTOMER_ID, :SERVICE_ID, current_date, -2, '')
                returning_values :vResult;
        end
        else
          -- в других случаях
          execute procedure AUTO_ON_SERVICE(:CUSTOMER_ID, :SERVICE_ID, current_date, -2, '')
              returning_values :vResult;
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE CHECK_IN_BLOCK (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    FOR_DATE D_DATE)
RETURNS (
    IN_BLOCK D_INTEGER)
AS
declare variable Disact_Serv_Id D_Uid_Null;
begin
  select first 1
      Disact_Serv_Id
    from Subscr_Hist sh
    where sh.Customer_Id = :CUSTOMER_ID
          and sh.Serv_Id = :SERVICE_ID
          and sh.Date_From <= :FOR_DATE
    order by sh.Date_From desc
  into :Disact_Serv_Id;

  if (Disact_Serv_Id = -3) then
    IN_BLOCK = 1;
  else
    IN_BLOCK = 0;
  suspend;
end;


CREATE OR ALTER PROCEDURE CHECK_IN_OFF (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    FOR_DATE D_DATE)
RETURNS (
    SRV_OFF D_INTEGER)
AS
declare variable Date_To        D_Date;
declare variable CALC_TYPE      D_Integer;
declare variable Disact_Serv_Id D_Uid_Null;
begin
  SRV_OFF = 0;
  select first 1
      Date_To, s.Calc_Type, sh.Disact_Serv_Id
    from Subscr_Hist sh
         inner join services s on (sh.Serv_Id = s.Service_Id)
    where sh.Customer_Id = :CUSTOMER_ID
          and sh.Serv_Id = :SERVICE_ID
          and sh.Date_From <= :FOR_DATE
    order by sh.Date_From desc, sh.Date_To desc
  into :Date_To, :CALC_TYPE, Disact_Serv_Id;

  if (Disact_Serv_Id <> -3) then begin

    if (CALC_TYPE = 5) then begin
     if (Date_To <= dateadd(day, -1, FOR_DATE)) then
       SRV_OFF = 1;
    end
    else
     if (Date_To < FOR_DATE) then
       SRV_OFF = 1;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE CHECK_SRV_ACTIVE (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL,
    FOR_DATE D_DATE = current_date)
RETURNS (
    SRV_ON D_INTEGER,
    DATE_ON D_DATE)
AS
declare variable sh_id D_Uid_Null;
begin

  if (FOR_DATE is null) then FOR_DATE = current_date;

  SRV_ON = 0;

  select first 1
      sh.Subscr_Serv_Id, sh.Date_From
    from Subscr_Hist sh
         inner join services s on (sh.Serv_Id = s.Service_Id)
    where sh.Customer_Id = :CUSTOMER_ID
          and ((sh.Serv_Id = :SERVICE_ID) or (:SERVICE_ID is null))
          and sh.Date_From <= :FOR_DATE
          and ((s.Calc_Type <> 5 and sh.date_to >= dateadd(day, -1, :FOR_DATE))
            or (s.Calc_Type = 5 and sh.date_to >= dateadd(day, -1, :FOR_DATE)))
--    order by sh.Date_From
  into :sh_id, :DATE_ON;

  if (sh_id is null) then
    SRV_ON = 0;
  else
    SRV_ON = 1;

  suspend;
end;


CREATE OR ALTER PROCEDURE CHECKCONTRACT (
    CONTRACT TYPE OF D_VARCHAR20)
RETURNS (
    CORRECT TYPE OF D_IBOOLEAN)
AS
declare variable I d_integer;
begin
  CORRECT = 1;
  select count(*) from customer c where c.dogovor_no = :CONTRACT
  into :i;
  if (i=0)
  then begin
      select count(*) from SUBSCR_SERV S where s.contract = :CONTRACT
      into :i;
      if (i>0) then correct = 0;
  end
  else correct = 0;
  suspend;
end;


CREATE OR ALTER PROCEDURE CLOSE_DAY_PROC (
    P_MONTH D_DATE = null,
    P_CUSTOMER_ID TYPE OF UID = null)
AS
declare variable V_S_MONTH   D_DATE;
declare variable CUSTOMER_ID D_INTEGER;
declare variable V_FEE_ROUND D_INTEGER;
declare variable V_CALC_TYPE D_INTEGER; -- метод расчета услуги
begin
  if (P_MONTH is null) then
    P_MONTH = current_date;
  /* получим значение число знаков после запятой для округления*/
  select
      cast(VAR_VALUE as integer)
    from SETTINGS
    where VAR_NAME = 'FEE_ROUND'
  into :V_FEE_ROUND;
  if (P_MONTH is null) then
    P_MONTH = current_date;
  V_S_MONTH = (P_MONTH - extract(day from P_MONTH) + 1); -- начало месяца
  --V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH))); -- конец месяца

  /*  расчет услуг с ежеденевным начислением                      */
  V_CALC_TYPE = 2;
  /*
  -- Удалим все начисления за месяц
  delete from MONTHLY_FEE F
      where F.MONTH_ID between :V_S_MONTH and :P_MONTH
            and exists(select
                           s.Service_Id
                         from Services s
                         where s.Service_Id = f.Service_Id
                               and S.SRV_TYPE_ID = 0
                               and S.CALC_TYPE = :V_CALC_TYPE)
            and ((f.customer_id = :p_customer_id)
              or (:p_customer_id is null));
  */
  execute procedure CALC_DAY_TARIF(:V_S_MONTH, :V_CALC_TYPE);

  for select distinct
          SH.CUSTOMER_ID
        from Subscr_Serv SH
             inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :V_CALC_TYPE
              and ((:P_CUSTOMER_ID is null)
                or (sh.Customer_Id = :P_CUSTOMER_ID))
      into :CUSTOMER_ID
  do
    execute procedure CALC_DAY_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);

  /*  расчет услуг с ежеденевным начислением с учетом дня подключения       */
  V_CALC_TYPE = 5;
  /*
  -- Удалим все начисления за месяц
  delete from MONTHLY_FEE F
      where F.MONTH_ID between :V_S_MONTH and :P_MONTH
            and exists(select
                           s.Service_Id
                         from Services s
                         where s.Service_Id = f.Service_Id
                               and S.SRV_TYPE_ID = 0
                               and S.CALC_TYPE = :V_CALC_TYPE)
            and ((f.customer_id = :p_customer_id)
              or (:p_customer_id is null));
  */
  execute procedure CALC_DAY_TARIF(:V_S_MONTH, :V_CALC_TYPE);

  for select distinct
          SH.CUSTOMER_ID
        from Subscr_Serv SH
             inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
        where S.SRV_TYPE_ID = 0
              and S.CALC_TYPE = :V_CALC_TYPE
              and ((:P_CUSTOMER_ID is null)
                or (sh.Customer_Id = :P_CUSTOMER_ID))
      into :CUSTOMER_ID
  do
    execute procedure CALC_DAY_INC_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
end;


CREATE OR ALTER PROCEDURE CLOSE_MATERIAL_DOC (
    DOC_ID UID)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable M_Id       type of Uid;
declare variable Mi_Quant   type of D_N15_5;
declare variable Wh_Id      type of Uid;
declare variable from_Wh_Id type of Uid;
declare variable type_Id    type of Uid;
declare variable doc_date   type of D_Date;
declare variable Quant      type of D_N15_5;
declare variable vCLOSED    D_INTEGER;
begin
  result = 1;

  select
      Wh_Id
    , Dt_Id
    , From_Wh
    , d.Doc_Date
    , coalesce(d.Doc_Closed, 0)
    from material_docs d
    where doc_id = :Doc_Id
  into :Wh_Id, :type_Id, :from_Wh_Id, :doc_date, :vCLOSED;

  if (vCLOSED = 1) then begin
    suspend;
    exit;
  end

  if (type_Id is null) then begin
    result = 0;
    suspend;
    exit;
  end

  -- перед закрытием проверим, хватает ли материала на складе
  if (type_Id = 2) -- перемещение
      -- (type_Id = 3)  -- списание материалов
  then begin
    for select
            M_Id
          , sum(M_Quant)
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
                and coalesce(M_Quant, 0) <> 0
          group by m_id
        into :M_Id, :MI_QUANT
    do begin
      Quant = null;
      select
          rm.Mr_Quant
        from Materials_Remain rm
        where rm.M_Id = :m_id
              and ((rm.Wh_Id = :from_Wh_Id
              and :type_Id = 2)
                or (rm.Wh_Id = :Wh_Id
              and :type_Id = 3))
      into :Quant;
      Quant = coalesce(Quant, MI_QUANT - 1);
      if (Quant < MI_QUANT) then
        exception E_Mat_Quant_Less;
    end
  end

  -- оприходуем на склад
  if ((type_Id = 1) -- Приход материалов
      or
      (type_Id = 2) -- перемещение
      or
      (type_Id = 4) -- инвинтаризация (коррекция)
      or
      (type_Id = 5)) -- инвинтаризация
  then begin
    for select
            M_Id
          , sum(coalesce(M_Quant, 0))
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
          group by m_id
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update Materials_Remain
        set MR_QUANT = MR_QUANT + :MI_QUANT
        where M_Id = :M_ID
              and Wh_Id = :WH_ID;
        if (row_count = 0) then -- если не нашли, вставим запись
          insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
          values (:M_Id, :Wh_Id, :Mi_Quant);
      end
    end
  end

  -- спишем со склада донора
  if ((type_Id = 2)) then begin -- перемещение
    for select
            M_Id
          , sum(coalesce(M_Quant, 0))
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
          group by m_id
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update MATERIALS_REMAIN r
        set MR_QUANT = MR_QUANT - :MI_QUANT
        where WH_ID = :from_Wh_Id
              and M_ID = :M_ID;
      end
    end
  end

  -- спишем со склада
  if ((type_Id = 3)) then begin -- списание материалов
    for select
            M_Id
          , sum(coalesce(M_Quant, 0))
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
          group by m_id
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update MATERIALS_REMAIN r
        set MR_QUANT = MR_QUANT - :MI_QUANT
        where WH_ID = :Wh_Id
              and M_ID = :M_ID;
      end
    end
  end

  -- спишем со склада документом
  if ((type_Id = 5)) then begin -- списание материалов
    for select
            M_Id
          , sum(coalesce(B_Quant, 0))
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
          group by m_id
        into :M_Id, :MI_QUANT
    do begin
      update MATERIALS_REMAIN r
      set MR_QUANT = MR_QUANT - :MI_QUANT,
          Inventory = iif(:doc_date >= coalesce(Inventory, :doc_date), :doc_date, coalesce(Inventory, :doc_date))
      where WH_ID = :Wh_Id
            and M_ID = :M_ID;
    end
  end

  update material_docs
  set Doc_Closed = 1
  where doc_id = :DOC_ID;

  suspend;

end;


CREATE OR ALTER PROCEDURE CLOSE_MONTH_PROC (
    P_MONTH D_DATE,
    P_CUSTOMER_ID TYPE OF UID = null)
AS
declare variable V_S_MONTH   D_DATE;
declare variable V_E_MONTH   D_DATE;
declare variable CUSTOMER_ID D_INTEGER;
declare variable V_FEE_ROUND D_INTEGER;
declare variable V_CALC_TYPE D_INTEGER; -- метод расчета услуги
declare variable V_FLAG      D_INTEGER; -- оптимизация
declare variable need_0      D_INTEGER; -- оптимизация
declare variable need_1      D_INTEGER; -- оптимизация
declare variable need_2      D_INTEGER; -- оптимизация
declare variable need_3      D_INTEGER; -- оптимизация
declare variable need_5      D_INTEGER; -- оптимизация
begin
  -- установим на первое число месяца
  P_MONTH = P_MONTH - extract(day from P_MONTH) + 1;

  -- для скорости рассчета. исключим те типы услуг,
  -- которые не используются организацией/абонентом
  need_0 = 0;
  need_1 = 0;
  need_2 = 0;
  need_3 = 0;
  need_5 = 0;
  for select distinct
          CALC_TYPE
        from services s
        where S.SRV_TYPE_ID = 0
      into :V_CALC_TYPE
  do begin
    if (V_CALC_TYPE = 0) then
      need_0 = 1;
    else
    if (V_CALC_TYPE = 1) then
      need_1 = 1;
    else
    if (V_CALC_TYPE = 2) then
      need_2 = 1;
    else
    if (V_CALC_TYPE = 3) then
      need_3 = 1;
    else
    if (V_CALC_TYPE = 5) then
      need_5 = 1;
  end

  /* получим значение число знаков после запятой для округления*/
  select
      cast(VAR_VALUE as integer)
    from SETTINGS
    where VAR_NAME = 'FEE_ROUND'
  into :V_FEE_ROUND;
  V_FEE_ROUND = coalesce(V_FEE_ROUND, 2);

  -- начало месяца и конец месяца
  V_S_MONTH = P_MONTH;
  V_E_MONTH = dateadd(-1 day to(dateadd(1 month to V_S_MONTH)));

  -- Удалим все начисления за месяц
  delete from MONTHLY_FEE F
      where F.MONTH_ID between :V_S_MONTH and :V_E_MONTH
            and ((f.customer_id = :p_customer_id)
              or (:p_customer_id is null))
            -- оставим разовые меньше 0  (чтоб не блокировало услуги)
            and ((f.Fee >= 0)
              or ((f.Fee < 0)
            and exists(select
                           s.Service_Id
                         from services s
                         where s.Srv_Type_Id <> 2
                               and s.Service_Id = f.Service_Id)));

  /*---------------------------------------------------------------------------------*/
  /*          расчитываем периодические услуги, пропорционально дням                 */
  /*---------------------------------------------------------------------------------*/
  if (need_0 = 1) then begin
    V_CALC_TYPE = 0;
    -- оптимизация.
    -- ставим флаг для первого рассчета тарифа.
    -- если в цикл не заходим, то и не рассчитываем
    V_FLAG = 0;
    for select distinct
            SH.CUSTOMER_ID
          from Subscr_Serv SH
               inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
          where S.SRV_TYPE_ID = 0
                and S.CALC_TYPE = :V_CALC_TYPE
                and ((sh.customer_id = :p_customer_id)
                  or (:p_customer_id is null))
        into :CUSTOMER_ID
    do begin
      if (V_FLAG = 0) then begin
        execute procedure CALC_DAY_TARIF(:P_MONTH, :V_CALC_TYPE);
        V_FLAG = 1;
      end
      execute procedure CALC_MONTH_DAY_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
    end
  end
  /*---------------------------------------------------------------------------------*/
  /*                     расчет услуг исходя из целого месяца                        */
  /* т.е. например подключен 15 дней и мение - не берем абонплату                    */
  /*               подключен 16 дней и более - берем абонплату                       */
  /*---------------------------------------------------------------------------------*/
  if (need_1 = 1) then begin
    V_CALC_TYPE = 1;
    for select distinct
            SH.CUSTOMER_ID
          from Subscr_Serv SH
               inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
          where S.SRV_TYPE_ID = 0
                and S.CALC_TYPE = :V_CALC_TYPE
                and ((sh.customer_id = :p_customer_id)
                  or (:p_customer_id is null))
        into :CUSTOMER_ID
    do
      execute procedure CALC_MONTH_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
  end
  /*---------------------------------------------------------------------------------*/
  /*                     расчет услуг с ежеденевным начислением                      */
  /*---------------------------------------------------------------------------------*/
  if (need_2 = 1) then begin
    V_CALC_TYPE = 2;
    V_FLAG = 0;
    for select distinct
            SH.CUSTOMER_ID
          from Subscr_Serv SH
               inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
          where S.SRV_TYPE_ID = 0
                and S.CALC_TYPE = :V_CALC_TYPE
                and ((sh.customer_id = :p_customer_id)
                  or (:p_customer_id is null))
        into :CUSTOMER_ID
    do begin
      if (V_FLAG = 0) then begin
        execute procedure CALC_DAY_TARIF(:P_MONTH, :V_CALC_TYPE);
        V_FLAG = 1;
      end
      execute procedure CALC_DAY_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
    end
  end
  /*---------------------------------------------------------------------------------*/
  /*                   расчет услуг с фиксированным начислением                      */
  /*---------------------------------------------------------------------------------*/
  if (need_3 = 1) then begin
    V_CALC_TYPE = 3;
    V_FLAG = 0;
    for select distinct
            SH.CUSTOMER_ID
          from Subscr_Serv SH
               inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
          where S.SRV_TYPE_ID = 0
                and S.CALC_TYPE = :V_CALC_TYPE
                and ((sh.customer_id = :p_customer_id)
                  or (:p_customer_id is null))
        into :CUSTOMER_ID
    do begin
      if (V_FLAG = 0) then begin
        execute procedure CALC_DAY_TARIF(:P_MONTH, :V_CALC_TYPE);
        V_FLAG = 1;
      end
      execute procedure CALC_MONTH_FIX_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
    end
  end
  /*---------------------------------------------------------------------------------*/
  /*         расчет услуг с ежеденевным начислением с учетом дня подключения         */
  /*---------------------------------------------------------------------------------*/
  if (need_5 = 1) then begin
    V_CALC_TYPE = 5;
    V_FLAG = 0;
    for select distinct
            SH.CUSTOMER_ID
          from Subscr_Serv SH
               inner join SERVICES S on (SH.SERV_ID = S.SERVICE_ID)
          where S.SRV_TYPE_ID = 0
                and S.CALC_TYPE = :V_CALC_TYPE
                and ((sh.customer_id = :p_customer_id)
                  or (:p_customer_id is null))
        into :CUSTOMER_ID
    do begin
      if (V_FLAG = 0) then begin
        execute procedure CALC_DAY_TARIF(:P_MONTH, :V_CALC_TYPE);
        V_FLAG = 1;
      end
      execute procedure CALC_DAY_INC_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND, :V_CALC_TYPE);
    end
  end
  /*---------------------------------------------------------------------------------*/
  /*                     расчитываем разовые услуги                                  */
  /*---------------------------------------------------------------------------------*/
  for select distinct
          Sh.CUSTOMER_ID
        from SINGLE_SERV Sh
             inner join SERVICES S on (S.SERVICE_ID = Sh.SERVICE_ID)
        where S.SRV_TYPE_ID = 1
              and Sh.SERV_DATE between :V_S_MONTH and :V_E_MONTH
              and ((sh.customer_id = :p_customer_id)
                or (:p_customer_id is null))
      into :CUSTOMER_ID
  do
    execute procedure CALC_SINGLE_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND);

  /*---------------------------------------------------------------------------------*/
  /*                     расчитываем фиксированные услуги                            */
  /*---------------------------------------------------------------------------------*/
  -- Удалим разовые меньше 0
  delete from MONTHLY_FEE F
      where F.MONTH_ID between :V_S_MONTH and :V_E_MONTH
            and ((f.customer_id = :p_customer_id)
              or (:p_customer_id is null))
            and (f.Fee < 0)
            and exists(select
                           s.Service_Id
                         from services s
                         where s.Srv_Type_Id = 2
                               and s.Service_Id = f.Service_Id);
  for select distinct
          Sh.CUSTOMER_ID
        from SINGLE_SERV Sh
             inner join SERVICES S on (S.SERVICE_ID = Sh.SERVICE_ID)
        where S.SRV_TYPE_ID = 2
              and Sh.SERV_DATE between :V_S_MONTH and :V_E_MONTH
              and ((sh.customer_id = :p_customer_id)
                or (:p_customer_id is null))
      into :CUSTOMER_ID
  do
    execute procedure CALC_FIXED_SRV_CUSTOMER(:CUSTOMER_ID, :P_MONTH, :V_FEE_ROUND);

  if (P_CUSTOMER_ID is null) then begin
    execute procedure CALC_DISCOUNT(:P_MONTH);

    update SETTINGS
    set VAR_VALUE = extract(year from :P_MONTH) || '-' || extract(month from :P_MONTH) || '-1'
    where VAR_NAME = 'CURRENT_DATE';
  end
end;


CREATE OR ALTER PROCEDURE CLOSE_PERIOD_PROC (
    P_START_MONTH D_DATE,
    P_END_MONTH D_DATE,
    P_CUSTOMER_ID TYPE OF UID)
AS
DECLARE VARIABLE F_MONTH D_DATE;
BEGIN
  -- установим на первое число месяца
  p_start_month = p_start_month - EXTRACT(DAY FROM p_start_month) + 1;
  -- установим на первое число месяца
  p_end_month = p_end_month - EXTRACT(DAY FROM p_end_month) + 1;

  f_MONTH = p_start_month;
  while (f_month <= p_End_month) do begin
    EXECUTE PROCEDURE CLOSE_MONTH_PROC(:f_MONTH, P_CUSTOMER_ID);
    f_MONTH = DATEADD(1 MONTH TO f_MONTH);
  END
END;


CREATE OR ALTER PROCEDURE CURRENCY_TO_STR (
    VAL D_N15_2,
    SHOWCURRENCY D_INTEGER)
RETURNS (
    CURR_STR D_VARCHAR1000)
AS
declare razryad d_varchar50;
declare razryad_idx d_varchar50;
declare hundreds d_varchar100;
declare hundreds_idx d_varchar50;
declare tens d_varchar100;
declare tens_idx d_varchar50;
declare ones d_varchar255;
declare ones_idx d_varchar100;
 
declare sign_of_val d_varchar10;
declare raz d_integer;
declare cents d_varchar5;
declare val_str d_varchar50;
declare num d_varchar50;
declare i d_integer;
declare buf d_varchar255;
declare buf1 d_varchar255;
 
begin
  /* Константы */
  razryad_idx = /* 2.2 */ '0100010506071308210829114011';
  razryad = 'тысячмиллионмиллиардтриллионквадриллионквинтиллион';
  hundreds_idx = /* 2.1 */ '010013046106169257328407479569';
  hundreds = 'стодвеститристачетырестапятьсотшестьсотсемьсотвосемьсотдевятьсот';
  tens_idx = /* 2.2 */ '0100010001080908170522093110410950116109';
  tens = 'двадцатьтридцатьсорокпятьдесятшестьдесятсемьдесятвосемьдесятдевяносто';
  ones_idx = /* 3.2 */ '0010000100001000010300406010040140501904023060290603506041110521006210072120841009411105101151212712';
  ones = 'тричетырепятьшестьсемьвосемьдевятьдесятьодиннадцатьдвенадцатьтринадцатьчетырнадцатьпятнадцатьшестнадцатьсемнадцатьвосемнадцатьдевятнадцать';
 
  IF (ShowCurrency IS NULL) then ShowCurrency = 0;
  curr_str = '';
 
  /* Смотрим знак */
  IF (val < 0) then begin
    sign_of_val = 'минус ';
    val = -val;
  end else
    sign_of_val = '';
 
  /* Выбираем и запоминаем копейки, убираем их из числа */
  val_str = cast(val AS varchar(20));
  i = position('.' IN val_str);
  cents = lpad(substring(val_str FROM i+1 FOR 2), 2, '0');
  val_str = lpad(substring(val_str FROM 1 FOR i-1), ((i+1)/3*3), '0');
 
  /* Разбираем число */
  raz = 0; curr_str = '';
  while (val_str != '') do begin
    /* Берём триаду символов */
    num = RIGHT(val_str, 3);
    /* Если не нулевое число */
    IF (num != '000') then begin
      /* Берём сотни */
      i = cast(substring(num FROM 1 FOR 1) AS int);
      buf = substring(hundreds FROM cast(substring(hundreds_idx FROM i*3+1 FOR 2) AS int) FOR cast(substring(hundreds_idx FROM i*3+3 FOR 1) AS int));
 
      /* Далее десятки */
      /* Для "десятнадцатых" упрощённая обработка */
      IF (substring(num FROM 2 FOR 1) = '1') then begin
          /* Вставляем нужную "десятнадцать" */
          i = cast(substring(num FROM 2 FOR 2) AS int);
          buf1 = substring(ones FROM cast(substring(ones_idx FROM i*5+1 FOR 3) AS int) FOR cast(substring(ones_idx FROM i*5+4 FOR 2) AS int));
          IF (buf != '') then buf = buf || ' ';
          buf = buf || buf1;
      end else
      /* Для "нормальных" чисел своя обработка */
      begin
        /* Десятки */
        i = cast(substring(num FROM 2 FOR 1) AS int);
        buf1 = substring(tens FROM cast(substring(tens_idx FROM i*4+1 FOR 2) AS int) FOR cast(substring(tens_idx FROM i*4+3 FOR 2) AS int));
        IF (buf != '' AND buf1 != '') then buf = buf || ' ';
        buf = buf || buf1;
 
        /* Единицы */
        i = cast(substring(num FROM 3 FOR 1) AS int);
        /* Смотрим количество для нужного окончания */
        IF (i = 1) then begin
          IF (raz = 1) then buf1 = 'одна'; else buf1 = 'один';
        end else
        IF (i = 2) then begin
          IF (raz = 1) then buf1 = 'две'; else buf1 = 'два';
        end else
          buf1 = substring(ones FROM cast(substring(ones_idx FROM i*5+1 FOR 3) AS int) FOR cast(substring(ones_idx FROM i*5+4 FOR 2) AS int));
        IF (buf != '' AND buf1 != '') then buf = buf || ' ';
        buf = buf || buf1;
      end
 
      /* Разряд числа */
      buf1 = substring(razryad FROM cast(substring(razryad_idx FROM raz*4+1 FOR 2) AS int) FOR cast(substring(razryad_idx FROM raz*4+3 FOR 2) AS int));
      IF (buf1 != '') then begin
        /* Подбор окончания для разряда */
        IF (i = 1) then begin
          IF (raz = 1) then buf1 = buf1 || 'а';
        end else
        IF (i IN (2,3,4)) then begin
          IF (raz = 1) then buf1 = buf1 || 'и';
          else IF (raz > 1) then buf1 = buf1 || 'а';
        end else
          IF (raz > 1) then buf1 = buf1 || 'ов';
        buf = buf || ' ' || buf1;
      end
    end else
      buf = '';
 
    /* Присоединяем обработанную триаду к результату */
    IF (curr_str != '' AND buf != '') then buf = buf || ' ';
    curr_str = buf || curr_str;
    /* Переходим к следующей триаде */
    val_str = LEFT(val_str, char_length(val_str)-3);
    /* Увеличиваем счётчик разряда */
    raz = raz + 1;
  end
 
  /* Припысываем знак */
  curr_str = sign_of_val || curr_str;
  /* Делаем первую букву прописной */
  curr_str = upper(substring(curr_str FROM 1 FOR 1)) || substring(curr_str FROM 2);
 
  /* Флаг "показать название валюты" */
  IF (ShowCurrency = 1) then
    curr_str = curr_str || ' руб. ' || cents || ' коп.';
 
  suspend;
end;


CREATE OR ALTER PROCEDURE CUSTOMER_BALANCE (
    P_CUSTOMER_ID TYPE OF UID,
    FROM_DATE D_DATE = null)
RETURNS (
    RCUSTOMER_ID TYPE OF UID,
    RMONTH D_DATE,
    FDESCRIPTION D_VARCHAR500,
    PDESCRIPTION D_VARCHAR500,
    FSUMMA D_N15_2,
    PSUMMA D_N15_2,
    SUM_TYPE D_INTEGER)
AS
declare variable V_Units     D_N15_2;
declare variable V_Shift     D_Integer;
declare variable V_Type      D_Integer;
declare variable V_Calc_Type D_Integer;
declare variable V_Dem       D_Varchar5;
declare variable V_S         D_Varchar100;
begin
  RCUSTOMER_ID = P_CUSTOMER_ID;

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = -1;
  if (not FROM_DATE is null) then begin
    select
        sum(m.FEE)
      from MONTHLY_FEE m
      where m.CUSTOMER_ID = :P_CUSTOMER_ID
            and m.Month_Id < :FROM_DATE
    into :v_units;
    FSUMMA = coalesce(v_units, 0);
    select
        sum(m.FEE)
      from other_fee m
      where m.CUSTOMER_ID = :P_CUSTOMER_ID
            and m.Fee_Date < :FROM_DATE
    into :v_units;
    FSUMMA = FSUMMA + coalesce(v_units, 0);
    select
        sum(p.PAY_SUM)
      from payment p
      where p.CUSTOMER_ID = :P_CUSTOMER_ID
            and p.PAY_DATE < :FROM_DATE
    into :v_units;
    FSUMMA = FSUMMA - coalesce(v_units, 0);
    select
        sum(p.Bonus)
      from CUSTOMER_BONUSES p
      where p.CUSTOMER_ID = :P_CUSTOMER_ID
            and p.Bonus_Date < :FROM_DATE
    into :v_units;
    FSUMMA = FSUMMA - coalesce(v_units, 0);
    FDESCRIPTION = 'Сальдо на ' || cast(FROM_DATE as varchar(10));
    RMONTH = FROM_DATE;
    suspend;
  end
  else
    From_date = cast('0001-01-01' as date);

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = 0; -- услуга
  for select
          m.MONTH_ID
        , s.NAME
        , m.FEE
        , m.UNITS
        , s.DIMENSION
        , s.shift_months
        , s.Srv_Type_Id
        , s.CALC_TYPE
        from MONTHLY_FEE m
             inner join services s on (s.SERVICE_ID = m.SERVICE_ID)
        where m.CUSTOMER_ID = :P_CUSTOMER_ID
              and coalesce(m.FEE, 0) <> 0
              and m.MONTH_ID >= :FROM_DATE
        order by m.MONTH_ID
      into :RMONTH, :FDESCRIPTION, :FSUMMA, :v_units, :v_dem, :v_shift, :v_type, :v_CALC_TYPE
  do begin
    v_s = '';
    if (v_type = 0) then begin
      v_type = extract(month from dateadd(coalesce(:v_shift, 0) month to :RMONTH));
      select
          MNAME
        from MONTH_NAME
        where mID = :v_type
      into :v_s;
      if (v_CALC_TYPE = 3) then
        v_s = ' за ' || v_s;
      else
        v_s = v_s || ' за ' || cast(v_units as integer) || coalesce(' ' || v_dem, '');
    end
    else begin
      if (v_type = 2) then
        v_s = '';
      else
        v_s = v_units;
      if (not v_dem is null) then
        v_s = v_s || ' ' || coalesce(v_dem, '');
      v_s = v_s || '/' || RMONTH;
    end
    v_s = trim(v_s);
    if (v_s <> '') then
      FDESCRIPTION = substring(FDESCRIPTION || ' (' || v_s || ')' from 1 for 500);

    RMONTH = (RMONTH - extract(day from RMONTH) + 1);
    suspend;
  end

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = 1; -- платеж
  for select
          p.PAY_DATE
        , p.PAY_SUM + coalesce(p.Fine_Sum, 0)
        from payment p
        where p.CUSTOMER_ID = :P_CUSTOMER_ID
              and p.PAY_DATE >= :FROM_DATE
        order by p.PAY_DATE
      into :RMONTH, :PSUMMA
  do begin
    PDESCRIPTION = lpad(extract(day from RMONTH),2,'0') || '.' || lpad(extract(month from RMONTH),2,'0') || '.' || extract(year from RMONTH);
    RMONTH = (RMONTH - extract(day from RMONTH) + 1);
    suspend;
  end

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = 2; -- пеня
  for select
          p.Pay_Date
        , p.Fine_Sum
        from payment p
        where p.CUSTOMER_ID = :P_CUSTOMER_ID
              and (not p.Fine_Sum is null)
              and (p.Fine_Sum <> 0)
              and p.Pay_Date >= :FROM_DATE
        order by p.Pay_Date
      into :RMONTH, :FSUMMA
  do begin
    FDESCRIPTION = 'Пеня';
    RMONTH = (RMONTH - extract(day from RMONTH) + 1);
    suspend;
  end

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = 3; -- прочее
  for select
          m.Fee_Date
        , m.Fee_Name
        , m.FEE
        , m.In_Request
        from other_fee m
        where m.CUSTOMER_ID = :P_CUSTOMER_ID
              and m.FEE <> 0
              and m.Fee_Date >= :FROM_DATE
        order by m.Fee_Date
      into :RMONTH, :FDESCRIPTION, :FSUMMA, :V_S
  do begin
    RMONTH = (RMONTH - extract(day from RMONTH) + 1);
    if (not V_S is null) then
      FDESCRIPTION = FDESCRIPTION || ' / ' || V_S;
    suspend;
    V_S = null;
  end

  FSUMMA = null;
  FDESCRIPTION = null;
  PSUMMA = null;
  PDESCRIPTION = null;
  V_S = null;
  Sum_Type = 4; -- Бонусы
  for select
          p.Bonus_Date
        , coalesce(o.O_Name, 'Бонус')
        , p.Bonus
        from CUSTOMER_BONUSES p
             left outer join objects o on (o.O_Id = p.Bt_Id and
                   o.O_Type = 30)
        where p.CUSTOMER_ID = :P_CUSTOMER_ID
              and p.Bonus_Date >= :FROM_DATE
        order by p.Bonus_Date
      into :RMONTH, :PDESCRIPTION, :PSUMMA
  do begin
    RMONTH = (RMONTH - extract(day from RMONTH) + 1);
    suspend;
  end
end;


CREATE OR ALTER PROCEDURE CUSTOMER_CONTACTS_IU (
    CUSTOMER_ID INTEGER,
    CC_VALUE VARCHAR(255),
    CC_TYPE SMALLINT = 0,
    CC_NOTICE VARCHAR(1000) = null /* COLLATE UTF8 - default */,
    CC_NOTIFY SMALLINT = 1,
    CC_OLD VARCHAR(255) = null /* COLLATE UTF8 - default */)
AS
-- declare variable contDigit D_Varchar50;
begin
  if (not CC_OLD is null) then
    delete from Customer_Contacts
        where (Customer_Id = :Customer_Id)
              and (Cc_Value = :CC_OLD);

  CC_NOTIFY = coalesce(CC_NOTIFY, 0);

  if ((CC_TYPE < 2) and (position('@' in CC_VALUE) > 2)) then
    CC_TYPE = 2;

  /*
  if (CC_TYPE < 2) then begin
    -- если это телефон, то постараемся изебжать дублей
    -- удаляем все кроме цифр
    contDigit = reverse(ONLY_DIGITS(:CC_VALUE));
  end
  else
    contDigit = '';

  if (contDigit <> '') then
    update or insert into Customer_Contacts (Customer_Id, Cc_Value, Cc_Type, Cc_Notify, Cc_Notice, cc_val_reverse)
    values (:Customer_Id, :Cc_Value, :Cc_Type, :Cc_Notify, :Cc_Notice, :contDigit)
    matching (Customer_Id, cc_val_reverse);
  else
  */
  update or insert into Customer_Contacts (Customer_Id, Cc_Value, Cc_Type, Cc_Notify, Cc_Notice)
  values (:Customer_Id, :Cc_Value, :Cc_Type, :Cc_Notify, :Cc_Notice)
  matching (Customer_Id, Cc_Value);
end;


CREATE OR ALTER PROCEDURE CUSTOMER_DEBT_ADD (
    P_CUSTOMER_ID UID,
    P_SUM D_N15_2)
AS
begin
  update CUSTOMER C
  set C.DEBT_SUM = coalesce(C.DEBT_SUM,0) + coalesce(:P_SUM,0)
  where C.CUSTOMER_ID = :P_CUSTOMER_ID;
end;


CREATE OR ALTER PROCEDURE CUSTOMER_SERVICES_STATE (
    P_CUSTOMER_ID TYPE OF UID)
AS
declare variable v_state        d_varchar1000;
declare variable v_service      d_integer;
declare variable disact_serv_id d_integer;
declare variable disact_date    D_Date;
declare variable act_name       d_varchar1000;
declare variable disact_name    d_varchar1000;
declare variable full_state     d_varchar1000;
declare variable v_on_services  d_integer;
declare variable srv_state  d_integer;
begin
  FULL_STATE = '';
  V_ON_SERVICES = 0;

  for select
          s.SERVICE_ID
        , coalesce(s.SHORTNAME, s.Name) || '. '
        from SUBSCR_SERV ss
             inner join SERVICES s on (s.SERVICE_ID = ss.SERV_ID)
        where ss.CUSTOMER_ID = :P_CUSTOMER_ID
              and ss.STATE_SGN = 1
              and exists(select
                             sl.CHILD
                           from SERVICES_LINKS sl
                           where sl.CHILD = s.SERVICE_ID
                                 and sl.LINK_TYPE = 0)
        order by ss.State_Date desc
      into :V_SERVICE, :V_STATE
  do begin
    select first 1
        sh.DISACT_SERV_ID
      , act.NAME || '(' || extract(day from sh.DATE_FROM) || '/' || extract(month from sh.DATE_FROM) || '/' || extract(year from sh.DATE_FROM) || ')'
      , disact.NAME
      , sh.DATE_TO
      from SUBSCR_HIST sh
           left outer join SERVICES disact on (sh.DISACT_SERV_ID = disact.SERVICE_ID)
           left outer join SERVICES act on (sh.ACT_SERV_ID = act.SERVICE_ID)
      where sh.CUSTOMER_ID = :P_CUSTOMER_ID
            and sh.SERV_ID = :V_SERVICE
      order by DATE_FROM desc, sh.Subscr_Hist_Id desc
    into :DISACT_SERV_ID, :ACT_NAME, :DISACT_NAME, :disact_date;

    if ((DISACT_SERV_ID = -1) -- нет услуги отключения
        or
        (DISACT_SERV_ID = -2)) -- снятие автоблокировки
    then begin
      V_STATE = substring(V_STATE || ACT_NAME from 1 for 500);
      V_ON_SERVICES = 1;
    end
    else begin
      disact_date = dateadd(day, 1, disact_date);
      DISACT_NAME = DISACT_NAME || '(' || extract(day from disact_date) || '/' || extract(month from disact_date) || '/' || extract(year from disact_date) || ')';
      V_STATE = substring(V_STATE || DISACT_NAME from 1 for 500);
    end

    FULL_STATE = substring(FULL_STATE || V_STATE || ' ' from 1 for 500);
  end

  if (V_ON_SERVICES = 0) then
    ACT_NAME = 'Ф';
  else
    ACT_NAME = '';

  FULL_STATE = coalesce(FULL_STATE, '');
  /* если все отключено то выведем статус отключенных */
  if (FULL_STATE = '') then begin
    for select
            s.SERVICE_ID
          , coalesce(s.SHORTNAME, s.Name) || '. '
          from SUBSCR_SERV ss
               inner join SERVICES s on (s.SERVICE_ID = ss.SERV_ID)
          where ss.CUSTOMER_ID = :P_CUSTOMER_ID
                and ss.STATE_SGN = 0
                and exists(select
                               sl.CHILD
                             from SERVICES_LINKS sl
                             where sl.CHILD = s.SERVICE_ID
                                   and sl.LINK_TYPE = 0)
          order by ss.State_Date desc
        into :V_SERVICE, :V_STATE
    do begin
      select first 1
          sh.DISACT_SERV_ID
        , act.NAME || '(' || extract(day from sh.DATE_FROM) || '/' || extract(month from sh.DATE_FROM) || '/' || extract(year from sh.DATE_FROM) || ')'
        , disact.NAME
        , sh.DATE_TO
        from SUBSCR_HIST sh
             left outer join SERVICES disact on (sh.DISACT_SERV_ID = disact.SERVICE_ID)
             left outer join SERVICES act on (sh.ACT_SERV_ID = act.SERVICE_ID)
        where sh.CUSTOMER_ID = :P_CUSTOMER_ID
              and sh.SERV_ID = :V_SERVICE
        order by DATE_FROM desc, sh.Subscr_Hist_Id desc
      into :DISACT_SERV_ID, :ACT_NAME, :DISACT_NAME, :disact_date;

      if ((DISACT_SERV_ID = -1) -- нет услуги отключения
          or
          (DISACT_SERV_ID = -2)) -- снятие автоблокировки
      then begin
        V_STATE = substring(V_STATE || ACT_NAME from 1 for 500);
        V_ON_SERVICES = 1;
      end
      else begin
        disact_date = dateadd(day, 1, disact_date);
        DISACT_NAME = DISACT_NAME || '(' || extract(day from disact_date) || '/' || extract(month from disact_date) || '/' || extract(year from disact_date) || ')';
        V_STATE = substring(V_STATE || DISACT_NAME from 1 for 500);
      end

      FULL_STATE = substring(FULL_STATE || V_STATE || ' ' from 1 for 500);
    end
    ACT_NAME = 'Ф';
  end

  /* статус старых услуг*/
  FULL_STATE = coalesce(FULL_STATE, '');
  if (FULL_STATE = '') then begin
    V_ON_SERVICES = 0;
    for select
            s.SERVICE_ID
          , coalesce(s.SHORTNAME, s.Name) || '. '
          , ss.STATE_SGN
          from SUBSCR_SERV ss
               inner join SERVICES s on (s.SERVICE_ID = ss.SERV_ID)
          where ss.CUSTOMER_ID = :P_CUSTOMER_ID
                and not exists(select
                               sl.CHILD
                             from SERVICES_LINKS sl
                             where sl.CHILD = s.SERVICE_ID
                                   and sl.LINK_TYPE = 0)
          order by ss.State_Date desc
        into :V_SERVICE, :V_STATE, :srv_state
    do begin
      select first 1
          sh.DISACT_SERV_ID
        , act.NAME || '(' || extract(day from sh.DATE_FROM) || '/' || extract(month from sh.DATE_FROM) || '/' || extract(year from sh.DATE_FROM) || ')'
        , disact.NAME
        , sh.DATE_TO
        from SUBSCR_HIST sh
             left outer join SERVICES disact on (sh.DISACT_SERV_ID = disact.SERVICE_ID)
             left outer join SERVICES act on (sh.ACT_SERV_ID = act.SERVICE_ID)
        where sh.CUSTOMER_ID = :P_CUSTOMER_ID
              and sh.SERV_ID = :V_SERVICE
        order by DATE_FROM desc, sh.Subscr_Hist_Id desc
      into :DISACT_SERV_ID, :ACT_NAME, :DISACT_NAME, :disact_date;

      if ((DISACT_SERV_ID = -1) -- нет услуги отключения
          or
          (DISACT_SERV_ID = -2)) -- снятие автоблокировки
      then begin
        V_STATE = substring(V_STATE || ACT_NAME from 1 for 500);
        V_ON_SERVICES = V_ON_SERVICES + 1;
      end
      else begin
        disact_date = dateadd(day, 1, disact_date);
        DISACT_NAME = DISACT_NAME || '(' || extract(day from disact_date) || '/' || extract(month from disact_date) || '/' || extract(year from disact_date) || ')';
        V_STATE = substring(V_STATE || DISACT_NAME from 1 for 500);
        V_ON_SERVICES = V_ON_SERVICES + srv_state;
      end

      FULL_STATE = substring(FULL_STATE || V_STATE || ' ' from 1 for 500);
    end
    if (V_ON_SERVICES > 0) then begin
      V_ON_SERVICES = 1;
      ACT_NAME = '';
    end
    else begin
      V_ON_SERVICES = 0;
      ACT_NAME = 'Ф';
    end
  end

  update customer c
  set c.CUST_STATE_DESCR = :FULL_STATE,
      c.CUST_STATE = :V_ON_SERVICES,
      c.CUST_PROP_DESCR = :ACT_NAME
  where c.CUSTOMER_ID = :P_CUSTOMER_ID;
end;


CREATE OR ALTER PROCEDURE CUSTOMERS_SERVICES_STATE
AS
declare variable ID  type of UID;
begin
  for
    SELECT c.customer_id
      FROM customer c
      into :ID
  do
  execute procedure customer_services_state (:ID);
end;


CREATE OR ALTER PROCEDURE DAY_TARIF_FOR_SRV (
    BEGIN_MONTH D_DATE,
    FOR_SERVICE TYPE OF UID)
AS
DECLARE VARIABLE VTARIF d_N15_5;
DECLARE VARIABLE JTARIF d_N15_5;
DECLARE VARIABLE LD d_INTEGER;
DECLARE VARIABLE I d_INTEGER;
DECLARE VARIABLE T_DAY d_DATE;
declare variable shift d_integer;
DECLARE VARIABLE START_MONTH d_DATE;

BEGIN

    DELETE FROM days_tarif d where d.serv_id = :for_service;

    select s.shift_months from services s where s.service_id = :for_service
    into :shift;

    START_MONTH = dateadd(shift month to BEGIN_MONTH );

    -- кол-во дней в месяце
    ld  = extract(day from dateadd( -1 day to (dateadd(1 month to START_MONTH))));

    i = 0;
    WHILE (i < ld) DO BEGIN
          t_day = :START_MONTH + i;
          for
            select t.tarif_sum, t.tarif_sum_jur
              from tarif t inner join services s on (t.service_id = s.service_id)
              where s.srv_type_id = 0 and s.calc_type = 0
                AND :t_day BETWEEN t.date_from AND t.date_to
                and s.service_id = :for_service
            INTO :vtarif, :JTARIF
          do begin
            IF (vtarif IS NOT NULL)
            THEN vtarif = round(vtarif/ld,5);
            else vtarif = 0;
            IF (JTARIF IS NOT NULL)
            THEN JTARIF = round(vtarif/ld,5);
            else JTARIF = 0;

            INSERT INTO days_tarif VALUES (:for_service,:t_day,:vtarif, :JTARIF);
          end
          i = i+1;
    END


END;


CREATE OR ALTER PROCEDURE DECL_OF_NUM (
    NUM INTEGER,
    TITLE0 VARCHAR(100) = null,
    TITLE1 VARCHAR(100) = null,
    TITLE2 VARCHAR(100) = null)
RETURNS (
    RESULT VARCHAR(100))
AS
begin
  if (Title0 is null) then
    Title0 = 'рубль';
  if (Title1 is null) then
    Title1 = 'рубля';
  if (Title2 is null) then
    Title2 = 'рублей';
  RESULT = iif(mod(NUM, 100) > 4 and mod(NUM, 100) < 20 or mod(NUM, 10) >= 5, TITLE2, decode(mod(NUM, 10), 0, TITLE2, 1, TITLE0, 2, TITLE1, 3, TITLE1, 4, TITLE1));
  suspend;
end;


CREATE OR ALTER PROCEDURE DELETE_CUSTOMER (
    CID TYPE OF UID)
AS
--declare variable HOUSE_ID D_UID_NULL;
--declare variable FLAT D_Flat;
begin
--  Select ss.House_Id, ss.Flat_No CUSTOMER ss where ss.CUSTOMER_ID = :CID
--  into :HOUSE_ID, :FLAT;
--  UPDATE REQUEST ss set ss.House_Id = HOUSE_ID, ss.Flat_No = :FLAT, ss.Rq_Customer = null where ss.Rq_Customer = :CID;

  --DELETE FROM REQUEST ss where ss.Rq_Customer = :CID;
  DELETE FROM BILLING ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM EVENT_DETAIL ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTLETTER ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_ACCOUNTS ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_ATTRIBUTES ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_BONUSES ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_CONTACTS ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_DECODERS ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM CUSTOMER_FILES ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM EQUIPMENT_HISTORY ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM MESSAGES ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM MONTHLY_FEE ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM MONTHLY_FREEZE ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM OTHER_FEE ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM PAYMENT ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM PERSONAL_TARIF ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM PREPAY_DETAIL ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM RECOURSE ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM SINGLE_SERV ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM SUBSCR_HIST ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM SUBSCR_SERV ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM TV_LAN ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM DISCOUNT_FACTOR ss where ss.CUSTOMER_ID = :CID;  
  DELETE FROM CUSTOMER ss where ss.CUSTOMER_ID = :CID;
  DELETE FROM APPLIANCE where Own_Id  = :CID and Own_Type = 0;
end;


CREATE OR ALTER PROCEDURE DELETE_CUSTOMER_DECODER (
    DEC_ID UID,
    DECODER_STATE D_INTEGER,
    STB_STATE D_INTEGER = null,
    NOTICE D_NOTICE = null)
AS
declare variable DECODER_N type of D_DECODER;
declare variable STB_N     type of D_VARCHAR50;
begin
  if (DECODER_STATE is null) then
    DECODER_STATE = 1;

  if (STB_STATE is null) then
    STB_STATE = DECODER_STATE;

  decoder_n = null;
  stb_n = null;

  select
      decoder_n, stb_n
    from CUSTOMER_DECODERS
    where DEC_ID = :DEC_ID
  into :decoder_n, :stb_n;
  delete from CUSTOMER_DECODERS where DEC_ID = :DEC_ID;

  if (not decoder_n is null) then
    update EQUIPMENT_DVB
    set EQ_state = :DECODER_STATE,
        Notice = coalesce(Notice, '') || coalesce(' ' || :NOTICE, '')
    where EQ_n = :decoder_n;

  if (not stb_n is null) then
    update EQUIPMENT_DVB
    set EQ_state = :STB_STATE,
        Notice = coalesce(Notice, '') || coalesce(' ' || :NOTICE, '')
    where EQ_n = :stb_n;
end;


CREATE OR ALTER PROCEDURE DELETE_MONTH_PROC (
    P_MONTH D_DATE)
AS
begin
  -- установим на первое число месяца
  P_MONTH = P_MONTH - EXTRACT(DAY FROM P_MONTH) + 1;
  delete from MONTHLY_FEE M
   where M.MONTH_ID >= :P_MONTH;

  P_MONTH = DATEADD(-1 MONTH TO P_MONTH);
  UPDATE SETTINGS SET VAR_VALUE = extract( year from :P_MONTH ) || '-'|| extract( month from :P_MONTH ) || '-1'
  WHERE VAR_NAME = 'CURRENT_DATE';
END;


CREATE OR ALTER PROCEDURE DELETE_NODE (
    ID TYPE OF UID)
AS
begin
  if (not ID is null) then begin
    update request r
    set r.Node_Id = null
    where r.Node_Id = :ID;
    delete from House_Circuit n where n.House_Id = :ID;
    delete from Nodes_Attributes n where n.Node_Id = :ID;
    delete from nodes n where n.Node_Id = :ID;
    delete from APPLIANCE where Own_Id = :Id and Own_Type = 1;
  end
end;


CREATE OR ALTER PROCEDURE DELETE_OBJECT (
    OID TYPE OF UID)
AS
begin
  UPDATE OBJECTS SET O_DELETED = 1 WHERE (O_ID = :OID);
end;


CREATE OR ALTER PROCEDURE DELETE_SUBSCR_SERVICE (
    P_SUBSCR_SERV_ID TYPE OF UID)
AS
declare variable C_ID          type of UID;
declare variable business_type d_integer;
declare variable id            d_integer;

begin
  delete from SUBSCR_SERV ss
      where ss.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

  /*
  select
      ss.CUSTOMER_ID, s.service_id, s.business_type
    from SUBSCR_SERV Ss
         inner join services s on (s.service_id = ss.serv_id)
    where ss.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
  into :c_ID, :ID, :business_type;



  if (business_type >= 2) then begin
    execute procedure DIGITAL_EVENT(2, :C_ID, null, :ID, LOCALTIMESTAMP, null);
  end

  --EXECUTE PROCEDURE CUSTOMER_SERVICES_STATE(:C_ID);
  */
end;


CREATE OR ALTER PROCEDURE DIGITAL_EVENT (
    DTV_ACTION TYPE OF D_INTEGER,
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
begin
  /* Добавления подписки */
  if (dtv_action = 1) then
    execute procedure Digital_Event_Add(:Customer_Id, :Hardware_Id, :Service_Id, :Act_Date, :Device_Model_Id);
  else begin
    /* удаление подписки */
    if (dtv_action = 2) then
      execute procedure Digital_Event_Del(:Customer_Id, :Hardware_Id, :Service_Id, :Act_Date, :Device_Model_Id);
  end
end;


CREATE OR ALTER PROCEDURE DIGITAL_EVENT_ADD (
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
declare variable dtv_id     type of D_VARCHAR100;
declare variable ext_id     type of D_VARCHAR100;
declare variable date_from  type of D_DATETIME;
declare variable date_to    type of D_DATETIME;
declare variable days_count type of d_integer;
declare variable DTV_ACTION type of D_INTEGER;
declare variable CARD_N     type of D_DECODER;
declare variable J_Notice   type of D_VARCHAR1000;
begin

  DTV_ACTION = 1;
  if (act_date is null) then
    act_date = localtimestamp;
  else begin
    /* если проводим вчерашним числом, то в CAS передадим текущую дату */
    if (act_date < current_date) then
      act_date = localtimestamp;
  end

  for select
          s.external_id
        , sh.date_to
        , sh.Date_From
        from services s
             inner join subscr_hist sh on (sh.serv_id = s.service_id and
                   sh.customer_id = :customer_id)
        where s.business_type >= 2
              and (((current_date between sh.date_from and sh.date_to
                or sh.date_from > current_date) -- Еси подписка будущим числом, тоже передадим
              and :SERVICE_ID is null)
                or (s.service_id = :SERVICE_ID
              and :act_date between sh.date_from and sh.date_to))
      into :ext_id, :date_to, :date_from
  do begin
    for select
            substring(Str from 1 for 100)
          from Explode(',', :ext_id)
        into :dtv_id
    do begin
      dtv_id = trim(dtv_id);
      if (coalesce(dtv_id, '') <> '') then begin
        if (Date_From < act_date) then
          Date_From = act_date;
        -- расчитаем кол-во дней активации
        days_count = datediff(day from Date_From to date_to);
        -- если активация хоть на 1 день, то активируем
        if (days_count > 0) then begin
          if (days_count > 1000) then
            days_count = 999;

          for select
                  cd.decoder_n
                from customer_decoders cd
                where (cd.customer_id = :customer_id)
                      and ((cd.Decoder_N = :HARDWARE_ID
                      and ((not exists(select
                                           *
                                         from Decoder_Packets p
                                         where p.Decoder_N = :HARDWARE_ID))
                        or ((not(:HARDWARE_ID is null))
                      and (not :SERVICE_ID is null)))) -- смотрим если пакет конкретно под карту, то добавим
                        or (:HARDWARE_ID is null))
              into :CARD_N
          do begin
            J_Notice = 'CARD ' || coalesce(CARD_N, '-') || ', ' || coalesce(dtv_id, '-');
            insert into Journal (J_Notice)
            values (:J_Notice);

            insert into TQueue ("ACTION", DATETIME, HARDWARE_ID, CLASS_ID, DAYCOUNT)
            values (:dtv_action, :Date_From, :CARD_N, cast(:dtv_id as integer), :days_count);
          end
        end
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE DIGITAL_EVENT_DECODER (
    HARDWARE_ID TYPE OF D_DECODER,
    NEW_SRV_ID TYPE OF UID,
    OLD_SRV_ID TYPE OF UID)
AS
declare variable CUSTOMER_ID type of UID;
declare variable i           type of D_Integer;

begin
  i = -1;
  select
      customer_id
    from Customer_Decoders cd
    where cd.Decoder_N = :HARDWARE_ID
  into :CUSTOMER_ID;

  if (not NEW_SRV_ID is null) then begin
    select
        count(*)
      from Decoder_Packets p
      where p.Decoder_N = :HARDWARE_ID
            and p.Service_Id <> :NEW_SRV_ID
    into :i;

    if (i = 0) then
      execute procedure Digital_Event(2, :Customer_Id, :Hardware_Id, null, null, null);

    execute procedure Digital_Event(1, :Customer_Id, :Hardware_Id, :NEW_SRV_ID, null, null);
  end

  if (not OLD_SRV_ID is null) then begin
    if (i<>0) then
        execute procedure Digital_Event(2, :Customer_Id, :Hardware_Id, :OLD_SRV_ID, null, null);

    select
        count(*)
      from Decoder_Packets p
      where p.Decoder_N = :HARDWARE_ID
            and p.Service_Id <> :OLD_SRV_ID
    into :i;

    if (i = 0) then
      execute procedure Digital_Event(1, :Customer_Id, :Hardware_Id, null, null, null);

  end
end;


CREATE OR ALTER PROCEDURE DIGITAL_EVENT_DEL (
    CUSTOMER_ID TYPE OF UID,
    HARDWARE_ID TYPE OF D_DECODER,
    SERVICE_ID TYPE OF UID,
    ACT_DATE TYPE OF D_DATETIME,
    DEVICE_MODEL_ID TYPE OF D_DECODER)
AS
declare variable dtv_id       type of D_VARCHAR100;
declare variable ext_id       type of D_VARCHAR100;
declare variable DTV_ACTION   type of D_INTEGER;
declare variable CARD_N       type of D_DECODER;
declare variable CARD_PROCEED type of D_INTEGER;
begin
  DTV_ACTION = 2;

  if (act_date is null) then
    act_date = localtimestamp;
  else begin
    if (act_date < current_date) then
      act_date = localtimestamp;
  end

  if (HARDWARE_ID is null) then
    HARDWARE_ID = 'undef';

  /* люработана ли карта */
  CARD_PROCEED = 0;

  for select distinct
          cd.decoder_n
        from customer_decoders cd
        where (cd.customer_id = :customer_id)
              and ((cd.Decoder_N = :HARDWARE_ID)
                or ('undef' = :HARDWARE_ID))
      into :CARD_N
  do begin
    if (not SERVICE_ID is null) then begin
      for select distinct
              s.external_id
            from services s
                 inner join Subscr_Serv ss on (ss.Serv_Id = s.Service_Id)
            where s.business_type >= 2
                  and ss.Customer_Id = :CUSTOMER_ID
                  and (s.service_id = :SERVICE_ID)
          into :ext_id
      do begin
        for select
                substring(Str from 1 for 100)
              from Explode(',', :ext_id)
            into :dtv_id
        do begin
          dtv_id = trim(dtv_id);
          CARD_PROCEED = 1;
          if (coalesce(dtv_id, '') <> '') then begin
            insert into TQueue ("ACTION", HARDWARE_ID, DATETIME, CLASS_ID)
            values (:dtv_action, :CARD_N, :act_date, cast(:dtv_id as integer));
          end
        end
      end
    end
    else begin
      /* если услуга не указана удалим все цифровые услуги */
      for select distinct
              s.external_id
            from services s
            where s.business_type >= 2
                  and (coalesce(s.external_id, '') <> '')
          into :ext_id
      do begin
        for select
                substring(Str from 1 for 100)
              from Explode(',', :ext_id)
            into :dtv_id
        do begin
          dtv_id = trim(dtv_id);
          CARD_PROCEED = 1;
          if (coalesce(dtv_id, '') <> '') then begin
            insert into TQueue ("ACTION", HARDWARE_ID, DATETIME, CLASS_ID)
            values (:dtv_action, :CARD_N, :act_date, cast(:dtv_id as integer));
          end
        end
      end
    end
  end

  /* если карточка была удалена, то она не обработана удалим все подписки с этой карты */
  if ((CARD_PROCEED = 0) and (HARDWARE_ID <> 'undef')) then begin
    for select distinct
            s.external_id
          from services s
          where s.business_type >= 2
                and (coalesce(s.external_id, '') <> '')
        into :ext_id
    do begin
      for select
              substring(Str from 1 for 100)
            from Explode(',', :ext_id)
          into :dtv_id
      do begin
        dtv_id = trim(dtv_id);
        if (coalesce(dtv_id, '') <> '') then begin
          insert into TQueue ("ACTION", HARDWARE_ID, DATETIME, CLASS_ID)
          values (:dtv_action, :HARDWARE_ID, :act_date, cast(:dtv_id as integer));
        end
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE DISCOUNT_IU (
    DISCOUNT_ID TYPE OF COLUMN DISCOUNT_FACTOR.DISCOUNT_ID,
    CUSTOMER_ID TYPE OF COLUMN DISCOUNT_FACTOR.CUSTOMER_ID,
    DATE_FROM TYPE OF COLUMN DISCOUNT_FACTOR.DATE_FROM,
    DATE_TO TYPE OF COLUMN DISCOUNT_FACTOR.DATE_TO,
    FACTOR_VALUE TYPE OF COLUMN DISCOUNT_FACTOR.FACTOR_VALUE,
    SERV_ID TYPE OF COLUMN DISCOUNT_FACTOR.SERV_ID,
    SRV_TYPE TYPE OF COLUMN DISCOUNT_FACTOR.SRV_TYPE,
    NOTICE TYPE OF COLUMN DISCOUNT_FACTOR.NOTICE)
AS
declare variable Id type of Uid;
begin
  if (not Factor_Value is null) then begin
    Id = null;
    select first 1
        f.Discount_Id
      from DISCOUNT_FACTOR F
      where f.CUSTOMER_ID = :CUSTOMER_ID
            and f.serv_id = :serv_id
            and f.srv_type = :srv_type
            and (f.discount_id <> coalesce(:discount_id, -1))
            and ((F.DATE_FROM between :DATE_FROM and :DATE_TO)
              or (F.Date_To between :DATE_FROM and :DATE_TO))
    into :Id;

    if (id is null) then begin
      if (DISCOUNT_ID is null) then
        DISCOUNT_ID = gen_id(gen_operations_uid, 1);

      update or insert into Discount_Factor (Discount_Id, Customer_Id, Date_From, Date_To, Factor_Value, Serv_Id, Srv_Type, Notice)
      values (:Discount_Id, :Customer_Id, :Date_From, :Date_To, :Factor_Value, :Serv_Id, :Srv_Type, :Notice)
      matching (Discount_Id);
    end
    else
      exception E_TARIF_EXISTS;
  end
end;


CREATE OR ALTER PROCEDURE DUBLICATE_REQUEST (
    FROM_REQUEST D_INTEGER,
    FOR_CUSTOMER D_INTEGER,
    FOR_NODE D_INTEGER = 0)
RETURNS (
    REQUEST_ID D_INTEGER)
AS
declare variable Rq_Type      D_Integer;
declare variable Rq_Content   D_NOTICE;
declare variable Rq_Notice    D_NOTICE;
declare variable Rq_Plan_Date D_Date;
declare variable Rq_Time_From D_Time;
declare variable Rq_Time_To   D_Time;
declare variable House_Id     D_Integer;
declare variable Flat_No      D_Flat;
declare variable Rqtl_Id      D_Integer;
declare variable Node_Id      D_Integer;
declare variable Add_Info     D_Varchar255;
begin
  if (FOR_NODE is null) then
    FOR_NODE = 0;

  select
      RQ_TYPE, RQ_CONTENT, RQ_PLAN_DATE, RQ_TIME_FROM, RQ_TIME_TO, RQTL_ID, ADD_INFO, RQ_NOTICE
    from REQUEST r
    where r.rq_id = :from_request
  into :RQ_TYPE, :RQ_CONTENT, :RQ_PLAN_DATE, :RQ_TIME_FROM, :RQ_TIME_TO, :RQTL_ID, :ADD_INFO, :RQ_NOTICE;

  select
      HOUSE_ID, FLAT_NO
    from customer c
    where c.customer_id = :for_customer
  into :HOUSE_ID, :FLAT_NO;

  node_id = null;
  if (FOR_NODE = 1) then begin
    -- прверим привязана ли квартира к узлу
    select
        f.Node_Id
      from node_flats f
      where f.House_Id = :house_id
            and f.Flat_No = :flat_no
    into :node_id;
    if (node_id is null) then
      node_id = 0;
  end
  else
    NODE_ID = 1; -- узел нам не нужен

  if (node_id <> 0) then begin
    -- если узел нашли или он нам не нужен
    REQUEST_ID = gen_id(gen_request, 1);

    if (FOR_NODE = 0) then begin
      insert into REQUEST (RQ_ID, RQ_TYPE, RQ_CUSTOMER, RQ_CONTENT, RQ_PLAN_DATE, RQ_TIME_FROM, RQ_TIME_TO, HOUSE_ID, FLAT_NO, RQTL_ID, ADD_INFO, RQ_NOTICE, PARENT_RQ)
      values (:REQUEST_ID, :RQ_TYPE, :FOR_CUSTOMER, :RQ_CONTENT, :RQ_PLAN_DATE, :RQ_TIME_FROM, :RQ_TIME_TO, :HOUSE_ID, :FLAT_NO, :RQTL_ID, :ADD_INFO, :RQ_NOTICE, :from_request);
    end
    else begin
      insert into REQUEST (RQ_ID, RQ_TYPE, NODE_ID, RQ_CONTENT, RQ_PLAN_DATE, RQ_TIME_FROM, RQ_TIME_TO, HOUSE_ID, FLAT_NO, RQTL_ID, ADD_INFO, RQ_NOTICE, PARENT_RQ)
      values (:REQUEST_ID, :RQ_TYPE, :NODE_ID, :RQ_CONTENT, :RQ_PLAN_DATE, :RQ_TIME_FROM, :RQ_TIME_TO, :HOUSE_ID, :FLAT_NO, :RQTL_ID, :ADD_INFO, :RQ_NOTICE, :from_request);
    end

    insert into REQUEST_WORKS (RQ_ID, W_ID, W_TIME, W_QUANT, W_COST, NOTICE)
    select
        :REQUEST_ID, W_ID, W_TIME, W_QUANT, W_COST, NOTICE
      from REQUEST_WORKS rw
      where rw.rq_id = :from_request;

    insert into Request_Materials (Rq_Id, M_Id, Wh_Id, Rm_Quant, Rm_Cost, Rm_Notice, NOT_CALC)
    select
        :REQUEST_ID, M_Id, Wh_Id, Rm_Quant, Rm_Cost, Rm_Notice, NOT_CALC
      from Request_Materials rw
      where rw.rq_id = :from_request;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE EPG_ADD (
    CH_ID TYPE OF UID,
    TITLE TYPE OF D_VARCHAR255,
    UTC_START TYPE OF D_TIMESTAMP,
    UTC_STOP TYPE OF D_TIMESTAMP,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255)
AS
declare variable Duration D_Integer;
begin
  Duration = datediff(minute, Utc_Start, Utc_Stop);

  /*
-- declare variable SD       D_TIMESTAMP;
  SD = null;
  select
      E.DATE_START
    from EPG E
    where E.CH_ID = :CH_ID
          and :DATE_START between E.DATE_START and E.DATE_STOP
  into :SD;

  if (not SD is null) then begin
    update EPG
    set DATE_STOP = :DATE_START
    where CH_ID = :CH_ID
          and DATE_START = :SD;
  end

  select
      E.DATE_START
    from EPG E
    where E.CH_ID = :CH_ID
          and :DATE_STOP between E.DATE_START and E.DATE_STOP
  into :SD;

  if (not SD is null) then begin
    update EPG
    set DATE_START = :DATE_STOP
    where CH_ID = :CH_ID
          and DATE_START = :SD;
  end
  */
  insert into Epg (Ch_Id, Date_Start, Title, Duration, Date_Stop, Description, Genres, Dvbgenres, Minage, Create_Year, Actors, Directed, Country, Utc_Start, Utc_Stop)
  values (:Ch_Id, :Date_Start, :Title, :Duration, :Date_Stop, :Description, :Genres, :Dvbgenres, :Minage, :Create_Year, :Actors, :Directed, :Country, :Utc_Start, :Utc_Stop);
end;


CREATE OR ALTER PROCEDURE EPG_ADD_BY_SC (
    SOURCE_ID TYPE OF UID,
    EPG_CODE TYPE OF D_VARCHAR100,
    TITLE TYPE OF D_VARCHAR255,
    UTC_START TYPE OF D_TIMESTAMP,
    UTC_STOP TYPE OF D_TIMESTAMP,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255)
AS
declare variable CH_ID UID;
begin
  for select
          Ch_Id
        from Epg_Mapping
        where Epg_Id = :Source_Id
              and Epg_Code = :Epg_Code
      into :Ch_Id
  do begin
    execute procedure Epg_Add(:Ch_Id, :Title, :Utc_Start, :Utc_Stop, :Date_Start, :Date_Stop, :Description, :Genres, :Dvbgenres, :Minage, :Create_Year, :Actors, :Directed, :Country);
  end
end;


CREATE OR ALTER PROCEDURE EQUIPMENT_UPD (
    EQ_ID TYPE OF UID,
    EQ_N TYPE OF D_DECODER,
    EQ_TYPE TYPE OF D_INTEGER,
    EQ_STATE TYPE OF D_INTEGER,
    EQ_MAN TYPE OF D_INTEGER,
    NOTICE TYPE OF D_NOTICE,
    TEXT_ENCODE TYPE OF D_VARCHAR5)
AS
begin
  update EQUIPMENT_DVB
  set EQ_STATE = :EQ_STATE,
      EQ_TYPE = :EQ_TYPE,
      EQ_MAN = :EQ_MAN,
      NOTICE = :NOTICE,
      TEXT_ENCODE = :TEXT_ENCODE
  where (EQ_ID = :EQ_ID);

  if (EQ_STATE <> 2) then begin
    delete from CUSTOMER_DECODERS
    where DECODER_N = :EQ_N;

    update CUSTOMER_DECODERS
    set stb_n = null
    where stb_n = :EQ_N;
  end
end;


CREATE OR ALTER PROCEDURE EXPLODE (
    SEPARATOR D_CHAR1,
    A_VALUE D_VARCHAR1000)
RETURNS (
    STR D_VARCHAR1000)
AS
declare variable i d_integer;
declare variable j d_integer;
declare variable d d_char1;
begin

  j = CHAR_LENGTH(a_value);
  i = 1;
  STR = '';
  while (i <= j) do begin
    d = substring(a_value FROM i FOR 1);
    IF (d <>  separator)
    then STR = str ||d;
    else begin
      suspend;
      STR = '';
    end
    i = i + 1;
  end
  suspend;

end;


CREATE OR ALTER PROCEDURE EXPLODE_NO_EMPTY (
    SEPARATOR D_CHAR1,
    A_VALUE D_VARCHAR2000)
RETURNS (
    STR D_VARCHAR2000)
AS
declare variable i d_integer;
declare variable j d_integer;
declare variable d d_char1;
begin

  j = CHAR_LENGTH(a_value);
  i = 1;
  STR = '';
  while (i <= j) do begin
    d = substring(a_value FROM i FOR 1);
    IF (d <>  separator)
    then STR = str ||d;
    else begin
      STR = TRIM(STR);
      if (STR <> '') then suspend;
      STR = '';
    end
    i = i + 1;
  end
  STR = TRIM(STR);
  if (STR <> '') then suspend;

end;


CREATE OR ALTER PROCEDURE EXTRACT_ALL_DIGITS (
    A_VALUE D_VARCHAR255)
RETURNS (
    DIGITS D_VARCHAR255)
AS
declare variable i d_integer;
declare variable j d_integer;
declare variable d d_char1;
begin

  j = CHAR_LENGTH(a_value);
  i = 1;
  DIGITS = '';
  while (i <= j) do begin
    d = substring(a_value FROM i FOR 1);
    IF (d BETWEEN '0' AND '9')
    then DIGITS = DIGITS ||d;
    i = i + 1;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE EXTRACT_NUMBER (
    A_VALUE D_VARCHAR255)
RETURNS (
    RESULT D_VARCHAR255)
AS
declare variable I d_integer;
declare variable J d_integer;
declare variable DIGITS D_VARCHAR255;
begin
  IF (a_value IS NULL) then begin
    suspend;
    exit;
  end

  a_value = trim(a_value);
  IF (a_value IS NULL OR char_length(a_value) = 0) then begin
    suspend;
    exit;
  end

  i = 0;
  begin
    RESULT = cast(a_value as integer);
    when any do i = 1;
  end

  if (i = 0)
  then begin
    suspend;
    exit;
  end

  j = CHAR_LENGTH(a_value);
  digits = '';
  while (i <= j) do begin
    IF (substring(a_value FROM i FOR 1) BETWEEN '0' AND '9'
     OR (i =1 AND substring(a_value FROM 1 FOR 1) IN ('-', '+')
       AND CHAR_LENGTH(a_value) > 1 ))
    then digits = digits ||substring(a_value FROM i FOR 1);
    else Break;
    i = i + 1;
  end

  if (digits is null) then begin
    suspend;
    exit;
  end
  if (digits IN ('-', '+', '')) then begin
    suspend;
    exit;
  end

  result = digits;
  suspend;
end;


CREATE OR ALTER PROCEDURE FIX_PORT_CONNECT
AS
declare variable CId  integer;
declare variable Port varchar(12);
declare variable EId  integer;
begin
  for select
          l.Customer_Id
        , l.Port
        , l.Eq_Id
        from Tv_Lan l
        where not((l.Port is null)
                or (l.Eq_Id is null))
      into :cid, :Port, :eid
  do begin
    update or insert into Port (Eid, Port, P_State, Con, Con_Id)
    values (:Eid, :Port, 1, 1, :CId)
    matching (Eid, Port);
  end
end;


CREATE OR ALTER PROCEDURE FORMAT_DATE (
    A_DATE DATE = current_date,
    FORMAT VARCHAR(1000) = null,
    LONG_DAY_NAMES VARCHAR(100) = null,
    SHORT_DAY_NAMES VARCHAR(50) = null,
    LONG_MONTH_NAMES VARCHAR(200) = null,
    SHORT_MONTH_NAMES VARCHAR(200) = null)
RETURNS (
    RESULT VARCHAR(1000))
AS
declare variable D_Year  smallint;
declare variable D_Month smallint;
declare variable D_Day   smallint;
declare variable M       smallint;
declare variable D       smallint;
declare variable L       smallint;
declare variable S       smallint;
declare variable L_Month varchar(15);
declare variable S_Month varchar(10);
declare variable L_Day   varchar(15);
declare variable S_Day   varchar(10);
begin
  if (Long_Day_Names is null) then
    Long_Day_Names = 'понедельник,вторник,среда,четверг,пятница,суббота,воскресенье';
  if (Short_Day_Names is null) then
    Short_Day_Names = 'пн,вт,ср,чт,пт,сб,вс';
  if (Long_Month_Names is null) then
    Long_Month_Names = 'января,февраля,марта,апреля,мая,июня,июля,августа,сентября,октября,ноября,декабря';
  if (Short_Month_Names is null) then
    Short_Month_Names = 'янв,фев,мар,апр,мая,июн,июл,авг,сен,окт,ноя,дек';
  if (Format is null) then
    Format = 'DD.MM.YYYY';

  if (A_DATE is null) then
    RESULT = null;
  else begin
    D_YEAR = extract(year from A_DATE);
    D_MONTH = extract(month from A_DATE);
    D_DAY = extract(day from A_DATE);
    RESULT = FORMAT;

    if (FORMAT is null) then
      RESULT = D_DAY || '.' || lpad(cast(D_MONTH as varchar(2)), 2, '0') || '.' || D_YEAR;
    else begin
      RESULT = replace(replace(RESULT, 'YYYY', D_YEAR), 'YY', mod(extract(year from current_date), 100));
      S_MONTH = '';
      L_MONTH = '';
      if (RESULT like '%MMM%') then begin
        M = D_MONTH;
        while (M > 0) do begin
          L = position(',', LONG_MONTH_NAMES);
          S = position(',', SHORT_MONTH_NAMES);
          if (M = 1) then begin
            L_MONTH = substring(LONG_MONTH_NAMES from 1 for L - 1);
            S_MONTH = substring(SHORT_MONTH_NAMES from 1 for S - 1);
          end
          else begin
            LONG_MONTH_NAMES = substring(LONG_MONTH_NAMES from L + 1);
            SHORT_MONTH_NAMES = substring(SHORT_MONTH_NAMES from S + 1);
          end
          M = M - 1;
        end
        RESULT = replace(replace(RESULT, 'MMMM', coalesce(L_MONTH, '')), 'MMM', coalesce(S_MONTH, ''));
      end
      if (RESULT like '%DDD%') then begin
        D = coalesce(nullif(extract(weekday from A_DATE), 0), 7);
        while (D > 0) do begin
          L = position(',', LONG_DAY_NAMES);
          S = position(',', SHORT_DAY_NAMES);
          if (D = 1) then begin
            L_DAY = substring(LONG_DAY_NAMES from 1 for L - 1);
            S_DAY = substring(SHORT_DAY_NAMES from 1 for S - 1);
          end
          else begin
            LONG_DAY_NAMES = substring(LONG_DAY_NAMES from L + 1);
            SHORT_DAY_NAMES = substring(SHORT_DAY_NAMES from S + 1);
          end
          D = D - 1;
        end
        RESULT = replace(replace(RESULT, 'DDDD', coalesce(L_DAY, '')), 'DDD', coalesce(S_DAY, ''));
      end
      RESULT = replace(RESULT, 'MM', lpad(cast(D_MONTH as varchar(2)), 2, '0'));
      RESULT = replace(RESULT, 'M', D_MONTH);
      RESULT = replace(RESULT, 'DD', lpad(cast(D_DAY as varchar(2)), 2, '0'));
      RESULT = replace(RESULT, 'D', D_DAY);
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE FORMAT_MAC (
    AMAC D_MAC)
RETURNS (
    MAC D_MAC)
AS
declare variable i      d_integer;
declare variable j      d_integer;
declare variable d      d_char1;
declare variable DIGITS D_MAC;
begin
  aMAC = upper(aMAC);
  MAC = null;
  j = char_length(aMAC);
  i = 1;
  DIGITS = '';
  while (i <= j) do begin
    d = substring(aMAC from i for 1);
    if ((d between '0' and '9')
        or
        (d between 'A' and 'F')) then
      DIGITS = DIGITS || d;
    i = i + 1;
  end
  if (char_length(DIGITS) = 12) then begin
    MAC = substring(DIGITS from 1 for 2) || ':';
    MAC = MAC || substring(DIGITS from 3 for 2) || ':';
    MAC = MAC || substring(DIGITS from 5 for 2) || ':';
    MAC = MAC || substring(DIGITS from 7 for 2) || ':';
    MAC = MAC || substring(DIGITS from 9 for 2) || ':';
    MAC = MAC || substring(DIGITS from 11 for 2);
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE FREELANEQUIPMENT (
    CUSTOMER_ID TYPE OF UID,
    UNIT_ID D_INTEGER)
AS
DECLARE VARIABLE C_ID  D_INTEGER;
DECLARE VARIABLE E_ID  D_INTEGER;
DECLARE VARIABLE H_ID  D_INTEGER;
DECLARE VARIABLE EH_ID D_INTEGER;
DECLARE VARIABLE FLAT  D_FLAT;
DECLARE VARIABLE PLACE D_VARCHAR20;
DECLARE VARIABLE PORT  D_INTEGER;

DECLARE VARIABLE NEW_IP d_ip;
DECLARE VARIABLE NEW_HOUSE D_INTEGER;
BEGIN

  /* получим дефолтные настройки для обборудования */
  select cast(VAR_VALUE as Integer) from SETTINGS where VAR_NAME = 'MODEM_NEW_HOUSE'
  into :NEW_HOUSE;
  select VAR_VALUE from SETTINGS where VAR_NAME = 'MODEM_NEW_IP'
  into :NEW_IP;

  /* Выборка абонента или по его ID или по ID биллинга */
  if (CUSTOMER_ID is null)
  then
    select c.customer_id, c.house_id, c.flat_no
      from customer c inner join billing b on (c.customer_id = b.customer_id) where b.unit_id = :UNIT_ID
    into :C_ID, :H_ID, :FLAT;
  else
    select c.customer_id, c.house_id, c.flat_no
      from customer c where c.customer_id = :CUSTOMER_ID
    into :C_ID, :H_ID, :FLAT;

  for
    select l.eq_id, l.port, e.house_id, e.place
    from equipment e
      inner join tv_lan l on (e.eid = l.eq_id)
      where l.customer_id = :C_ID
    into :E_ID, :PORT, :EH_ID, :PLACE
   do begin
     if ((Port is null)
        and (EH_ID = H_ID)
        and (FLAT = PLACE))
     then begin
       Update equipment e
       set
         e.house_id = :NEW_HOUSE,
         e.ip = :NEW_IP,
         e.place = null,
         e.notice  = 'на проверку' || coalesce(e.notice,'')
       where e.eid = :E_ID;
     end
  end
  delete from tv_lan t where t.customer_id = :C_ID;

end;


CREATE OR ALTER PROCEDURE FULL_RECALC_CUSTOMER (
    P_CUSTOMER_ID TYPE OF UID,
    P_FROM_DATE D_DATE = null)
AS
declare variable F_MONTH     D_DATE;
declare variable P_END_MONTH D_DATE;
declare variable MIN_S       D_INTEGER;
declare variable MAX_S       D_INTEGER;
declare variable IGNOR       D_VARCHAR10;
declare variable I           D_INTEGER;
declare variable inStrict    D_IBOOLEAN;
begin
  select
      cast(s.Var_Value as integer)
    from settings s
    where s.Var_Name = 'STRICT_MODE'
  into :inStrict;
  inStrict = coalesce(inStrict, 1);
  -- проверим в строгом режиме или нет
  if (inStrict = 0) then begin

    -- если указано с какой даты считать возьмем ее иначе с начала действия договора
    if (not P_FROM_DATE is null) then begin
      F_MONTH = Month_First_Day(:P_FROM_DATE);
      -- удалим все предидущие расчеты
      delete from MONTHLY_FEE M
        where M.CUSTOMER_ID = :P_CUSTOMER_ID
          and m.Month_Id >= :F_MONTH;
    end
    else begin
      -- удалим все предидущие расчеты
      delete from MONTHLY_FEE M
        where M.CUSTOMER_ID = :P_CUSTOMER_ID;

      -- определим дату начала расчетов (дату договора)
      IGNOR = null;
      F_MONTH = null;

      select
          VAR_VALUE
        from SETTINGS S
        where S.VAR_NAME = 'IGNORE_CONTRACT'
      into :IGNOR;

      if (IGNOR is null) then
        IGNOR = '0';

      if (IGNOR <> '1') then
        select
            CONTRACT_DATE
          from CUSTOMER C
          where C.CUSTOMER_ID = :P_CUSTOMER_ID
        into :F_MONTH;

      if (F_MONTH is null) then begin
        -- найдем минамальную дату пересчета абонента
        select
            min(SH.DATE_FROM)
          from SUBSCR_HIST SH
          where SH.CUSTOMER_ID = :P_CUSTOMER_ID
        into :F_MONTH;

        if (F_MONTH is null) then
          F_MONTH = current_date;

        select
            min(SH.SERV_DATE)
          from SINGLE_SERV SH
          where SH.CUSTOMER_ID = :P_CUSTOMER_ID
        into :P_END_MONTH;

        if (P_END_MONTH is null) then
          P_END_MONTH = current_date;
        if (P_END_MONTH < F_MONTH) then
          F_MONTH = P_END_MONTH;

        select
            min(SH.FEE_DATE)
          from OTHER_FEE SH
          where SH.CUSTOMER_ID = :P_CUSTOMER_ID
        into :P_END_MONTH;

        if (P_END_MONTH is null) then
          P_END_MONTH = current_date;
        if (P_END_MONTH < F_MONTH) then
          F_MONTH = P_END_MONTH;
      end

      F_MONTH = F_MONTH - extract(day from F_MONTH) + 1;
    end
  end

  -- определим текущий расчетный период
  select
      cast(VAR_VALUE as date)
    from SETTINGS S
    where S.VAR_NAME = 'CURRENT_DATE'
  into :P_END_MONTH;

  P_END_MONTH = Month_First_Day(:P_END_MONTH);

  if (inStrict = 1) then begin
    -- если строгий режим, то пересчет с текущей даты
    F_MONTH = P_END_MONTH;
  end

  -- учтем смещение месяцев, если абонплата насчитывается на перед
  MIN_S = null;
  MAX_S = null;
  select
      min(S.SHIFT_MONTHS)
    , max(S.SHIFT_MONTHS)
    from SERVICES S
         inner join SUBSCR_SERV SS on (S.SERVICE_ID = SS.SERV_ID)
    where SS.CUSTOMER_ID = :P_CUSTOMER_ID
  into :MIN_S, :MAX_S;

  MIN_S = coalesce(MIN_S, 0);
  MAX_S = coalesce(MAX_S, 0);

  if (MAX_S > 0) then
    F_MONTH = dateadd((-1 * MAX_S) month to F_MONTH);

  if (MIN_S < 0) then begin
    -- попытка просчитать услуги с постоплатой
    -- если нет подключенных услуг, то расчитаем абонента наперед
    select
        count(*)
      from SUBSCR_HIST S
      where S.CUSTOMER_ID = :P_CUSTOMER_ID
            and S.DATE_TO > dateadd(1 month to :P_END_MONTH)
    into :I;

    if (I = 0) then
      P_END_MONTH = dateadd(-1 * MIN_S month to P_END_MONTH);
  end

  while (F_MONTH <= P_END_MONTH) do begin
    execute procedure CLOSE_MONTH_PROC(:F_MONTH, :P_CUSTOMER_ID);
    F_MONTH = dateadd(1 month to F_MONTH);
  end

  execute procedure RECALCCUSTOMERDEBT(:P_CUSTOMER_ID);
  execute procedure CHECK_FOR_UNBLOCK(:P_CUSTOMER_ID);
end;


CREATE OR ALTER PROCEDURE GEN_PASSWORD (
    MIN_LENGTH SMALLINT = 8,
    MAX_LENGTH SMALLINT = 10)
RETURNS (
    PWD VARCHAR(100))
AS
declare variable P_LENGTH           smallint; -- длина пароля
declare variable DICE               smallint; -- "игральная кость" — случайное число
declare variable LOWER_CHARS        char(25) = 'abcdefghijkmnopqrstuvwxyz'; -- строчные буквы. Запрещённые символы: l (в большинстве шрифтов похож на 1 и заглавную I)
declare variable LOWER_CHARS_CHANCE smallint = 50; -- шанс на выпадение строчной буквы
declare variable UPPER_CHARS        char(24) = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; -- заглавные буквы. Запрещённые символы: I (в большинстве шрифтов похож на 1 и строчную l), O (похож на ноль)
declare variable UPPER_CHARS_CHANCE smallint = 35; -- шанс на выпадение заглавной буквы
declare variable DIGITS             char(8) = '23456789'; -- цифры. Запрещённые символы: 0 (похож на букву O), 1 (похожа на заглавную I и строчную l)
declare variable DIGITS_CHANCE      smallint = 20; -- шанс на выпадение цифры
declare variable ADD_CHARS          char(11) = '$~+-_?!#@^&'; -- специальные символы
declare variable ADD_CHARS_CHANCE   smallint = 15; -- шанс на выпадение специального символа
begin
  /* в пароле должно быть не менее 6 символов */
  if (MIN_LENGTH is null
      or
      MIN_LENGTH < 6) then
    MIN_LENGTH = 6;
  if (MIN_LENGTH > 100) then
    MIN_LENGTH = 100;
  if (MAX_LENGTH is null
      or
      MAX_LENGTH < MIN_LENGTH) then
    MAX_LENGTH = MIN_LENGTH;
  if (MAX_LENGTH > 100) then
    MAX_LENGTH = 100;
  if (MIN_LENGTH = MAX_LENGTH) then
    P_LENGTH = MAX_LENGTH;
  else
    P_LENGTH = MAX_LENGTH - trunc(rand() * (MAX_LENGTH - MIN_LENGTH + 1));
  PWD = '';
  while (P_LENGTH > 0) do begin
    DICE = trunc(rand() * (LOWER_CHARS_CHANCE + UPPER_CHARS_CHANCE + DIGITS_CHANCE + ADD_CHARS_CHANCE));
    if (DICE < LOWER_CHARS_CHANCE) then begin
      PWD = PWD || substring(LOWER_CHARS from 1 + trunc(rand() * char_length(LOWER_CHARS)) for 1);
      LOWER_CHARS_CHANCE = LOWER_CHARS_CHANCE - 5;
      if (LOWER_CHARS_CHANCE <= 0) then
        LOWER_CHARS_CHANCE = 1;
      UPPER_CHARS_CHANCE = UPPER_CHARS_CHANCE + 4;
      DIGITS_CHANCE = DIGITS_CHANCE + 5;
      ADD_CHARS_CHANCE = ADD_CHARS_CHANCE + 2;
    end
    else
    if (DICE < LOWER_CHARS_CHANCE + UPPER_CHARS_CHANCE) then begin
      PWD = PWD || substring(UPPER_CHARS from 1 + trunc(rand() * char_length(UPPER_CHARS)) for 1);
      LOWER_CHARS_CHANCE = LOWER_CHARS_CHANCE + 5;
      UPPER_CHARS_CHANCE = UPPER_CHARS_CHANCE - 5;
      if (UPPER_CHARS_CHANCE <= 0) then
        UPPER_CHARS_CHANCE = 1;
      DIGITS_CHANCE = DIGITS_CHANCE + 5;
      ADD_CHARS_CHANCE = ADD_CHARS_CHANCE + 2;
    end
    else
    if (DICE < LOWER_CHARS_CHANCE + UPPER_CHARS_CHANCE + DIGITS_CHANCE) then begin
      PWD = PWD || substring(DIGITS from 1 + trunc(rand() * char_length(DIGITS)) for 1);
      LOWER_CHARS_CHANCE = LOWER_CHARS_CHANCE + 5;
      UPPER_CHARS_CHANCE = UPPER_CHARS_CHANCE + 4;
      DIGITS_CHANCE = DIGITS_CHANCE - 5;
      if (DIGITS_CHANCE <= 0) then
        DIGITS_CHANCE = 1;
      ADD_CHARS_CHANCE = ADD_CHARS_CHANCE + 2;
    end
    else begin
      PWD = PWD || substring(ADD_CHARS from 1 + trunc(rand() * char_length(ADD_CHARS)) for 1);
      LOWER_CHARS_CHANCE = LOWER_CHARS_CHANCE + 5;
      UPPER_CHARS_CHANCE = UPPER_CHARS_CHANCE + 4;
      DIGITS_CHANCE = DIGITS_CHANCE + 5;
      ADD_CHARS_CHANCE = ADD_CHARS_CHANCE - 5;
      if (ADD_CHARS_CHANCE <= 0) then
        ADD_CHARS_CHANCE = 1;
    end
    P_LENGTH = P_LENGTH - 1;
  end
  /* если пароль состоит только из символов одного типа (строчных или заглавных
     букв, цифр или специальных символов, то его нужно сформировать заново

     NB! Если минимальную длину пароля уменьшить до менее чем 3 символов, то
     тут гарантировано зависание процедуры. Поскольку у нас минимум 6 символов,
     то это не страшно */
  if (:PWD not similar to '%[[:UPPER:]+]%'
      or
      :PWD not similar to '%[[:LOWER:]+]%'
      or
      :PWD not similar to '%[[:DIGIT:]+]%'
      or
      :PWD not similar to '%[^[:ALNUM:]+]%') then
    PWD = (select
               PWD
             from GEN_PASSWORD(:MIN_LENGTH, :MAX_LENGTH));
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_ACTIVE_DAYS (
    CUSTOMER_ID UID,
    FROM_DATE D_DATE,
    TO_DATE D_DATE,
    SERVICE_ID D_UID_NULL,
    BUSINESS_ID D_UID_NULL = null)
RETURNS (
    DAYS_ON D_INTEGER)
AS
declare variable T_DAY d_DATE;
declare variable i     d_INTEGER;
begin
  if (FROM_DATE is null) then
    select
        min(h.Date_From)
      from Subscr_Hist h
      where h.Customer_Id = :CUSTOMER_ID
    into :FROM_DATE;

  if (TO_DATE is null) then
    TO_DATE = current_date;

  delete from days_tarif;
  if (not SERVICE_ID is null) then
    i = SERVICE_ID;
  else
    i = BUSINESS_ID;

  T_DAY = FROM_DATE;
  while (T_DAY <= TO_DATE) do begin
    insert into days_tarif
    values (:i, :t_day, 1, 1);
    T_DAY = dateadd(day, 1, T_DAY);
  end
  i = 0;
  if (not SERVICE_ID is null) then
    select
        count(distinct DT.T_DAY)
      from SUBSCR_HIST S
           inner join DAYS_TARIF DT on (DT.SERV_ID = S.SERV_ID)
      where S.SERV_ID = :SERVICE_ID
            and DT.T_DAY >= :FROM_DATE
            and DT.T_DAY <= :TO_DATE
            and DT.T_DAY between S.DATE_FROM and S.DATE_TO
            and S.CUSTOMER_ID = :CUSTOMER_ID
    into :i;
  else
    select
        count(distinct DT.T_DAY)
      from SUBSCR_HIST S
           inner join services r on (s.Serv_Id = r.Service_Id)
           inner join DAYS_TARIF DT on (DT.serv_id = r.business_type)
      where r.Business_Type = :BUSINESS_ID
            and DT.T_DAY >= :FROM_DATE
            and DT.T_DAY <= :TO_DATE
            and DT.T_DAY between S.DATE_FROM and S.DATE_TO
            and S.CUSTOMER_ID = :CUSTOMER_ID
    into :i;

  DAYS_ON = coalesce(i, 0);
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_ALL_REPORTS
RETURNS (
    ID_REPORT D_INTEGER,
    ID_PARENT D_INTEGER,
    REPORT_NAME D_VARCHAR500,
    NO_VISIBLE D_IBOOLEAN,
    LVL D_INTEGER,
    IS_FILE D_IBOOLEAN,
    PATH D_PATH,
    FULL_PATH D_PATH)
AS
declare variable canView d_integer;
begin
  for with recursive tree
      as (select
              r.id_report, r.id_parent, r.report_name, r.no_visible, 1 lvl, iif(r.report_body is null, 0, 1) is_file, iif(r.report_body is null, r.report_name, '') path
            from reports r
            where r.id_parent = 0
          union all
          select
              r.id_report, r.id_parent, r.report_name, r.no_visible, p.lvl + 1 lvl, iif(r.report_body is null, 0, 1) is_file, p.path || iif(r.report_body is null, '/' || r.report_name, '')
            from reports r
                 inner join tree p on p.id_report = r.id_parent)
      select
          ID_REPORT, ID_PARENT, REPORT_NAME, NO_VISIBLE, LVL, IS_FILE, PATH
        from tree
        order by path, is_file
      into :ID_REPORT, :ID_PARENT, :REPORT_NAME, :NO_VISIBLE, :LVL, :IS_FILE, :PATH
  do begin
    NO_VISIBLE = coalesce(NO_VISIBLE,0);
    execute procedure get_fullname_report(:ID_REPORT, null) returning_values :FULL_PATH;
    if (current_user <> 'SYSDBA') then begin
      canView = 0;
      if (IS_FILE = 1) then
        select first 1
            1
          from REPORTS r
               inner join Sys$Group_Rights gr on (gr.Rights_Type = 1 and
                     gr.Right_Id = r.Id_Report)
               inner join Sys$Group g on (g.Id = gr.Group_Id and
                     coalesce(g.Lockedout, 0) = 0)
               inner join Sys$User_Groups ug on (ug.Group_Id = gr.Group_Id)
               inner join Sys$User u on (u.Id = ug.User_Id)
          where upper(u.Ibname) = upper(current_user)
                and r.Id_Report = :ID_REPORT
        into :canView;
      else
        canView = 1;

      if (canView = 1) then
        suspend;

    end
    else
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_CONNECTED_DAYS (
    P_CUSTOMER_ID D_UID_NULL,
    P_SERVICE_ID D_UID_NULL,
    P_FROM D_DATE,
    P_TO D_DATE)
RETURNS (
    DAYS D_INTEGER)
AS
declare variable vFROM D_DATE;
    declare variable vTO   D_DATE;
BEGIN
    DAYS = 0;
  FOR
    select
    iif(SH.DATE_FROM > :p_from, SH.DATE_FROM,:p_from),
    iif(SH.DATE_TO < :P_TO, SH.DATE_TO, :P_TO)
    from SUBSCR_HIST SH
    where SH.CUSTOMER_ID = :P_CUSTOMER_ID
          and SH.SERV_ID = :P_SERVICE_ID
          and (SH.DATE_FROM <= :P_TO)
          and (SH.DATE_TO >= :P_FROM)
    into :vFROM, :vTO
  DO BEGIN

     DAYS = DAYS + datediff(day from vFROM to vTO)+1;

  END
  SUSPEND;
END;


CREATE OR ALTER PROCEDURE GET_CUSTOMER_CHANNELS (
    CHECK_DATE D_DATE,
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    DECODER_ID TYPE OF UID,
    CHANNEL_ID TYPE OF UID,
    DECODER_N TYPE OF D_DECODER,
    CHANNEL_STATE D_INTEGER)
AS
declare variable VON D_INTEGER;
begin
  if (CHECK_DATE is null) then
    CHECK_DATE = current_date;

  for select
          D.DEC_ID, D.DECODER_N
        from CUSTOMER_DECODERS D
        where d.Customer_Id = :CUSTOMER_ID
      into :DECODER_ID, :DECODER_N
  do begin
    CHANNEL_STATE = 1;/* активные пакеты */
    VON = 0; -- признак того что абонента нашли в подключеных
    for select
            CH.CH_ID
          from SUBSCR_HIST SS
               inner join SERVICES S on (SS.SERV_ID = S.SERVICE_ID)
               inner join CHANNELS_IN_SERVCE CS on (CS.SRV_ID = S.SERVICE_ID)
               inner join CHANNELS CH on (CH.CH_ID = CS.CH_ID)
          where S.BUSINESS_TYPE >= 2
                and CS.ON_OFF = 1
                and :CHECK_DATE between SS.DATE_FROM and SS.DATE_TO
                and SS.CUSTOMER_ID = :CUSTOMER_ID
                and not exists(select
                                   DP.DECODER_N
                                 from DECODER_PACKETS DP
                                 where DP.DECODER_N = :DECODER_N)

        union

        select
            CH.CH_ID
          from SUBSCR_HIST SS
               inner join SERVICES S on (SS.SERV_ID = S.SERVICE_ID)
               inner join CHANNELS_IN_SERVCE CS on (CS.SRV_ID = S.SERVICE_ID)
               inner join CHANNELS CH on (CH.CH_ID = CS.CH_ID)
          where S.BUSINESS_TYPE >= 2
                and CS.ON_OFF = 1
                and :CHECK_DATE between SS.DATE_FROM and SS.DATE_TO
                and SS.CUSTOMER_ID = :CUSTOMER_ID
                and exists(select
                               DP.DECODER_N
                             from DECODER_PACKETS DP
                             where DP.DECODER_N = :DECODER_N
                                   and DP.SERVICE_ID = S.SERVICE_ID)
        into :CHANNEL_ID
    do begin
      VON = 1;
      suspend;
    end
     -- если декодер активен, вынесем его персональные каналы
    if (1 = VON) then begin
       -- персональные каналы
      for select distinct
              CD.CUSTOMER_ID, CD.DEC_ID, CD.DECODER_N, CC.CH_ID, iif((:CHECK_DATE between CC.DATE_ON and CC.DATE_OFF), 1, 0)
            from CUSTOMER_CHANNELS CC
                 inner join CUSTOMER_DECODERS CD on (CD.DEC_ID = CC.DECODER_ID)
            where CD.DEC_ID = :DECODER_ID
                  and :CHECK_DATE between cc.Date_On and cc.Date_Off
          into :CUSTOMER_ID, :DECODER_ID, :DECODER_N, :CHANNEL_ID, :CHANNEL_STATE
      do begin
        suspend;
      end
    end
    else begin
      for select distinct
              D.CUSTOMER_ID, D.DEC_ID, D.DECODER_N, CS.CH_ID, 1
            from SUBSCR_HIST SH
                 inner join CUSTOMER_DECODERS D on (SH.CUSTOMER_ID = D.CUSTOMER_ID)
                 inner join CHANNELS_IN_SERVCE CS on (SH.SERV_ID = CS.SRV_ID)
            where not(:CHECK_DATE between SH.DATE_FROM and SH.DATE_TO)
                  and CS.ON_OFF = 0
                  and D.DEC_ID = :DECODER_ID
          into :CUSTOMER_ID, :DECODER_ID, :DECODER_N, :CHANNEL_ID, :CHANNEL_STATE
      do begin
        suspend;
      end
    end
  end

end;


CREATE OR ALTER PROCEDURE GET_CUSTOMER_CODE (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    CUST_CODE TYPE OF D_VARCHAR20)
AS
begin
  if (coalesce(trim(FLAT_NO), '') <> '') then
    FLAT_NO = '-' || FLAT_NO;
  else
    FLAT_NO = '';

  select
      substring((coalesce(a.area_code || '-', '') || s.STREET_CODE || '-' || h.HOUSE_NO || :FLAT_NO) from 1 for 20)
    from house h
         inner join street s on (h.street_id = s.street_id)
         left outer join area a on (s.area_id = a.area_id)
    where h.HOUSE_ID = :HOUSE_ID
  into CUST_CODE;
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_CUSTOMER_CURRENT_SRV (
    CUSTOMER_ID TYPE OF UID,
    BUSINESS_TP TYPE OF UID = null)
RETURNS (
    SERVICE_ID TYPE OF UID,
    NAME TYPE OF D_VARCHAR60,
    STATE_SGN D_INTEGER,
    STATE_SRV TYPE OF UID,
    STATE_DATE D_DATE,
    BUSINESS_TYPE D_INTEGER)
AS
begin
  for select S.SERVICE_ID, S.NAME, SS.STATE_SGN, SS.STATE_SRV, SS.STATE_DATE, S.BUSINESS_TYPE
      from SUBSCR_SERV SS
      inner join SERVICES S on (S.SERVICE_ID = SS.SERV_ID)
      where (S.BUSINESS_TYPE = coalesce(:BUSINESS_TP, S.BUSINESS_TYPE))
        and SS.CUSTOMER_ID = :CUSTOMER_ID
        and (
              (SS.STATE_SGN = 1 and SS.STATE_DATE <= current_date)
            or
              (SS.STATE_SGN = 0 and (SS.STATE_SRV = -3 or SS.STATE_DATE > current_date))
            )

      into :SERVICE_ID, :NAME, :STATE_SGN, :STATE_SRV, :STATE_DATE, :BUSINESS_TYPE
  do
    suspend;
end;


CREATE OR ALTER PROCEDURE GET_DAYS_TOTAL (
    CUSTOMER_ID UID,
    ACTIVE_ONLY D_INTEGER = 0)
RETURNS (
    TOTAL_START D_DATE,
    TOTAL_DAYS D_INTEGER,
    ACTIVE_START D_DATE,
    ACTIVE_DAYS D_INTEGER)
AS
declare variable s  D_DATE;
declare variable e  D_DATE;
declare variable sp D_DATE;
declare variable ep D_DATE;
declare C  cursor for (
    select
        SH.DATE_FROM
      , SH.DATE_TO
      from SUBSCR_HIST SH
      where SH.CUSTOMER_ID = :CUSTOMER_ID
      order by SH.DATE_FROM);
begin
  open C;
  fetch C
  into :s, :e;
  if (row_count <> 0) then begin
    Total_Days = 0;
    Active_Days = 0;
    Total_Start = s;
    sp = s;
    ep = e;
    while (1 = 1) do begin
      fetch C
      into :s, :e;
      if (row_count = 0) then
        leave;
      if ((s > sp) and (e <= ep)) then begin
        if (e > ep) then
          ep = e;
      end
      else begin
        Total_Days = Total_Days + datediff(day from sp to ep)+1;
        sp = s;
        ep = e;
      end
    end
    close C;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_DEBT_START_DATE (
    ACCOUNT D_ACCOUNT)
RETURNS (
    DEBT_DATE D_DATE,
    DEBT D_N15_2)
AS
declare variable Customer_Id D_Uid_Null;
begin
  select
      customer_id
    from customer c
    where c.Account_No = :account
  into :customer_id;
  select
      Debt_Date
    from Get_Debt_Start_Date_Cid(:Customer_Id)
  into :Debt_Date;
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_DEBT_START_DATE_CID (
    CUSTOMER_ID TYPE OF UID)
RETURNS (
    DEBT_DATE D_DATE,
    DEBT D_N15_2)
AS
declare variable Pays_Total D_N15_2;
declare variable V_Date     D_Date;
declare variable V_Fee      D_N15_2;
declare variable Fee        D_N15_2;
declare variable Pay        D_N15_2;
declare variable Days       D_Integer;
begin
  debt_date = null;
  DEBT = null;

  if (not customer_id is null) then begin
    select
        sum(p.Pay_Sum)
      from payment p
      where p.Customer_Id = :customer_id
    into :pays_total;
    pays_total = coalesce(pays_total, 0);
    if (pays_total < 0) then
      pays_total = 0;

    for select
            Fee_Date
          , sum(Fee)
          from (select
                    dateadd(month, coalesce(s.Shift_Months, 0), f.Month_Id) Fee_Date
                  , f.Fee
                  from Monthly_Fee f
                       inner join services s on (f.Service_Id = s.Service_Id)
                  where f.Customer_Id = :customer_id
                union
                select
                    Fee_Date
                  , Fee
                  from Other_Fee
                  where Customer_Id = :customer_id
                        and coalesce(fee, 0) <> 0)
          group by 1
        into :v_date, :v_fee
    do begin
      pays_total = pays_total - v_fee;
      if ((pays_total < 0) and (debt_date is null)) then begin
        debt_date = v_date;
        pay = pays_total;
        DEBT = -1*pays_total;
        fee = v_fee;
      end
      else begin
        if ((pays_total > 0) and (not debt_date is null)) then begin
          debt_date = null;
          DEBT = null;
        end
      end
    end

    if (not debt_date is null) then begin
      -- месяц знаем, попытаемся вычислить день долга
      debt_date = (debt_date - extract(day from debt_date) + 1);
      days = extract(day from dateadd(-1 day to(dateadd(1 month to debt_date))));
      select
          sum(f.Fee)
        from Monthly_Fee f
        where f.Customer_Id = :customer_id
              and f.Month_Id >= :debt_date
              and f.Month_Id < dateadd(1 month to :debt_date)
      into :v_fee;
      v_Fee = coalesce(v_Fee, 0);
      if (v_fee <> 0) then begin
        v_fee = v_fee / days;
        if (v_fee <> 0) then begin
          days = round((fee + pay) / v_fee, 0);
          -- если дней больше чем в месяце, то явно ошибка.
          if (days >= extract(day from dateadd(-1 day to(dateadd(1 month to debt_date))))) then
            days = 0;
        end
        else
          days = 0;
      end
      debt_date = dateadd(days day to debt_date);
    end
    else
      debt_date = null; -- Нет задолженности
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_DISTANCE (
    LAT1 DOUBLE PRECISION,
    LOG1 DOUBLE PRECISION,
    LAT2 DOUBLE PRECISION,
    LOG2 DOUBLE PRECISION)
RETURNS (
    DISTANCE_METER DOUBLE PRECISION)
AS
declare variable RADIUS      double precision;
declare variable A           double precision;
declare variable A1          double precision;
declare variable A2          double precision;
declare variable DISTANCE_KM double precision;
declare variable DLON        double precision;
declare variable DLAT        double precision;
begin
  /* переведем градусы в радианы */
  -- if (CORD_FORMAT = 1) then begin
    LAT1 = LAT1 * (pi() / 180);
    LOG1 = LOG1 * (pi() / 180);
    LAT2 = LAT2 * (pi() / 180);
    LOG2 = LOG2 * (pi() / 180);
  -- end
  /* средний радиус земли в км  */
  radius = 6371.0000; -- 6378.137;

  dlon = (loG2 - loG1);
  dlat = (lat2 - lat1);

  a1 = (sin(dlat / 2));
  a1 = a1 * a1;
  a2 = (sin(dlon / 2));
  a2 = a2 * a2;

  a = a1 + cos(lat1) * cos(lat2) * a2;

  distance_km = radius * (2 * atan2(sqrt(a), sqrt(1 - a)));

  distance_meter = distance_km * 1000;

  suspend;
end;


CREATE OR ALTER PROCEDURE GET_EPG (
    STREAM_ID TYPE OF UID,
    DATE_FROM TYPE OF D_TIMESTAMP,
    DATE_TO TYPE OF D_TIMESTAMP,
    OTHERSTREAM TYPE OF D_INTEGER,
    DESC_FORMAT D_VARCHAR50 = null /* COLLATE UTF8 - default */)
RETURNS (
    TSID TYPE OF D_INTEGER,
    ONID TYPE OF D_INTEGER,
    SID TYPE OF D_INTEGER,
    CH_ID TYPE OF UID,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    TITLE TYPE OF D_VARCHAR255,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255,
    LANG TYPE OF D_VARCHAR5,
    ISACTUAL TYPE OF D_INTEGER)
AS
declare variable str         D_EIT_EVENT;
declare variable repDESC     D_Iboolean;
declare variable repYEAR     D_Iboolean;
declare variable repCountry  D_Iboolean;
declare variable repGenres   D_Iboolean;
declare variable repActors   D_Iboolean;
declare variable repDirected D_Iboolean;
declare variable repAge      D_Iboolean;
begin
  DESC_FORMAT = upper(coalesce(DESC_FORMAT, ''));
  repDESC = 0;
  repYEAR = 0;
  repCountry = 0;
  repGenres = 0;
  repActors = 0;
  repDirected = 0;
  repAge = 0;
  if (position('DESC', DESC_FORMAT) > 0) then
    repDESC = 1;
  if (position('YEAR', DESC_FORMAT) > 0) then
    repYEAR = 1;
  if (position('CNTR', DESC_FORMAT) > 0) then
    repCountry = 1;
  if (position('GENR', DESC_FORMAT) > 0) then
    repGenres = 1;
  if (position('ACTR', DESC_FORMAT) > 0) then
    repActors = 1;
  if (position('DRCT', DESC_FORMAT) > 0) then
    repDirected = 1;
  if (position('AGE', DESC_FORMAT) > 0) then
    repAge = 1;

  for select
          Tsid
        , Onid
        , Sid
        , Ch_Id
        , Date_Start
        , Date_Stop
        , Title
        , Description
        , Genres
        , Dvbgenres
        , Minage
        , Create_Year
        , Actors
        , Directed
        , Country
        , Lang
        , Isactual
        from Get_Epg_Apart(:Stream_Id, :Date_From, :Date_To, :Otherstream)
      into :Tsid, :Onid, :Sid, :Ch_Id, :Date_Start, :Date_Stop, :Title, :Description, :Genres, :Dvbgenres, :Minage, :Create_Year, :Actors, :Directed, :Country, :Lang, :Isactual
  do begin
    if (DESC_FORMAT = '') then
      Description = substring(iif(Minage<>'0', Minage|| '+ ', '')
                            || coalesce(Description||' ', '')
                            || coalesce(Genres||' ', '')
                            || coalesce(Country||' ', '')
                            || coalesce(Create_Year||' ', '')
                            || coalesce(Directed||' ', '')
                            || coalesce(Actors, '') from 1 for 4096 );
    else begin
      str = DESC_FORMAT;
      if (repDESC = 1) then
        str = replace(str, 'DESC', coalesce(Description, ''));
      if (repYEAR = 1) then
        str = replace(str, 'YEAR', coalesce(Create_Year, ''));
      if (repCountry = 1) then
        str = replace(str, 'CNTR', coalesce(Country, ''));
      if (repGenres = 1) then
        str = replace(str, 'GENR', coalesce(Genres, ''));
      if (repActors = 1) then
        str = replace(str, 'ACTR', coalesce(Actors, ''));
      if (repDirected = 1) then
        str = replace(str, 'DRCT', coalesce(Directed, ''));
      if (repAge = 1) then
        str = replace(str, 'AGE', iif(Minage<>'0', Minage|| '+ ', ''));
      Description = str;
    end
    Description = substring(trim(' ' from Description) from 1 for 4096);
    suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_EPG_APART (
    STREAM_ID TYPE OF UID,
    DATE_FROM TYPE OF D_TIMESTAMP,
    DATE_TO TYPE OF D_TIMESTAMP,
    OTHERSTREAM TYPE OF D_INTEGER)
RETURNS (
    TSID TYPE OF D_INTEGER,
    ONID TYPE OF D_INTEGER,
    SID TYPE OF D_INTEGER,
    CH_ID TYPE OF UID,
    DATE_START TYPE OF D_TIMESTAMP,
    DATE_STOP TYPE OF D_TIMESTAMP,
    TITLE TYPE OF D_VARCHAR255,
    DESCRIPTION TYPE OF D_EIT_EVENT,
    GENRES TYPE OF D_VARCHAR255,
    DVBGENRES TYPE OF D_VARCHAR255,
    MINAGE TYPE OF D_INTEGER,
    CREATE_YEAR TYPE OF D_VARCHAR255,
    ACTORS TYPE OF D_VARCHAR255,
    DIRECTED TYPE OF D_VARCHAR255,
    COUNTRY TYPE OF D_VARCHAR255,
    LANG TYPE OF D_VARCHAR5,
    ISACTUAL TYPE OF D_INTEGER)
AS
declare variable DVBN_ID        type of uid;
declare variable DVBN_SID       type of uid;
declare variable DVB_TSID       type of D_Integer; --declare variable UTC_SHIFT type of D_INTEGER; не используем сдвиг, это путает
declare variable DVBN_LANG      type of D_VARCHAR5;
declare variable DURATION       type of D_Integer;
declare variable AD_TITLE       type of D_VARCHAR255;
declare variable AD_DESCRIPTION type of D_EIT_EVENT;
declare variable LOCAL_START    type of D_TIMESTAMP; -- declare variable EMP_STREAM_ID  type of UID;
begin

  if (Date_From is null) then
    Date_From = dateadd(day, -1, current_date);

  if (Date_To is null) then
    Date_To = dateadd(day, 7, current_date);

  if (OTHERSTREAM is null) then
    OTHERSTREAM = 0;

  select first 1
      s.Dvbs_Id
    , n.Dvbn_Id
    , coalesce(n.Lang, 'RUS')
    , s.Tsid
    , n.Onid /*, coalesce(n.Timeoffset,0)*/
    from Dvb_Network n
         inner join Dvb_Streams s on (n.Dvbn_Id = s.Dvbn_Id)
    where (s.Dvbs_Id = :STREAM_ID)
            or (:STREAM_ID is null)
  into :STREAM_ID, :DVBN_ID, :DVBN_LANG, :DVB_TSID, :ONID /*, :UTC_SHIFT*/ ;

  isActual = 1;
  for select
          coalesce(sc.Tsid, :DVB_TSID)
        , sc.Sid
        , e.Ch_Id
        , e.UTC_Start
        , e.Title
        , e.Duration
        , e.UTC_Stop
        , e.Description
        , e.Genres
        , coalesce(e.Dvbgenres, c.Dvbgenres)
        , coalesce(e.Minage, c.MINAGE, 0) MINAGE
        , e.Create_Year
        , e.Actors
        , e.Directed
        , e.Country
        , coalesce(c.Lang, :DVBN_LANG)
        , e.Date_Start
        from DVB_Stream_Channels sc
             inner join Epg e on (sc.Ch_Id = e.Ch_Id)
             inner join Channels c on (c.Ch_Id = e.Ch_Id)
        where sc.Dvbs_Id = :STREAM_ID
              and e.Epg_Date between :Date_From and :Date_To
        order by sc.Sid, e.date_start
      into :TSID, :SID, :Ch_Id, :Date_Start, :Title, :Duration, :Date_Stop, :Description, :Genres, :Dvbgenres, :Minage, :Create_Year, :Actors, :Directed, :Country, :LANG, :LOCAL_START

  do begin
    Date_Stop = coalesce(Date_Stop, dateadd(minute, coalesce(Duration, 1), Date_Start));

    /* не используем сдвиг, это путает
    if (UTC_SHIFT<>0) then begin
      Date_Start = dateadd(minute, UTC_SHIFT, Date_Start);
      Date_Stop = dateadd(minute, UTC_SHIFT, Date_Stop);
    end
    */
    select first 1
        a.Ad_Title
      , a.AD_DESCRIPTION
      from Epg_Ad a
      where :LOCAL_START between a.Start_Time and a.Stop_Time
            and ((a.All_Chan = 1)
              or (exists(select
                             ec.Ch_Id
                           from Epg_Ad_Channels ec
                           where ec.Ea_Id = a.Id
                                 and ec.Ch_Id = :CH_ID)))
    into :Ad_Title, :AD_DESCRIPTION;

    if (AD_DESCRIPTION is null) then
      AD_DESCRIPTION = Description;
    else
      AD_DESCRIPTION = AD_DESCRIPTION || '. ' || Description;

    if (Ad_Title is null) then
      Ad_Title = '';
    else begin
      AD_DESCRIPTION = Title || '. ' || AD_DESCRIPTION;
      Title = Ad_Title;
    end

    -- Description = trim('.' from substring(AD_DESCRIPTION || coalesce('. ' || Genres, '') || coalesce('. ' || Minage || '+ ', '') || coalesce('. ' || Country, '') || coalesce('. ' || Create_Year, '') || coalesce('. ' || Directed, '') || coalesce('. ' || Description, '') || coalesce('. ' || Actors, '') from 1 for 4096));
    Description = substring(AD_DESCRIPTION from 1 for 4096);
    suspend;
    AD_DESCRIPTION = null;
    Ad_Title = null;
  end

  if (OtherStream = 1) then begin
    isActual = 0;
    for select
            s.Dvbs_Id
          , s.Tsid
          from Dvb_Streams s
          where s.Dvbn_Id = :DVBN_ID
                and s.Dvbs_Id <> :STREAM_ID
        into :DVBN_SID, :DVB_TSID
    do begin
      for select
              coalesce(sc.Tsid, :DVB_TSID)
            , sc.Sid
            , e.Ch_Id
            , e.UTC_Start
            , e.Title
            , e.Duration
            , e.UTC_Stop
            , e.Description
            , e.Genres
            , e.Dvbgenres
            , e.Minage
            , e.Create_Year
            , e.Actors
            , e.Directed
            , e.Country
            , coalesce(c.Lang, :DVBN_LANG)
            from DVB_Stream_Channels sc
                 inner join Epg e on (sc.Ch_Id = e.Ch_Id)
                 inner join Channels c on (c.Ch_Id = e.Ch_Id)
            where SC.Dvbs_Id = :DVBN_SID
                  and e.Epg_Date between :Date_From and :Date_To
            order by sc.Sid, e.date_start
          into :TSID, :SID, :Ch_Id, :Date_Start, :Title, :Duration, :Date_Stop, :Description, :Genres, :Dvbgenres, :Minage, :Create_Year, :Actors, :Directed, :Country, :LANG
      do begin
        Date_Stop = coalesce(Date_Stop, dateadd(minute, coalesce(Duration, 1), Date_Start));

        select first 1
            a.Ad_Title
          , a.AD_DESCRIPTION
          from Epg_Ad a
          where :LOCAL_START between a.Start_Time and a.Stop_Time
                and ((a.All_Chan = 1)
                  or (exists(select
                                 ec.Ch_Id
                               from Epg_Ad_Channels ec
                               where ec.Ea_Id = a.Id
                                     and ec.Ch_Id = :CH_ID)))
        into :Ad_Title, :AD_DESCRIPTION;

        if (AD_DESCRIPTION is null) then
          AD_DESCRIPTION = Description;
        else
          AD_DESCRIPTION = AD_DESCRIPTION || '. ' || Description;

        if (Ad_Title is null) then
          Ad_Title = '';
        else begin
          AD_DESCRIPTION = Title || '. ' || AD_DESCRIPTION;
          Title = Ad_Title;
        end

        -- Description = trim('.' from substring(AD_DESCRIPTION || coalesce('. ' || Genres, '') || coalesce('. ' || Minage || '+ ', '') || coalesce('. ' || Country, '') || coalesce('. ' || Create_Year, '') || coalesce('. ' || Directed, '') || coalesce('. ' || Description, '') || coalesce('. ' || Actors, '') from 1 for 4096));
        Description = substring(AD_DESCRIPTION from 1 for 4096);
        suspend;
        AD_DESCRIPTION = null;
        Ad_Title = null;
      end
    end
  end

  /* вывод объявлений для каналов без епг на эти дни */
  TITLE = '';
  DESCRIPTION = '';
  GENRES = '';
  DVBGENRES = '';
  MINAGE = 6;
  CREATE_YEAR = '';
  ACTORS = '';
  DIRECTED = '';
  COUNTRY = '';
  LANG = '';
  for select first 1
          coalesce(a.Ad_Title, '')
        , coalesce(a.AD_DESCRIPTION, '')
        from Epg_Ad a
        where ((a.Start_Time between :Date_From and :Date_To)
                or (a.Stop_Time between :Date_From and :Date_To))
              and a.For_Empty = 1
      into :Ad_Title, :AD_DESCRIPTION
  do begin
    Date_Start = Date_From;
    while (Date_Start <= Date_To) do begin
      for select
              sc.Dvbs_Id
            , coalesce(sc.Tsid, s.Tsid, 999)
            , sc.Sid
            , sc.Ch_Id
            , coalesce(c.Dvbgenres, '')
            , coalesce(c.MINAGE, 0) MINAGE
            , coalesce(c.Lang, :DVBN_LANG)
            from Dvb_Streams s
                 inner join DVB_Stream_Channels sc on (s.Dvbs_Id = sc.Dvbs_Id)
                 inner join Channels c on (c.Ch_Id = sc.Ch_Id)
            where s.Dvbn_Id = :DVBN_ID
                  and ((sc.Dvbs_Id = :STREAM_ID)
                    or ((1 = :OtherStream)
                  and (sc.Dvbs_Id <> :STREAM_ID)))
                  and not exists(select
                                     e.Ch_Id
                                   from epg e
                                   where e.Ch_Id = c.Ch_Id
                                         and e.Epg_Date = :Date_Start)
            order by sc.Sid, sc.Ch_Id
          into :DVBN_SID, :TSID, :SID, :Ch_Id, :Dvbgenres, :Minage, :LANG
      do begin
        if (DVBN_SID = STREAM_ID) then
          isActual = 1;
        else
          isActual = 0;
        Title = Ad_Title;
        Description = AD_DESCRIPTION;
        Date_Stop = dateadd(minute, -1, dateadd(day, 1, Date_Start));
        Duration = datediff(minute, Date_Stop, Date_Start);
        LOCAL_START = Date_Start;
        suspend;
      end
      Date_Start = dateadd(1 day to Date_Start);
    end
  end

end;


CREATE OR ALTER PROCEDURE GET_FLOOR (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    FLOOR_N TYPE OF D_VARCHAR10)
AS
begin
  if (not FLAT_NO is null) then begin
    select first 1
        HF.FLOOR_N
      from HOUSEFLATS HF
        where HF.HOUSE_ID = :HOUSE_ID
              and HF.FLAT_NO = :FLAT_NO
    into :FLOOR_N;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_FREE_INET_IP (
    SRV_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
declare variable START_IP   type of D_INT_IP;
declare variable END_IP     type of D_INT_IP;
declare variable FINDED_IP  type of D_INT_IP;
declare variable CURRENT_IP type of D_INT_IP;
declare variable MASK_0_255 type of D_INT_IP;
begin
  IP = '';

  select v.ip_begin_bin , v.ip_end_bin - 1
    from services v
    where v.Service_Id = :Srv_Id
  into :START_IP, :END_IP;

  CURRENT_IP = START_IP;
  FINDED_IP = 0;

  while ((CURRENT_IP < END_IP) and (FINDED_IP = 0)) do begin
    /* исключим 255 и 0 из диапазона IP */
    MASK_0_255 = bin_and(CURRENT_IP, 255);
    if ((MASK_0_255 > 0) and (MASK_0_255 < 255)) then begin
      if (not exists(select Ip_Inet from BILLING T where t.Ip_Inet_Bin = :CURRENT_IP))
      then begin
        if (not exists(select IP_BIN from V_ALL_IP B where B.IP_BIN = :CURRENT_IP))
        then
          FINDED_IP = CURRENT_IP;
      end
    end
    CURRENT_IP = CURRENT_IP + 1;
  end

  if ((FINDED_IP = 0) and (CURRENT_IP < END_IP))
  then begin
    CURRENT_IP = CURRENT_IP + 1;
    /* исключим 255 и 0 из диапазона IP */
    MASK_0_255 = bin_and(CURRENT_IP, 255);
    if ((MASK_0_255 > 0) and (MASK_0_255 < 255))
    then
        select STR_IP from INT2IP(:CURRENT_IP)
        into :IP;
  end
  else begin
    if ((FINDED_IP <= END_IP) and (FINDED_IP > 0))
    then
        select STR_IP from INT2IP(:FINDED_IP)
        into :IP;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE GET_FREE_INET_IP_CUSTOMER (
    CUSTOMER_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
declare variable Srv_Id type of UID;
begin

  for select
          s.Service_Id
        from services s
             inner join Subscr_Serv sh on (s.Service_Id = sh.Serv_Id)
        where sh.Customer_Id = :CUSTOMER_ID
              and not s.Ip_Begin_Bin is null
              and not s.Ip_End_Bin is null
      into :Srv_Id
  do begin
    IP = '';
    execute procedure Get_Free_Inet_Ip(:Srv_Id)
        returning_values :Ip;
    suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_FREE_IP (
    IP_MASK D_IP = null)
RETURNS (
    IP TYPE OF D_IP)
AS
declare variable START_IP   type of D_INT_IP;
declare variable END_IP     type of D_INT_IP;
declare variable FINDED_IP  type of D_INT_IP;
begin
  IP = '';
  FINDED_IP = null;
  IP_MASK = coalesce(trim(IP_MASK), '');

  if (IP_MASK = '') then
    select
        max(l.Ip_Bin)
      from V_ALL_IP l
    into :FINDED_IP;
  else begin
    select
        max(l.Ip_Bin)
      from V_ALL_IP l
      where l.Ip starting with :IP_MASK
    into :FINDED_IP;
    /* адрес не нашли, выберем первый подходящий по маске */
    if (FINDED_IP is null) then begin
      START_IP = 1;
      IP_MASK = trim(trailing '.' from IP_MASK);
      while (START_IP <> 3) do begin
        START_IP = char_length(IP_MASK);
        END_IP = char_length(replace(IP_MASK, '.', ''));
        START_IP = START_IP - END_IP;
        if (START_IP <> 3) then
          IP_MASK = IP_MASK || '.0';
      end
      FINDED_IP = Inet_Aton(IP_MASK);
    end
  end

  if (not FINDED_IP is null) then begin
    FINDED_IP = FINDED_IP + 1;
    IP = INET_NTOA(FINDED_IP);
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE GET_FREE_VLAN_IP (
    VLAN_ID TYPE OF D_INT_IP)
RETURNS (
    IP TYPE OF D_IP)
AS
declare variable START_IP   type of D_INT_IP;
declare variable END_IP     type of D_INT_IP;
declare variable FINDED_IP  type of D_INT_IP;
declare variable CURRENT_IP type of D_INT_IP;
declare variable MASK_0_255 type of D_INT_IP;
declare variable i          D_Integer;
begin
  IP = '';

  select
      V.IP_BEGIN_BIN, V.IP_END_BIN
    from VLANS V
    where V.V_ID = :VLAN_ID
  into :START_IP, :END_IP;

  i = null;
  select
      Var_Value
    from Settings
    where var_Name = 'IP_RESERV_START'
  into :i;
  if (not i is null) then
    START_IP = START_IP + i;

  i = null;
  select
      Var_Value
    from Settings
    where var_Name = 'IP_RESERV_END'
  into :i;
  if (not i is null) then
    END_IP = END_IP - i;

  CURRENT_IP = START_IP;
  FINDED_IP = 0;

  while ((CURRENT_IP <= END_IP) and (FINDED_IP = 0)) do begin
    /* исключим 255 и 0 из диапазона IP */
    MASK_0_255 = bin_and(CURRENT_IP, 255);
    if ((MASK_0_255 > 0) and (MASK_0_255 < 255)) then begin
      if (not exists(select
                         IP
                       from TV_LAN T
                       where t.Ip_Bin = :CURRENT_IP and t.Vlan_Id = :VLAN_ID )) then begin
        if (not exists(select
                           IP_BIN
                         from EQUIPMENT T
                         where T.IP_BIN = :CURRENT_IP and t.Vlan_Id = :VLAN_ID)) then
          FINDED_IP = CURRENT_IP;
      end
    end
    CURRENT_IP = CURRENT_IP + 1;
  end

  if ((FINDED_IP = 0) and (CURRENT_IP < END_IP)) then begin
    CURRENT_IP = CURRENT_IP + 1;
    /* исключим 255 и 0 из диапазона IP */
    MASK_0_255 = bin_and(CURRENT_IP, 255);
    if ((MASK_0_255 > 0) and (MASK_0_255 < 255)) then
      select
          STR_IP
        from INT2IP(:CURRENT_IP)
      into :IP;
  end
  else begin
    if ((FINDED_IP <= END_IP) and (FINDED_IP > 0)) then
      select
          STR_IP
        from INT2IP(:FINDED_IP)
      into :IP;
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE GET_FULLNAME_ALLREPORTS (
    SEPARATOR VARCHAR(10))
RETURNS (
    ID_REPORT INTEGER,
    FULL_NAME VARCHAR(5000))
AS
declare variable id_parent integer;
declare variable name_level varchar(100);
begin
  if (separator is null) then
    separator = '/'; -- значение сепаратора по умолчанию
-- текущей узел
  for
    select r.id_report, r.id_parent, r.report_name
    from REPORTS r
    where r.no_visible = 0 and not r.report_body is null
    into :id_report, :id_parent, :full_name
  do
  begin
-- очередной узел, только если  найден текущий
    execute procedure get_fullname_report(:id_parent, :separator) returning_values :name_level;
-- добавление имени очередного узла
    full_name = coalesce(:name_level||:separator, '')||:full_name;
-- вывод
    suspend;
  end

end;


CREATE OR ALTER PROCEDURE GET_FULLNAME_REPORT (
    ID_REPORT INTEGER,
    SEPARATOR VARCHAR(10))
RETURNS (
    FULL_NAME VARCHAR(5000))
AS
declare variable id_parent integer;
declare variable name_level varchar(100);
begin
  if (separator is null) then
    separator = '/'; -- значение сепаратора по умолчанию
-- текущей узел
  for
    select r.id_report, r.id_parent, r.report_name
    from REPORTS r
    where r.id_report = :id_report
    into :id_report, :id_parent, :full_name
  do
  begin
-- очередной узел, только если  найден текущий
    execute procedure get_fullname_report(:id_parent, :separator) returning_values :name_level;
-- добавление имени очередного узла
    full_name = coalesce(:name_level||:separator, '')||:full_name;
  end
-- вывод
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_MAT_FOR_NODE (
    NODE_ID UID)
RETURNS (
    M_ID UID,
    NAME D_VARCHAR255,
    M_TYPE D_UID_NULL,
    NEED_CNT D_N15_2,
    IS_UNIT D_IBOOLEAN)
AS
declare variable T_NAME D_VARCHAR255;--declare variable v_used D_N15_2;
declare variable v_flag D_INTEGER;
begin
  v_flag = 0;
  -- выведем согласно компановке узла
  for select
          M_Type
        , Dev_Cnt
        from Node_Layout CA
        where CA.Node_Id = :NODE_ID
      into :M_Type, :NEED_CNT
  do begin
    v_flag = 1;
    for select
            m.M_Id
          , m.Name
          , a.O_Name
          , m.IS_UNIT
          from materials m
               inner join OBJECTS A on (A.O_Id = m.M_TYPE and
                     A.O_TYPE = 48)
          where m.M_Type = :M_Type
          order by m.Name
        into :M_ID, :NAME, :T_NAME, :IS_UNIT
    do begin
      NAME = NAME || coalesce(' / ' || T_NAME, '');
      suspend;
    end
  end

  -- если компановки нет. то компановку для типа узла
  if (v_flag = 0) then begin
    for select
            M_Type
          , Dev_Cnt
          from Node_Layout CA
          where CA.Node_Id in (select
                                   -1 * n.Type_Id
                                 from nodes n
                                 where n.Node_Id = :NODE_ID)
        into :M_Type, :NEED_CNT
    do begin
      v_flag = 1;
      for select
              m.M_Id
            , m.Name
            , a.O_Name
            , m.IS_UNIT
            from materials m
                 inner join OBJECTS A on (A.O_Id = m.M_TYPE and
                       A.O_TYPE = 48)
            where m.M_Type = :M_Type
            order by m.Name
          into :M_ID, :NAME, :T_NAME, :IS_UNIT
      do begin
        NAME = NAME || coalesce(' / ' || T_NAME, '');
        suspend;
      end
    end

  end

  -- если компановки нет. то выведем весь список материалов
  if (v_flag = 0) then begin
    for select
            m.M_Id
          , m.Name
          , a.O_Name
          , m.IS_UNIT
          from materials m
               inner join OBJECTS A on (A.O_Id = m.M_TYPE and
                     A.O_TYPE = 48)
          order by m.Name
        into :M_ID, :NAME, :T_NAME, :IS_UNIT
    do begin
      NAME = NAME || coalesce(' (' || T_NAME || ')', '');
      suspend;
    end
  end
end;


CREATE OR ALTER PROCEDURE GET_MAT_FOR_REQUEST (
    IRQ_ID D_UID_NULL,
    IMG_ID D_UID_NULL = null,
    IMT_ID D_UID_NULL = null)
RETURNS (
    RM_ID D_UID_NULL,
    M_ID UID,
    NAME D_VARCHAR100,
    DIMENSION D_VARCHAR10,
    COST D_N15_2,
    WH_NAME D_VARCHAR100,
    WH_ID UID,
    RM_QUANT D_N15_5,
    NOT_CALC D_IBOOLEAN,
    MR_QUANT D_N15_5,
    M_NUMBER D_N15_5,
    RQ_ID D_UID_NULL)
AS
begin
  for select
          M.M_ID, M.NAME, M.DIMENSION, M.M_Number
        from MATERIALS M
        where ((:IMT_ID is null)
                or (M.M_ID = :IMT_ID))
              and ((M.MG_ID = :IMG_ID)
                or (:IMG_ID is null))
        order by M.NAME
      into :M_ID, :NAME, :DIMENSION, :M_NUMBER
  do begin
    for select
            O.O_ID, O.O_NAME
          from OBJECTS O
          where O.O_TYPE = 10
                and ((current_user = 'SYSDBA')
                  or (exists(select
                                 WH.WH_ID
                               from SYS$USER U
                                    inner join SYS$USER_WH WH on (WH.USER_ID = U.ID)
                               where U.IBNAME = current_user
                                     and WH.CAN_VIEW = 1)))
          order by O.O_NAME
        into :WH_ID, :WH_NAME
    do begin
      for select
              MR.MR_QUANT, MR.MR_COST
            from MATERIALS_REMAIN MR
            where MR.WH_ID = :WH_ID
                  and MR.M_ID = :M_ID
                  and MR.MR_QUANT <> 0
          into :MR_QUANT, :COST
      do begin
        RQ_ID = null;
        RM_ID = null;
        NOT_CALC = null;
        RM_QUANT = null;
        for select
                RM_ID, RM_QUANT, RQ_ID, NOT_CALC
              from REQUEST_MATERIALS RM
              where RM.WH_ID = :WH_ID
                    and RM.M_ID = :M_ID
                    and RM.RQ_ID = :IRQ_ID
                    and coalesce(RM.RM_COST, 0) = coalesce(:COST, 0)
            into :RM_ID, :RM_QUANT, :RQ_ID, :NOT_CALC
        do begin
          suspend;
        end
        if (RM_QUANT is null) then
          suspend;
      end

      MR_QUANT = null;

      for select
              RM_ID, RM_QUANT, RQ_ID, RM_COST, NOT_CALC
            from REQUEST_MATERIALS RM
            where RM.WH_ID = :WH_ID
                  and RM.M_ID = :M_ID
                  and RM.RQ_ID = :IRQ_ID
                  and (not exists(select
                                      MR.M_ID
                                    from MATERIALS_REMAIN MR
                                    where MR.WH_ID = RM.WH_ID
                                          and MR.M_ID = RM.M_ID
                                          and coalesce(MR.MR_COST, 0) = coalesce(RM.RM_COST, 0)))

          into :RM_ID, :RM_QUANT, :RQ_ID, :COST, :NOT_CALC
      do begin
        suspend;
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE GET_MAT_GIVE_OUT (
    FOR_RQ D_INTEGER,
    MG_ID D_INTEGER = -1,
    RQ_OWNER D_IBOOLEAN = 0)
RETURNS (
    RM_ID D_INTEGER,
    M_ID D_INTEGER,
    NAME D_DESCRIPTION,
    DIMENSION D_VARCHAR10,
    O_NAME D_DESCRIPTION,
    WH_ID D_INTEGER,
    RM_QUANT D_N15_5,
    NOT_CALC D_INTEGER,
    MR_QUANT D_N15_5,
    RM_COST D_N15_2,
    M_NUMBER D_VARCHAR20,
    QUANT_TOTAL D_N15_5,
    QUANT_IN_REQUEST D_N15_5,
    RQ_ID D_INTEGER,
    RM_NOTICE D_NOTICE,
    DESCRIPTION D_NOTICE)
AS
begin
  RQ_ID = coalesce(:FOR_RQ, 0);

  for select
          rm.Rm_Id
        , m.M_ID
        , m.Name
        , m.Dimension
        , w.O_Name
        , w.O_ID as WH_ID
        , rm.Rm_Quant
        , rm.NOT_CALC
        , coalesce(mr.Mr_Quant, 0)
        , rm.Rm_Cost
        , m.M_Number
        , rm.Rm_Quant + coalesce(mr.Mr_Quant, 0)
        , rm.Rm_Quant
        , rm.Rm_Notice
        , m.Description
        from MATERIALS M
             inner join Request_Materials rm on (rm.M_Id = m.M_Id)
             left outer join Materials_Remain mr on (mr.M_Id = m.M_Id and
                   mr.wh_id = rm.Wh_Id)
             left outer join OBJECTS W on (W.O_ID = rm.Wh_Id and
                   W.O_TYPE = 10)
        where rm.Rq_Id = :RQ_ID
              and ((:MG_ID = -2) or ((:MG_ID = -1)
                or (M.MG_ID = :MG_ID
              and not :MG_ID is null)
                or (M.MG_ID is null
              and :MG_ID is null)))
      into :RM_ID, :M_ID, :NAME, :DIMENSION, :O_NAME, :WH_ID, :RM_QUANT, :NOT_CALC, :MR_QUANT,
           :RM_COST, :M_NUMBER, :QUANT_TOTAL, :QUANT_IN_REQUEST, :RM_NOTICE, :Description
  do begin
    suspend;
  end

  RM_NOTICE = null;
  Description = null;

  if (MG_ID <> -2) then begin
    RQ_ID = coalesce(:FOR_RQ, 0);

    for select
            null
          , m.M_ID
          , m.Name
          , m.Dimension
          , w.O_Name
          , w.O_ID
          , null
          , 0 NOT_CALC
          , mr.Mr_Quant
          , m.Cost
          , m.M_Number
          , mr.Mr_Quant
          , 0
          , m.Description
          from MATERIALS M
               left outer join Materials_Remain mr on (mr.M_Id = m.M_Id and
                     (exists(select
                                 wh.wh_id
                               from SYS$USER u
                                    inner join sys$user_wh wh on (wh.user_id = u.id)
                               where u.ibname = current_user
                                     and wh.can_view = 1
                                     and wh.wh_id = mr.Wh_Id) or current_user = 'SYSDBA'))
               left outer join OBJECTS W on (W.O_ID = mr.Wh_Id and
                     W.O_TYPE = 10)

          where (not exists(select
                                rm.Rm_Id
                              from Request_Materials rm
                              where rm.M_Id = m.M_Id
                                    and rm.Rq_Id = :FOR_RQ
                                    and rm.WH_ID = mr.WH_ID))

                and ((:MG_ID = -1)
                  or (M.MG_ID = :MG_ID
                and not :MG_ID is null)
                  or (M.MG_ID is null
                and :MG_ID is null))
                and (((m.Deleted = 0)
                and (mr.Mr_Quant > 0)))
                and ((:RQ_Owner = 0)
                  or exists(select
                                e.Rq_Id
                              from Request_Executors e
                              where e.Exec_Id = w.O_Numericfield
                                    and e.Rq_Id = :FOR_RQ))
        into :RM_ID, :M_ID, :NAME, :DIMENSION, :O_NAME, :WH_ID, :RM_QUANT, :NOT_CALC, :MR_QUANT, :RM_COST, :M_NUMBER, :QUANT_TOTAL, :QUANT_IN_REQUEST, :Description
    do begin
      suspend;
    end
  end
end;


CREATE OR ALTER PROCEDURE GET_MAX_INET_IP (
    SRV_ID UID)
RETURNS (
    IP TYPE OF D_IP)
AS
declare variable Start_Ip   type of D_Int_Ip;
  declare variable End_Ip     type of D_Int_Ip;
  declare variable Current_Ip type of D_Int_Ip;
  declare variable Finded_Ip  type of D_Int_Ip;
  declare variable Prev_Ip    type of D_Int_Ip;
begin
  ip = '';

  select v.ip_begin_bin , v.ip_end_bin - 1
    from services v
    where v.Service_Id = :Srv_Id
  into :START_IP, :END_IP;

  if (start_ip is null) then
    start_ip = -1;
  if (end_ip is null) then
    end_ip = 9999999999;

  PREV_IP = START_IP - 1;
  FINDED_IP = 0;

    -- возьмем макссимальный IP
    select max(b.Ip_Inet_Bin)
        from BILLING b
        where b.Ip_Inet_Bin between :START_IP and :END_IP
    into :CURRENT_IP;

    FINDED_IP = CURRENT_IP + 1;

  if (FINDED_IP = 0) then
  begin
    PREV_IP = PREV_IP + 1;
    if (PREV_IP <= END_IP) then
      select str_ip
        from int2ip(:PREV_IP)
      into :IP;
  end
  else
  begin
    if (FINDED_IP <= END_IP) then
      select str_ip
        from int2ip(:FINDED_IP)
      into :IP;
  end

  suspend;

end;


CREATE OR ALTER PROCEDURE GET_MODULES_FOR_MENU
RETURNS (
    ID_MODULE D_INTEGER,
    NAME D_VARCHAR500,
    LANG D_INTEGER,
    NOTICE D_NOTICE)
AS
begin
  if (current_user <> 'SYSDBA') then begin
    for select distinct
            m.ID_MODULE, m.NAME, m.LANG, m.NOTICE
          from modules m
               inner join Sys$Group_Rights gr on (gr.Rights_Type = 2 and
                     gr.Right_Id = m.Id_Module)
               inner join Sys$Group g on (g.Id = gr.Group_Id and
                     coalesce(g.Lockedout, 0) = 0)
               inner join Sys$User_Groups ug on (ug.Group_Id = gr.Group_Id)
               inner join Sys$User u on (u.Id = ug.User_Id)
          where in_menu = 1
                and upper(u.Ibname) = upper(current_user)
        into :ID_MODULE, :NAME, :LANG, :NOTICE
    do
      suspend;
  end
  else begin
    for select
            ID_MODULE, NAME, LANG, NOTICE
          from modules m
          where in_menu = 1
        into :ID_MODULE, :NAME, :LANG, :NOTICE
    do
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_NODE_FLAT_LVL (
    NODE_ID INTEGER)
RETURNS (
    HOUSE_ID INTEGER,
    LVL INTEGER,
    FLAT_NO D_FLAT_NS,
    PORCH_N D_FLAT_NS,
    FLOOR_N D_FLAT_NS,
    SRV_LIST VARCHAR(400),
    CST_LIST VARCHAR(400),
    STREET_NAME VARCHAR(250),
    HOUSE_NO VARCHAR(80),
    NOTICE D_NOTICE)
AS
declare variable T_NODE integer;
begin
  if (NODE_ID is null) then
    suspend;
  else begin
    for with recursive Node_tree
        as (select
                t.Node_Id
              , t.parent_id
              , 1 lvl
              from Nodes t
              where node_id = :NODE_ID
            union all
            select
                t.Node_Id
              , t.parent_id
              , prior.lvl + 1 lvl
              from Nodes t
                   inner join Node_tree prior on prior.Node_Id = t.parent_id)
        select
            nt.Node_Id
          , nt.lvl
          from Node_tree nt
        into :T_NODE, :LVL
    do begin
      for select
              nF.House_Id
            , nf.Flat_No
            , f.Porch_N
            , f.Floor_N
            , s.Street_Name || ' ' || s.Street_Short as Street_Name
            , h.House_No
            , nf.NOTICE
            from Node_Flats NF
                 inner join house h on (nf.House_Id = h.House_Id)
                 inner join street s on (s.Street_Id = h.Street_Id)
                 left outer join houseflats F on (f.House_Id = nf.House_Id and
                       f.Flat_No = nf.Flat_No)
            where nf.NODE_ID = :T_NODE
            order by f.porch_n, f.Floor_N, f.Flat_No
          into :HOUSE_ID, :FLAT_NO, :PORCH_N, :FLOOR_N, :STREET_NAME, :HOUSE_NO, :NOTICE
      do begin
        SRV_LIST = null;
        CST_LIST = null;
        select
            list(distinct c.CUSTOMER_ID) CST_LIST
          , list(distinct R.Shortname) SRV_LIST
          from customer c
               left outer join subscr_serv ss on (ss.Customer_Id = c.Customer_Id and
                     ss.State_Sgn = 1)
               left outer join services r on (r.Service_Id = ss.Serv_Id)
          where c.House_Id = :HOUSE_ID
                and c.Flat_No = :Flat_No
        into :CST_LIST, :SRV_LIST;
        suspend;
      end
    end
  end
end;


CREATE OR ALTER PROCEDURE GET_PAY_DOC (
    PAYSOURCE_ID D_INTEGER,
    PAY_DATE D_DATE,
    PAY_DOC_NO D_VARCHAR255)
RETURNS (
    PAY_DOC_ID D_INTEGER)
AS
declare variable fio d_varchar100;
begin
  if (PAYSOURCE_ID is null) then begin
    -- посмотрим, есть ли источник для данного пользователя
    select
        first 1 coalesce(surname, '')
      from worker
      where upper(ibname) = upper(current_user)
    into :fio;

    select
        coalesce(ps.paysource_id, 0)
      from paysource ps
      where upper(ps.paysource_descr) = upper(:fio)
    into :Paysource_Id;
  end

  -- Если нет, то выберем первый из списка
  if (Paysource_Id is null) then begin
    select first 1
        Paysource_Id
      from Paysource p
      order by p.Paysource_Id
    into :PAYSOURCE_ID;
    -- если источника нет, то создадим
    if (Paysource_Id is null) then begin
      Paysource_Id = gen_id(gen_operations_uid, 1);
      insert into Paysource (Paysource_Id, Paysource_Descr, Leak_Prc, Tax_Prc)
      values (:Paysource_Id, 'Источник', 0, 0);
    end
  end

  if (PAY_DATE is null) then
    PAY_DATE = current_date;
  -- если номер не установлен, пропишем как дату
  if (Pay_Doc_No is null) then
    Pay_Doc_No = extract(year from Pay_Date) || lpad(extract(month from Pay_Date), 2, '0') || lpad(extract(day from Pay_Date), 2, '0');

  select first 1
      Pay_Doc_Id
    from Pay_Doc
    where Paysource_Id = :Paysource_Id
          and Pay_Doc_Date = :Pay_Date
          and Pay_Doc_No = :Pay_Doc_No
  into :Pay_Doc_Id;
  -- если документ не найден, создадим его
  if (Pay_Doc_Id is null) then begin
    PAY_DOC_ID = gen_id(gen_operations_uid, 1);

    insert into Pay_Doc (Pay_Doc_Id, Paysource_Id, Pay_Doc_No, Pay_Doc_Date, Pay_Doc_Sum)
    values (:Pay_Doc_Id, :Paysource_Id, :Pay_Doc_No, :Pay_Date, 0);
  end

  suspend;
end;


CREATE OR ALTER PROCEDURE GET_PORCH (
    HOUSE_ID TYPE OF UID,
    FLAT_NO TYPE OF D_FLAT)
RETURNS (
    PORCH_N TYPE OF D_VARCHAR10)
AS
begin
  if (not FLAT_NO is null) then begin
    select first 1
        HF.PORCH_N
      from HOUSEFLATS HF
        where HF.HOUSE_ID = :HOUSE_ID
              and HF.FLAT_NO = :FLAT_NO
    into :PORCH_N;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_REPORT_ID (
    FULL_NAME VARCHAR(5000),
    SEPARATOR CHAR(1))
RETURNS (
    ID_REPORT INTEGER)
AS
begin
  if (separator is null) then
    separator = '/'; -- значение сепаратора по умолчанию

  -- чудовищно не оптимальный запрос
  if (current_user <> 'SYSDBA') then begin
    select first 1
        r.id_report
      from REPORTS r
           inner join Sys$Group_Rights gr on (gr.Rights_Type = 1 and
                 gr.Right_Id = r.Id_Report)
           inner join Sys$Group g on (g.Id = gr.Group_Id and
                 coalesce(g.Lockedout, 0) = 0)
           inner join Sys$User_Groups ug on (ug.Group_Id = gr.Group_Id)
           inner join Sys$User u on (u.Id = ug.User_Id)
      where upper(u.Ibname) = upper(current_user)
            and exists(select
                           *
                         from get_fullname_report(r.id_report, :SEPARATOR) g
                         where upper(g.full_name) = upper(:FULL_NAME))
    into :id_report;
  end
  else begin
    select first 1
        r.id_report
      from REPORTS r
      where exists(select
                       *
                     from get_fullname_report(r.id_report, :SEPARATOR) g
                     where upper(g.full_name) = upper(:FULL_NAME))
    into :id_report;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_REQUEST_BUSY_DAYS (
    HOUSE_ID TYPE OF UID,
    FROM_DATE D_DATE,
    TO_DATE D_DATE,
    TEMPLATE_ID D_INTEGER)
RETURNS (
    BUSY_DAY D_DATE)
AS
declare variable WA_ID  D_INTEGER; -- ID участка
declare variable WA_LIMIT  D_INTEGER; -- Кол-во заявок на участок
declare variable RT_RQ  D_INTEGER; -- Кол-во заявок на тип
declare variable RC     D_INTEGER; -- Ограничение заявок на участок
declare variable RC_TPL D_INTEGER; -- Ограничение заявок на тип
begin

  -- Защита от NULL
  if (FROM_DATE is null) then FROM_DATE = CURRENT_DATE+1;-- - EXTRACT(DAY FROM CURRENT_DATE) + 1;
  if (TO_DATE is NULL)
  then TO_DATE   = FROM_DATE;
  -- Установим на конец месяца
  TO_DATE   = TO_DATE - EXTRACT(DAY FROM TO_DATE) + 1;
  TO_DATE   = DATEADD( -1 DAY TO ( DATEADD( 1 MONTH TO TO_DATE )));

  select first 1 A.WA_ID, A.REQ_LIMIT
      from HOUSE H
          inner join WORKGROUPS G on (H.WG_ID = G.WG_ID)
          inner join WORKAREA A on (A.WA_ID = G.WA_ID)
      where H.HOUSE_ID = :HOUSE_ID
  into :WA_ID, :WA_LIMIT;

  if (not TEMPLATE_ID is null)
  then begin
    select WA.QUANT
        from WORKAREALIMIT WA
        where WA.WA_ID = :WA_ID and
              WA.W_ID = :TEMPLATE_ID
    into :RT_RQ;
    if (RT_RQ is null)
    then RT_RQ = 9999999;
  end
  else begin
    TEMPLATE_ID = -1;
    RT_RQ = 9999999;
  end

  /* Если установлено ограничение поищем занятые дни */
  if (WA_LIMIT >=0)
  then begin
    -- запретим добавлять в дни ранее сегодняшнего
    BUSY_DAY = FROM_DATE - EXTRACT(DAY FROM FROM_DATE) + 1;
    while (BUSY_DAY <=  CURRENT_DATE) do begin
      suspend;
      BUSY_DAY = BUSY_DAY+1;
    end
    FROM_DATE = BUSY_DAY;
    BUSY_DAY = null;
    for
        select r.RQ_PLAN_DATE, count(*)
            from request r
              inner join house h on (r.house_id = h.house_id)
              inner join workgroups g on (h.wg_id = g.wg_id)
            where g.wa_id = :WA_ID and r.RQ_PLAN_DATE between :FROM_DATE and :TO_DATE
            GROUP BY r.RQ_PLAN_DATE
        into :BUSY_DAY, :RC
    do begin
      if (RC >= WA_LIMIT)
      then suspend;
      else begin
        -- Если число заявок меньше чем лимит
        -- Проверим не привысил лилимит конкретно по одной из работ
        if (TEMPLATE_ID > 0)
        then begin
            select count(*)
                from REQUEST R
                    inner join HOUSE H on (R.HOUSE_ID = H.HOUSE_ID)
                    inner join WORKGROUPS G on (H.WG_ID = G.WG_ID)
                where G.WA_ID = :WA_ID
                      and R.RQ_PLAN_DATE = :BUSY_DAY
                      and (R.rqtl_id = :TEMPLATE_ID
                        -- Для МТИС
                        --37    Подключение абонента в ТВ сети (3 точки подключения)
                        --38    Подключение абонента в ТВ сети (2 точки подключения)
                        --39    Подключение абонента в ТВ сети (1 точка подключения)
                        --44    Прокладка кабеля
                        or  (:TEMPLATE_ID in (37,38,39,44) and R.rqtl_id in (37,38,39,44))
                      )
            into :RC_TPL;
        end
        if (RC_TPL >= RT_RQ)
        then suspend;
      end
    end
  end
  else suspend;
end;


CREATE OR ALTER PROCEDURE GET_REQUEST_FREEDAY (
    HOUSE_ID TYPE OF UID,
    TEMPLATE_ID D_INTEGER)
RETURNS (
    FREE_DAY D_DATE)
AS
declare variable WA_ID        D_INTEGER; -- ID участка
declare variable WA_LIMIT     D_INTEGER; -- Кол-во заявок на участок
declare variable RT_RQ        D_INTEGER; -- Кол-во заявок на тип
declare variable RC           D_INTEGER; -- Ограничение заявок на участок
declare variable RC_TPL       D_INTEGER; -- Ограничение заявок на тип
declare variable I            D_INTEGER;
declare variable SKIP_WEEKEND D_INTEGER;
declare variable VDAY         D_DATE;
declare variable WD           D_INTEGER;
declare variable REQ_TIME     D_TIME;
declare variable ON_NEXT_DAY  D_INTEGER;
begin
  select
      cast(S.VAR_VALUE as integer)
    from SETTINGS S
    where S.VAR_NAME = 'REQUEST_SKIP_WEEKEND'
  into :SKIP_WEEKEND;
  if (SKIP_WEEKEND is null) then
    SKIP_WEEKEND = 1;

  select
      cast(S.VAR_VALUE as time)
    from SETTINGS S
    where S.VAR_NAME = 'REQUEST_NEXT_DAY_TIME'
  into :REQ_TIME;
  ON_NEXT_DAY = 1;/* пропустим сегодняшний день */
  if (not REQ_TIME is null) then
    /* Если не наступило время брать заявки на завтра, то берем на сегодня */
    if (current_time < REQ_TIME) then
      ON_NEXT_DAY = 0;

  select first 1
      A.WA_ID
    , A.REQ_LIMIT
    from HOUSE H
         inner join WORKGROUPS G on (H.WG_ID = G.WG_ID)
         inner join WORKAREA A on (A.WA_ID = G.WA_ID)
    where H.HOUSE_ID = :HOUSE_ID
  into :WA_ID, :WA_LIMIT;

  if (not TEMPLATE_ID is null) then begin
    select
        WA.QUANT
      from WORKAREALIMIT WA
      where WA.WA_ID = :WA_ID
            and WA.W_ID = :TEMPLATE_ID
    into :RT_RQ;
    if (RT_RQ is null) then
      RT_RQ = 9999999;
  end
  else begin
    TEMPLATE_ID = -1;
    RT_RQ = 9999999;
  end

  /* Если установлено ограничение поищем свободные дни */
  if (WA_LIMIT >= 0) then begin
    I = ON_NEXT_DAY;
    while (FREE_DAY is null) do begin
      -- посчитаем кол-во заявок на день
      select
          count(*)
        from REQUEST R
             inner join HOUSE H on (R.HOUSE_ID = H.HOUSE_ID)
             inner join WORKGROUPS G on (H.WG_ID = G.WG_ID)
        where G.WA_ID = :WA_ID
              and R.RQ_PLAN_DATE = dateadd(:I day to current_date)
      into :RC;

      if (RC < WA_LIMIT) then begin
        -- Если число заявок меньше чем лимит
        -- Проверим не привысил лилимит конкретно по одной из работ
        if (TEMPLATE_ID > 0) then begin
          select
              count(*)
            from REQUEST R
                 inner join HOUSE H on (R.HOUSE_ID = H.HOUSE_ID)
                 inner join WORKGROUPS G on (H.WG_ID = G.WG_ID)
            where G.WA_ID = :WA_ID
                  and R.RQ_PLAN_DATE = dateadd(:I day to current_date)
                  and (R.RQTL_ID = :TEMPLATE_ID)
          into :RC_TPL;
        end
        if (((RC_TPL < RT_RQ) and (TEMPLATE_ID > 0)) -- ограничение по шаблону
            or
            (TEMPLATE_ID = -1)) -- ограничение по участку
        then begin
          VDAY = dateadd(I day to current_date);
          WD = extract(weekday from VDAY);
          -- пропустим воскресенье и субботу
          if (((WD <> 0) and (WD <> 6))
              or
              ((SKIP_WEEKEND = 0))) then
            FREE_DAY = VDAY;
        end
      end
      I = I + 1;
    end
  end
  else begin
    FREE_DAY = dateadd(ON_NEXT_DAY day to current_date);
    WD = extract(weekday from FREE_DAY);
    -- пропустим воскресенье и субботу
    if (SKIP_WEEKEND = 1) then begin
      if (WD = 0) then
        FREE_DAY = dateadd(1 day to FREE_DAY);
      if (WD = 6) then
        FREE_DAY = dateadd(2 day to FREE_DAY);
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE GET_SERVICES_FOR_IP (
    IP D_IP)
RETURNS (
    CUSTOMER_ID UID,
    SERVICE_ID UID,
    STATE D_INTEGER)
AS
declare variable VON D_INTEGER;
begin
  select
      l.CUSTOMER_ID,
      count(p.Service_Id)
    from tv_lan l
         left outer join Tv_Lan_Packets p on (l.Lan_Id = p.Lan_Id)
    where l.Ip = :IP
    group by 1
  into :CUSTOMER_ID, :VON;
  if (VON = 0) then begin
    -- Нет привязанных услуг. Выбираем все услуги абонента
    for select
            Service_Id,
            State
          from Api_Get_Customer_Services(:CUSTOMER_ID)
        into :SERVICE_ID, :STATE
    do
      suspend;
  end
  else begin
    -- Выбираем все привязанные услуги
    for select
            p.Service_Id,
            s.State
          from tv_lan l
               inner join Tv_Lan_Packets p on (l.Lan_Id = p.Lan_Id)
               inner join(select
                              Service_Id,
                              State
                            from Api_Get_Customer_Services(4)) s on (s.Service_Id = p.Service_Id)
          where l.Ip = :IP
        into :SERVICE_ID, :STATE
    do
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_SERVICES_TO_SWITCH (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
begin
  for select
          s.SERVICE_ID, s.SRV_TYPE_ID, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
          --, (select count(*) from subscr_serv h where h.serv_id = s.service_id and h.state_sgn = 1)
        from SERVICES S
             inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
        where sl.LINK_TYPE = 6
              and sl.Parent = :P_SERVICE
        order by s.NAME
      into :SERVICE_ID, :SRV_TYPE_ID, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
           --, :cnt
  do
    suspend;

end;


CREATE OR ALTER PROCEDURE GET_STATISTICS (
    S_DATE D_DATE,
    E_DATE D_DATE)
RETURNS (
    SERVICE_ID UID,
    CUSTOMER_ID UID,
    S_ON D_INTEGER,
    S_BLOCK D_INTEGER,
    P_NEW D_INTEGER,
    P_RETURN D_INTEGER,
    P_SWITCH D_INTEGER,
    P_OFF D_INTEGER,
    P_OFFSWITCH D_INTEGER,
    E_ON D_INTEGER,
    E_BLOCK D_INTEGER)
AS
declare variable V_SUBSCR_SERV_ID UID;
declare variable V_STATE D_INTEGER;
declare variable V_ST_DATE D_DATE;
declare variable V_ST_SRV D_INTEGER;
declare variable BUS_TYPE D_INTEGER;
declare variable V_SD D_DATE;
begin
  if (S_DATE is null) then
    S_DATE = current_date;
  if (E_DATE is null) then
    E_DATE = S_DATE;

  for select SS.CUSTOMER_ID, SS.SERV_ID, SS.SUBSCR_SERV_ID, SS.STATE_SGN, SS.STATE_DATE, SS.STATE_SRV, S.BUSINESS_TYPE
      from SUBSCR_SERV SS
      inner join SERVICES S on (SS.SERV_ID = S.SERVICE_ID)
            -- where ss.Customer_Id = 5710 --  (LS 4775)
            -- and s.service_id = 716042
      into :CUSTOMER_ID, :SERVICE_ID, :V_SUBSCR_SERV_ID, :V_STATE, :V_ST_DATE, :V_ST_SRV, :BUS_TYPE
  do
  begin
    S_ON = 0;
    S_BLOCK = 0;
    P_NEW = 0;
    P_RETURN = 0;
    P_SWITCH = 0;
    P_OFF = 0;
    P_OFFSWITCH = 0;
    E_ON = 0;
    E_BLOCK = 0;

    if ((V_ST_DATE < S_DATE) and
        (V_STATE = 1)) then
      S_ON = 1;
    else
    begin
      if ((V_ST_DATE = S_DATE) and
          (V_STATE = 0)) then
      begin
        S_ON = 1;
        if (V_ST_SRV <> -3) then
          P_OFF = 1;
        else
          S_BLOCK = 1;
      end
      else
      begin
        select SRV_ON, DATE_ON
        from CHECK_SRV_ACTIVE(:CUSTOMER_ID, :SERVICE_ID, :S_DATE)
        into :S_ON, :V_SD;
        if (V_SD = S_DATE) then
          S_ON = 0;
      end
    end

    -- Если отключен на начало, проверим. может он был в блокировке.
    if (S_ON = 0) then
    begin
      -- может был в блокировке?
      if ((V_ST_DATE <= S_DATE) and
          (V_STATE = 0) and
          (V_ST_SRV = -3)) then
        S_BLOCK = 1; -- В блокировке
      else
      begin
        select IN_BLOCK
        from CHECK_IN_BLOCK(:CUSTOMER_ID, :SERVICE_ID, :S_DATE)
        into :S_BLOCK;
      end
    end

    -- Если не новый и не в блокировке, то может в период что-то было
    if ((S_BLOCK = 0) and
        (S_ON = 0)) then
    begin
      -- может новый?
      P_NEW = iif(exists(select SH.SUBSCR_SERV_ID
                         from SUBSCR_HIST SH
                         where SH.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID
                               --and (((:V_CALC_TYPE <> 5) and (sh.DATE_FROM+0 between :s_date and dateadd(day, -1, :e_date)))
                               --  or ((:V_CALC_TYPE = 5) and (sh.DATE_FROM+0 between :s_date and :e_date)))
                               and
                               (SH.DATE_FROM+0) between :S_DATE and :E_DATE and
                               not exists(select H.SUBSCR_HIST_ID
                                          from SUBSCR_HIST H
                                          inner join SERVICES S on (H.SERV_ID = S.SERVICE_ID)
                                          where H.CUSTOMER_ID = SH.CUSTOMER_ID and
                                                S.BUSINESS_TYPE = :BUS_TYPE and
                                                (H.DATE_FROM+0) < :S_DATE)), 1, 0);
      -- может переключился?
      if (P_NEW = 0) then
      begin
        P_SWITCH = iif(exists(select SH.SUBSCR_SERV_ID
                              from SUBSCR_HIST SH
                              where SH.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID
                                    --and (((:V_CALC_TYPE <> 5) and (sh.DATE_FROM+0 between :s_date and dateadd(day, -1, :e_date)))
                                    --  or ((:V_CALC_TYPE = 5) and (sh.DATE_FROM+0 between :s_date and :e_date)))
                                    and
                                    (SH.DATE_FROM+0) between :S_DATE and :E_DATE and
                                    not exists(select H.SUBSCR_HIST_ID
                                               from SUBSCR_HIST H
                                               where H.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID and
                                                     (H.DATE_FROM+0)  < :S_DATE)), 1, 0);
      end
      -- может вернулся?
      if ((P_NEW = 0) and
          (P_SWITCH = 0)) then
      begin
        P_RETURN = iif(exists(select SH.SUBSCR_SERV_ID
                              from SUBSCR_HIST SH
                              where SH.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID and
                                    (SH.DATE_FROM+0) between :S_DATE and :E_DATE and
                                    exists(select H.SUBSCR_HIST_ID
                                           from SUBSCR_HIST H
                                           where H.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID and
                                                 (H.DATE_FROM+0)  < :S_DATE)), 1, 0);
      end
    end

    -- если был активен за период может он отключился?
    if ((S_ON = 1) or (S_BLOCK = 1) or (P_NEW = 1) or (P_RETURN = 1) or (P_SWITCH = 1)) then
    begin
      if (P_OFF <> 1) then
        select SRV_OFF
        from CHECK_IN_OFF(:CUSTOMER_ID, :SERVICE_ID, :E_DATE)
        into :P_OFF;
      -- если отключен, может он ушел на другой тариф
      if (P_OFF = 1) then
      begin
        P_OFFSWITCH = iif(exists(select SH.SUBSCR_SERV_ID
                                 from SUBSCR_HIST SH
                                 where SH.SUBSCR_SERV_ID = :V_SUBSCR_SERV_ID and
                                       exists(select H.SUBSCR_HIST_ID
                                              from SUBSCR_HIST H
                                              inner join SERVICES S on (H.SERV_ID = S.SERVICE_ID)
                                              where H.CUSTOMER_ID = SH.CUSTOMER_ID and
                                                    H.SUBSCR_SERV_ID <> :V_SUBSCR_SERV_ID and
                                                    S.BUSINESS_TYPE = :BUS_TYPE and
                                                    (H.DATE_FROM+0) between :S_DATE and :E_DATE)), 1, 0);
        if (P_OFFSWITCH = 1) then
          P_OFF = 0;

      end
    end

    if ((V_ST_DATE <= E_DATE) and
        (V_STATE = 0) and
        (V_ST_SRV <> -3)) then
      E_ON = 0;
    else
    begin
      if (P_OFF = 0) then
        select SRV_ON
        from CHECK_SRV_ACTIVE(:CUSTOMER_ID, :SERVICE_ID, :E_DATE)
        into E_ON;
    end

    if (E_ON = 0) then
    begin
      -- Если отключен на конец, проверим. может он был в блокировке
      if ((V_ST_DATE <= E_DATE) and
          (V_STATE = 0) and
          (V_ST_SRV = -3)) then
      begin
        E_ON = 1;
        E_BLOCK = 1; -- В блокировке
      end
      else
      begin
        select IN_BLOCK
        from CHECK_IN_BLOCK(:CUSTOMER_ID, :SERVICE_ID, :E_DATE)
        into :E_BLOCK;
      end
    end
    if (S_BLOCK = 1) then
      S_ON = 0;
    if (E_BLOCK = 1) then
      E_ON = 0;

    suspend;
  end
end;


CREATE OR ALTER PROCEDURE GET_TARIF_SUM_CUSTOMER_SRV (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL = null,
    FOR_DAY D_DATE = null)
RETURNS (
    M_TARIF D_N15_4)
AS
declare variable Jur     D_Integer;
declare variable SRV     UID;
declare variable ALL_SUM D_N15_4;
begin
  For_Day = coalesce(For_Day, current_date);
  M_Tarif = null;

  select
      coalesce(c.Juridical, 0)
    from customer c
    where c.Customer_Id = :Customer_Id
  into :JUR;

  for select
          sh.Serv_Id
        from Subscr_hist sh
        where sh.Customer_Id = :Customer_Id
              and ((sh.Serv_Id = :Service_Id)
                or (:Service_Id is null))
              and :For_Day between sh.Date_From and sh.Date_To
      union
      select
          ss.Serv_Id
        from subscr_serv ss
        where ss.Customer_Id = :Customer_Id
              and ss.State_Srv = -3
              and (ss.Serv_Id = :Service_Id
                or (:Service_Id is null))
      into :srv
  do begin
    ALL_SUM = GET_SRV_TARIF_FOR_CUSTOMER(:Customer_Id, :SRV, :FOR_DAY, :Jur);

    M_Tarif = coalesce(M_Tarif, 0) + coalesce(ALL_SUM, 0);
  end
  M_TARIF = round(M_TARIF, 2);
  suspend;
end;


CREATE OR ALTER PROCEDURE GETSERVICES (
    P_CUSTOMER_ID TYPE OF UID,
    P_TYPE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
--declare variable cnt d_integer;
begin
  if (P_TYPE = 0) then
    for select
            s.SERVICE_ID, s.SRV_TYPE_ID, s.SHIFT_MONTHS, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
            --, (select count(*) from subscr_serv h where h.serv_id = s.service_id and h.state_sgn = 1)
          from SERVICES S
               inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
          where sl.LINK_TYPE = 0
                and (not exists(select
                                    SS.SERV_ID
                                  from SUBSCR_SERV SS
                                  where SS.CUSTOMER_ID = :P_customer_id
                                        and ss.Serv_Id = S.SERVICE_ID))
          order by s.NAME
        into :SERVICE_ID, :SRV_TYPE_ID, :SHIFT_MONTHS, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
             --, :cnt
    do
      suspend;
  else begin
    for select
            s.SERVICE_ID, s.SRV_TYPE_ID, s.SHIFT_MONTHS, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
          from SERVICES S
               inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
          where sl.LINK_TYPE = 1
          order by s.NAME
        into :SERVICE_ID, :SRV_TYPE_ID, :SHIFT_MONTHS, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
    do
      suspend;
  end
end;


CREATE OR ALTER PROCEDURE GETSERVICESTOSWITCH (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE TYPE OF UID)
RETURNS (
    SERVICE_ID TYPE OF UID,
    SRV_TYPE_ID TYPE OF UID,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5)
AS
begin
  for select
          s.SERVICE_ID, s.SRV_TYPE_ID, s.NAME, s.SHORTNAME, s.DESCRIPTION, s.DIMENSION
          --, (select count(*) from subscr_serv h where h.serv_id = s.service_id and h.state_sgn = 1)
        from SERVICES S
             inner join SERVICES_LINKS sl on (S.SERVICE_ID = sl.CHILD)
        where sl.LINK_TYPE = 6
              and sl.Parent = :P_SERVICE
        order by s.NAME
      into :SERVICE_ID, :SRV_TYPE_ID, :NAME, :SHORTNAME, :DESCRIPTION, :DIMENSION
           --, :cnt
  do
    suspend;

end;


CREATE OR ALTER PROCEDURE HOUSE_IUD (
    OPERATION D_CHAR1,
    HOUSE_ID TYPE OF UID = null,
    STREET_ID TYPE OF UID = null,
    HOUSE_NO TYPE OF D_VARCHAR10 = null,
    Q_FLAT TYPE OF D_INTEGER = null,
    SUBAREA_ID TYPE OF D_UID_NULL = null,
    CHAIRMAN TYPE OF D_VARCHAR50 = null,
    CHAIRMAN_PHONE TYPE OF D_VARCHAR20 = null,
    NOTICE TYPE OF D_NOTICE = null,
    HOUSE_BLB TYPE OF D_UID_NULL = null,
    ORG_ID TYPE OF D_UID_NULL = null,
    POST_INDEX TYPE OF D_VARCHAR6 = null,
    HEADEND_ID TYPE OF D_UID_NULL = null,
    HOUSE_CODE TYPE OF D_VARCHAR6 = null,
    EXIST_TV TYPE OF D_IBOOLEAN = null,
    EXIST_LAN TYPE OF D_IBOOLEAN = null,
    EXIST_DTV TYPE OF D_IBOOLEAN = null,
    WG_ID TYPE OF D_UID_NULL = null)
AS
declare variable CCOUNT d_INTEGER;
begin
  if (OPERATION = 'U') then begin
    update house
    set street_id = :street_id,
        house_no = :house_no,
        q_flat = :q_flat,
        subarea_id = :subarea_id,
        chairman = :chairman,
        chairman_phone = :chairman_phone,
        notice = :notice,
        house_blb = :house_blb,
        org_id = :org_id,
        post_index = :post_index,
        headend_id = :headend_id,
        house_code = :house_code,
        exist_tv = :exist_tv,
        exist_lan = :exist_lan,
        exist_dtv = :exist_dtv,
        WG_ID = :WG_ID
    where (house_id = :house_id);
  end

  if (OPERATION = 'I') then begin
    select
        count(*)
      from HOUSE
      where STREET_ID = :STREET_ID
            and HOUSE_NO = :HOUSE_NO
    into ccount;
    if (ccount = 0) then
      insert into house (house_id, street_id, house_no, q_flat, subarea_id, chairman, chairman_phone, notice, house_blb, org_id, post_index, headend_id, house_code, exist_tv, exist_lan, exist_dtv, WG_ID)
      values (:house_id, :street_id, :house_no, :q_flat, :subarea_id, :chairman, :chairman_phone, :notice, :house_blb, :org_id, :post_index, :headend_id, :house_code, :exist_tv, :exist_lan, :exist_dtv, :WG_ID);
  end

  if (OPERATION = 'D') then begin
    ccount = 0;
    select
        count(*)
      from CUSTOMER
      where HOUSE_ID = :HOUSE_ID
    into ccount;
    if (ccount = 0) then
      select
          count(*)
        from REQUEST
        where HOUSE_ID = :HOUSE_ID
      into ccount;
    if (ccount = 0) then
      select
          count(*)
        from Nodes
        where HOUSE_ID = :HOUSE_ID
      into ccount;
    if (ccount = 0) then
      delete from HOUSE where (HOUSE_ID = :HOUSE_ID);
    else
      exception E_CANNOT_DELETE;
  end
end;


CREATE OR ALTER PROCEDURE HOUSE_MAP (
    A_HOUSE_ID TYPE OF UID)
RETURNS (
    PORCH_ID TYPE OF UID,
    FLOOR_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PORCH_N TYPE OF D_VARCHAR10,
    FLOOR_N TYPE OF D_VARCHAR10,
    FLAT_N TYPE OF D_FLAT)
AS
declare variable v_flat_from type of d_integer;
declare variable v_flat_to type of d_integer;
declare variable i type of d_integer;
declare variable f_null type of d_integer;
declare variable f_adds type of d_varchar10;
declare variable v_str type of d_varchar10;
begin
/*
  for
    select
      p.porch_id,
      p.porch_n,
      f.floor_id,
      f.floor_n,
      f.flat_from,
      f.flat_to
    from houseporch p
      inner join housefloor f on (p.porch_id = f.porch_id)
    where p.house_id = :a_house_id
      order by p.porch_n, f.floor_n
    into :porch_id, :porch_n, :floor_id, :floor_n, :v_flat_from, :v_flat_to
  do begin
    i = v_flat_from;

    while (i<=v_flat_to) do begin
      f_null = 0; -- признак того что в базе есть абонент в такой квартире
      for
        select
          c.customer_id, c.flat_no
        from customer c where c.house_id = :a_house_id and c.flat_no starting cast(:i as varchar(10))
        into :customer_id, :f_adds
      do begin
        v_str = i;

        if (f_adds = v_str) then begin
        -- если номер квартиры совпадает с номером квартиры абонента
          f_null = 1;
          suspend;
        end
        else begin
          -- проверим это литера квартиры или номер
          -- исключим цифры
          v_str = SUBSTRING(f_adds from char_length(v_str) + 1 FOR 1 );
          if (v_str not in ('0','1','2','3','4','5','6','7','8','9'))
          then begin
            f_null = 1;
            suspend;
          end
        end

      end
      if (f_null = 0) -- если абонента нет, то выведем квартиру с нуловым абонентом
      then begin
        flat_n = i;
        customer_id = null;
        suspend;
      end
      i = i + 1;
    end
  end
*/
end;


CREATE OR ALTER PROCEDURE INDICES_REACTIVATE
AS
BEGIN
  EXECUTE PROCEDURE INDICES_SWITCH(0);
  EXECUTE PROCEDURE INDICES_SWITCH(1);
END;


CREATE OR ALTER PROCEDURE INDICES_REBUILD_SELECTIVITY
AS
DECLARE VARIABLE S D_VARCHAR1000;
BEGIN
  /*Процедура для перерасчета селективности индексов, запускать переодически (если не было ресторинга БД),
  либо в случае больших изменений в БД.*/
  FOR SELECT RDB$INDEX_NAME FROM RDB$INDICES INTO :S DO
  BEGIN
    S = 'SET statistics INDEX ' || S || ';';
    EXECUTE STATEMENT :S;
  END
  SUSPEND;
END;


CREATE OR ALTER PROCEDURE INDICES_SWITCH (
    ENABLE_FLAG D_INTEGER)
AS
DECLARE VARIABLE RELATION_NAME d_VARCHAR1000;
DECLARE VARIABLE INDEX_INACTIVE d_INTEGER;
DECLARE VARIABLE ACTION_NAME d_VARCHAR50;
DECLARE VARIABLE SQL d_VARCHAR1000;
BEGIN
  /* Переключает состояние индексов */
  /* source SQL
  SELECT R.RDB$CONSTRAINT_NAME, R.RDB$INDEX_NAME AS REFINDEXNAME, I.RDB$INDEX_NAME AS REALINDEX, I.RDB$RELATION_NAME, I.RDB$INDEX_INACTIVE 
  FROM RDB$INDICES I RIGHT JOIN RDB$RELATION_CONSTRAINTS R ON I.RDB$INDEX_NAME = R.RDB$INDEX_NAME 
  WHERE R.RDB$CONSTRAINT_TYPE = 'FOREIGN KEY' OR R.RDB$CONSTRAINT_TYPE = 'PRIMARY KEY'
  ORDER BY R.RDB$CONSTRAINT_NAME
  */
  --Все активные переводим в неактивные (default)
  INDEX_INACTIVE = 0;
  ACTION_NAME = 'INACTIVE';
  IF (ENABLE_FLAG > 0) THEN
  BEGIN
    --Перевод в активное состояние
    INDEX_INACTIVE = 3;
    ACTION_NAME = 'ACTIVE';
  END
 
  FOR SELECT I.RDB$INDEX_NAME
  FROM RDB$INDICES I
  RIGHT JOIN RDB$RELATION_CONSTRAINTS R ON I.RDB$INDEX_NAME = R.RDB$INDEX_NAME 
  WHERE (R.RDB$CONSTRAINT_TYPE = 'FOREIGN KEY' OR R.RDB$CONSTRAINT_TYPE = 'PRIMARY KEY')
        AND (I.RDB$INDEX_INACTIVE = :INDEX_INACTIVE)
  INTO :RELATION_NAME DO
  BEGIN
    SQL = 'ALTER INDEX ' || RELATION_NAME || ' ' || ACTION_NAME;
    IF (SQL IS NOT NULL) THEN EXECUTE STATEMENT SQL;
  END
END;


CREATE OR ALTER PROCEDURE INT2IP (
    INT_IP D_N10)
RETURNS (
    STR_IP D_IP)
AS
begin
  Str_IP = INET_NTOA(INT_IP);
  suspend;
end;


CREATE OR ALTER PROCEDURE INTTOHEX (
    INPUTNUMBER D_BIGINT)
RETURNS (
    OUTPUTNUMBER D_VARCHAR10)
AS
declare variable Q D_bigint;
declare variable R D_bigint;
declare variable T D_bigint;
declare variable H D_Char1;
declare variable S D_Varchar6;
begin
  /* Max input value allowed is: 4294967295 */
  S = 'ABCDEF';
  Q = 1;
  OUTPUTNUMBER = '';
  T = INPUTNUMBER;
  while (Q <> 0) do begin
    Q = T / 16;
    R = mod(T, 16);
    T = Q;
    if (R > 9) then
      H = substring(S from (R - 9) for 1);
    else
      H = R;
    OUTPUTNUMBER = H || OUTPUTNUMBER;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE IP2INT (
    AIP D_IP)
RETURNS (
    INT_IP D_N10)
AS
begin
  int_ip = INET_ATON(:AIP);
  suspend;
end;


CREATE OR ALTER PROCEDURE MAT_MOVE_DETAILS (
    M_ID TYPE OF UID,
    WH_ID TYPE OF UID,
    SDATE D_DATE,
    EDATE D_DATE)
RETURNS (
    MOVE_DAY D_DATE,
    Q_WH_IN D_N15_5,
    Q_WH_OUT D_N15_5,
    Q_REQ_OUT D_N15_5,
    Q_REQ_IN D_N15_5,
    REQ_OUT D_VARCHAR1000,
    REQ_IN D_VARCHAR1000,
    NOTICE D_VARCHAR255,
    KEEP D_N15_5)
AS
declare variable CUR_DAY D_DATE;
declare variable MAX_DAY D_DATE;
declare variable MIN_DAY D_DATE;
declare variable Q_TMP   D_N15_5;
declare variable R_OUT   D_VARCHAR1000;
declare variable R_IN    D_VARCHAR1000;

begin
  -- если даты периода не заданы, найдем минимальную и максимальную дату движения материала
  if ((SDATE is null)
      or
      (EDATE is null)) then begin
    select
        min(cast(rm.Added_On as date))
      , max(cast(rm.Added_On as date))
      from Request_Materials rm
      where rm.M_Id = :m_id
            and rm.Wh_Id = :Wh_Id
    into :MIN_DAY, :MAX_DAY;

    select
        min(d.DOC_DATE)
      , max(d.DOC_DATE)
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 2
            and d.From_Wh = :wh_id
            and md.M_Id = :m_id
    into :move_day, :CUR_DAY;
    move_day = coalesce(move_day, MIN_DAY);
    CUR_DAY = coalesce(CUR_DAY, MAX_DAY);
    if (move_day < MIN_DAY) then
      MIN_DAY = move_day;
    if (CUR_DAY > MAX_DAY) then
      MAX_DAY = CUR_DAY;
    move_day = null;
    CUR_DAY = null;
    select
        min(d.DOC_DATE)
      , max(d.DOC_DATE)
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.Dt_Id <> 2
    into :move_day, :CUR_DAY;
    move_day = coalesce(move_day, MIN_DAY);
    CUR_DAY = coalesce(CUR_DAY, MAX_DAY);
    if (move_day < MIN_DAY) then
      MIN_DAY = move_day;
    if (CUR_DAY > MAX_DAY) then
      MAX_DAY = CUR_DAY;
    move_day = null;
    CUR_DAY = null;

    select
        min(cast(rm.Added_On as date))
      , max(cast(rm.Added_On as date))
      from Request_Materials_Return rm
      where rm.M_Id = :m_id
            and rm.Wh_Id = :Wh_Id
    into :move_day, :CUR_DAY;
    move_day = coalesce(move_day, MIN_DAY);
    CUR_DAY = coalesce(CUR_DAY, MAX_DAY);
    if (move_day < MIN_DAY) then
      MIN_DAY = move_day;
    if (CUR_DAY > MAX_DAY) then
      MAX_DAY = CUR_DAY;
    move_day = null;
  end
  else begin
    MIN_DAY = SDATE;
    MAX_DAY = EDATE;
  end

  CUR_DAY = MIN_DAY;
  keep = 0;
  REQ_OUT = '';
  REQ_IN = '';
  while (CUR_DAY <= MAX_DAY) do begin
    MIN_DAY = dateadd(day, 1, :CUR_DAY);

    -- + 1приход
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 1
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_IN = coalesce(Q_TMP, 0);
    -- + 2перемещение на склад
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 2
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_IN = Q_WH_IN + coalesce(Q_TMP, 0);
    -- + 4корректировка
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 4
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_IN = Q_WH_IN + coalesce(Q_TMP, 0);
    -- + 5инвентаризация
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 5
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_IN = Q_WH_IN + coalesce(Q_TMP, 0);

    -- - перемещение со склада
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 2
            and d.From_Wh = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_OUT = coalesce(Q_TMP, 0);

    -- - 3списание
    Q_TMP = null;
    select
        sum(coalesce(M_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 3
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_OUT = Q_WH_OUT + coalesce(Q_TMP, 0);
    -- - инвентаризация
    Q_TMP = null;
    select
        sum(coalesce(b_Quant, 0))
      from Material_Docs d
           inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
      where d.Doc_Closed = 1
            and d.Dt_Id = 5
            and d.Wh_Id = :wh_id
            and md.M_Id = :m_id
            and d.DOC_DATE >= :CUR_DAY
            and d.DOC_DATE < :MIN_DAY
    into :Q_TMP;
    Q_WH_OUT = Q_WH_OUT + coalesce(Q_TMP, 0);

    -- + вернули с заявок
    Q_TMP = null;
    select
        sum(coalesce(rm.Quant, 0)), list(distinct rm.Rq_Id)
      from Request_Materials_Return rm
      where rm.M_Id = :m_id
            and rm.Wh_Id = :Wh_Id
            and rm.Added_On >= :CUR_DAY
            and rm.Added_On < :MIN_DAY
    into :Q_TMP, :R_IN;
    Q_REQ_IN = coalesce(Q_TMP, 0);
    REQ_IN = coalesce(R_IN, '');
    -- - списано на заявку
    Q_TMP = null;
    select
        sum(coalesce(Rm_Quant, 0)), list(distinct rm.Rq_Id)
      from Request_Materials rm
      where rm.M_Id = :m_id
            and rm.Wh_Id = :Wh_Id
            and rm.Added_On >= :CUR_DAY
            and rm.Added_On < :MIN_DAY
    into :Q_TMP, :R_OUT;
    Q_REQ_OUT = coalesce(Q_TMP, 0);
    REQ_OUT = coalesce(R_OUT, '');

    keep = keep + Q_WH_IN - Q_WH_OUT - Q_REQ_OUT + Q_REQ_IN;
    move_day = CUR_DAY;
    if ((Q_WH_IN <> 0)
        or
        (Q_WH_OUT <> 0)
        or
        (Q_REQ_OUT <> 0)
        or
        (Q_REQ_IN <> 0)) then
      suspend;


    CUR_DAY = dateadd(day, 1, CUR_DAY);
    Q_WH_IN = null;
    Q_WH_OUT = null;
    Q_REQ_OUT = null;
    Q_REQ_IN = null;
    R_OUT = null;
    R_IN = null;
  end
end;


CREATE OR ALTER PROCEDURE MATERIAL_DOCS_DELETE (
    DOC_ID INTEGER)
AS
declare variable DOC_CLOSED d_integer;
begin
  select
      DOC_CLOSED
    from Material_Docs
    where (Doc_Id = :Doc_Id)
  into :DOC_CLOSED;
  DOC_CLOSED = coalesce(DOC_CLOSED, 0);

  if (DOC_CLOSED = 0) then begin
    delete from Materials_In_Doc where (Doc_Id = :Doc_Id);
    delete from Material_Docs where (Doc_Id = :Doc_Id);
  end
end;


CREATE OR ALTER PROCEDURE MATERIAL_REMAIN_RECALC (
    M_ID TYPE OF UID,
    FOR_WH TYPE OF UID = null)
AS
declare variable Wh_Id     type of Uid;
declare variable Mr_Quant  type of D_N15_5;
declare variable Quant     type of D_N15_5;
-- declare variable from_date type of D_Date;
begin
  if (M_ID is null) then M_ID = -9999;

  Mr_Quant = 0;

  for
    select O_Id from objects where O_Type = 10 and ((:FOR_WH is null) or (O_ID = :FOR_WH))
    into :wh_id
  do begin
    -- + 1приход
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 1 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = coalesce(quant, 0);
    -- + 2перемещение на склад
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 2 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant + coalesce(quant, 0);
    -- + 4корректировка
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 4 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant + coalesce(quant, 0);
    -- + 5инвентаризация
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 5 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant + coalesce(quant, 0);
    -- + вернули с заявок
    Quant = null;
    select sum(coalesce(rm.Quant,0)) from Request_Materials_Return rm inner join request r on (rm.Rq_Id = r.Rq_Id)
    where rm.M_Id = :m_id and rm.Wh_Id = :Wh_Id -- and r.Added_On > :from_date
    into :Quant;
    Mr_Quant = Mr_Quant + coalesce(quant, 0);
    -- - перемещение со склада
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 2 and d.From_Wh = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant - coalesce(quant, 0);
    -- - 3списание
    Quant = null;
    select sum(coalesce(M_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 3 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant - coalesce(quant, 0);
    -- - инвентаризация
    Quant = null;
    select sum(coalesce(b_Quant,0)) from Material_Docs d inner join Materials_In_Doc md on (d.Doc_Id = md.Doc_Id)
    where d.Doc_Closed = 1 and d.Dt_Id = 5 and d.Wh_Id = :wh_id and md.M_Id = :m_id
    into :quant;
    Mr_Quant = Mr_Quant - coalesce(quant, 0);
    -- - списано на заявку
    Quant = null;
    select sum(coalesce(Rm_Quant,0)) from Request_Materials rm inner join request r on (rm.Rq_Id = r.Rq_Id)
    where rm.M_Id = :m_id and rm.Wh_Id = :Wh_Id
    into :Quant;
    Mr_Quant = Mr_Quant - coalesce(quant, 0);

    -- внесем остатки на склад
    update or insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
    values (:M_Id, :Wh_Id, :Mr_Quant)
    matching (M_Id, Wh_Id);
  end
end;


CREATE OR ALTER PROCEDURE MD5 (
    SOURCE BLOB SUB_TYPE 1 SEGMENT SIZE 80)
RETURNS (
    RES CHAR(32) CHARACTER SET OCTETS)
AS
declare variable A bigint = 0X0067452301;
declare variable B bigint = 0X00EFCDAB89;
declare variable C bigint = 0X0098BADCFE;
declare variable D bigint = 0X0010325476;
declare variable AA bigint;
declare variable BB bigint;
declare variable CC bigint;
declare variable DD bigint;
declare variable BUF char(64) character set OCTETS;
declare variable LEN bigint;
declare variable M integer;
declare variable N integer;
begin
  len = octet_length(source);
  m = 56 - mod(len + 1, 64);
  if (m < 0) then m = m + 64;
  source = source || rpad(x'80', m+1, x'00') ||
    (select res from md5_IntToChar4(bin_and(0x00FFFFFFFF, bin_shl(:len, 3)))) ||
    (select res from md5_IntToChar4(bin_shr(:len, 32-3)));

  n = 0;
  while (n < (len+m+9) / 64) do
  begin
    AA = A;
    BB = B;
    CC = C;
    DD = D;

    buf = substring(source from n * 64 + 1 for 64);

    /* Round 1 */
    A = (select res from md5_F(:A, :B, :C, :D,  0,  7, 0x00d76aa478, 1, :buf)); /* 1 */
    D = (select res from md5_F(:D, :A, :B, :C,  1, 12, 0x00e8c7b756, 1, :buf)); /* 2 */
    C = (select res from md5_F(:C, :D, :A, :B,  2, 17, 0x00242070db, 1, :buf)); /* 3 */
    B = (select res from md5_F(:B, :C, :D, :A,  3, 22, 0x00c1bdceee, 1, :buf)); /* 4 */
    A = (select res from md5_F(:A, :B, :C, :D,  4,  7, 0x00f57c0faf, 1, :buf)); /* 5 */
    D = (select res from md5_F(:D, :A, :B, :C,  5, 12, 0x004787c62a, 1, :buf)); /* 6 */
    C = (select res from md5_F(:C, :D, :A, :B,  6, 17, 0x00a8304613, 1, :buf)); /* 7 */
    B = (select res from md5_F(:B, :C, :D, :A,  7, 22, 0x00fd469501, 1, :buf)); /* 8 */
    A = (select res from md5_F(:A, :B, :C, :D,  8,  7, 0x00698098d8, 1, :buf)); /* 9 */
    D = (select res from md5_F(:D, :A, :B, :C,  9, 12, 0x008b44f7af, 1, :buf)); /* 10 */
    C = (select res from md5_F(:C, :D, :A, :B, 10, 17, 0x00ffff5bb1, 1, :buf)); /* 11 */
    B = (select res from md5_F(:B, :C, :D, :A, 11, 22, 0x00895cd7be, 1, :buf)); /* 12 */
    A = (select res from md5_F(:A, :B, :C, :D, 12,  7, 0x006b901122, 1, :buf)); /* 13 */
    D = (select res from md5_F(:D, :A, :B, :C, 13, 12, 0x00fd987193, 1, :buf)); /* 14 */
    C = (select res from md5_F(:C, :D, :A, :B, 14, 17, 0x00a679438e, 1, :buf)); /* 15 */
    B = (select res from md5_F(:B, :C, :D, :A, 15, 22, 0x0049b40821, 1, :buf)); /* 16 */

    /* Round 2 */
    A = (select res from md5_F(:A, :B, :C, :D,  1,  5, 0x00f61e2562, 2, :buf)); /* 17 */
    D = (select res from md5_F(:D, :A, :B, :C,  6,  9, 0x00c040b340, 2, :buf)); /* 18 */
    C = (select res from md5_F(:C, :D, :A, :B, 11, 14, 0x00265e5a51, 2, :buf)); /* 19 */
    B = (select res from md5_F(:B, :C, :D, :A,  0, 20, 0x00e9b6c7aa, 2, :buf)); /* 20 */
    A = (select res from md5_F(:A, :B, :C, :D,  5,  5, 0x00d62f105d, 2, :buf)); /* 21 */
    D = (select res from md5_F(:D, :A, :B, :C, 10,  9, 0x0002441453, 2, :buf)); /* 22 */
    C = (select res from md5_F(:C, :D, :A, :B, 15, 14, 0x00d8a1e681, 2, :buf)); /* 23 */
    B = (select res from md5_F(:B, :C, :D, :A,  4, 20, 0x00e7d3fbc8, 2, :buf)); /* 24 */
    A = (select res from md5_F(:A, :B, :C, :D,  9,  5, 0x0021e1cde6, 2, :buf)); /* 25 */
    D = (select res from md5_F(:D, :A, :B, :C, 14,  9, 0x00c33707d6, 2, :buf)); /* 26 */
    C = (select res from md5_F(:C, :D, :A, :B,  3, 14, 0x00f4d50d87, 2, :buf)); /* 27 */
    B = (select res from md5_F(:B, :C, :D, :A,  8, 20, 0x00455a14ed, 2, :buf)); /* 28 */
    A = (select res from md5_F(:A, :B, :C, :D, 13,  5, 0x00a9e3e905, 2, :buf)); /* 29 */
    D = (select res from md5_F(:D, :A, :B, :C,  2,  9, 0x00fcefa3f8, 2, :buf)); /* 30 */
    C = (select res from md5_F(:C, :D, :A, :B,  7, 14, 0x00676f02d9, 2, :buf)); /* 31 */
    B = (select res from md5_F(:B, :C, :D, :A, 12, 20, 0x008d2a4c8a, 2, :buf)); /* 32 */

    /* Round 3 */
    A = (select res from md5_F(:A, :B, :C, :D,  5,  4, 0x00fffa3942, 3, :buf)); /* 33 */
    D = (select res from md5_F(:D, :A, :B, :C,  8, 11, 0x008771f681, 3, :buf)); /* 34 */
    C = (select res from md5_F(:C, :D, :A, :B, 11, 16, 0x006d9d6122, 3, :buf)); /* 35 */
    B = (select res from md5_F(:B, :C, :D, :A, 14, 23, 0x00fde5380c, 3, :buf)); /* 36 */
    A = (select res from md5_F(:A, :B, :C, :D,  1,  4, 0x00a4beea44, 3, :buf)); /* 37 */
    D = (select res from md5_F(:D, :A, :B, :C,  4, 11, 0x004bdecfa9, 3, :buf)); /* 38 */
    C = (select res from md5_F(:C, :D, :A, :B,  7, 16, 0x00f6bb4b60, 3, :buf)); /* 39 */
    B = (select res from md5_F(:B, :C, :D, :A, 10, 23, 0x00bebfbc70, 3, :buf)); /* 40 */
    A = (select res from md5_F(:A, :B, :C, :D, 13,  4, 0x00289b7ec6, 3, :buf)); /* 41 */
    D = (select res from md5_F(:D, :A, :B, :C,  0, 11, 0x00eaa127fa, 3, :buf)); /* 42 */
    C = (select res from md5_F(:C, :D, :A, :B,  3, 16, 0x00d4ef3085, 3, :buf)); /* 43 */
    B = (select res from md5_F(:B, :C, :D, :A,  6, 23, 0x0004881d05, 3, :buf)); /* 44 */
    A = (select res from md5_F(:A, :B, :C, :D,  9,  4, 0x00d9d4d039, 3, :buf)); /* 45 */
    D = (select res from md5_F(:D, :A, :B, :C, 12, 11, 0x00e6db99e5, 3, :buf)); /* 46 */
    C = (select res from md5_F(:C, :D, :A, :B, 15, 16, 0x001fa27cf8, 3, :buf)); /* 47 */
    B = (select res from md5_F(:B, :C, :D, :A,  2, 23, 0x00c4ac5665, 3, :buf)); /* 48 */

    /* Round 4 */
    A = (select res from md5_F(:A, :B, :C, :D,  0,  6, 0x00f4292244, 4, :buf)); /* 49 */
    D = (select res from md5_F(:D, :A, :B, :C,  7, 10, 0x00432aff97, 4, :buf)); /* 50 */
    C = (select res from md5_F(:C, :D, :A, :B, 14, 15, 0x00ab9423a7, 4, :buf)); /* 51 */
    B = (select res from md5_F(:B, :C, :D, :A,  5, 21, 0x00fc93a039, 4, :buf)); /* 52 */
    A = (select res from md5_F(:A, :B, :C, :D, 12,  6, 0x00655b59c3, 4, :buf)); /* 53 */
    D = (select res from md5_F(:D, :A, :B, :C,  3, 10, 0x008f0ccc92, 4, :buf)); /* 54 */
    C = (select res from md5_F(:C, :D, :A, :B, 10, 15, 0x00ffeff47d, 4, :buf)); /* 55 */
    B = (select res from md5_F(:B, :C, :D, :A,  1, 21, 0x0085845dd1, 4, :buf)); /* 56 */
    A = (select res from md5_F(:A, :B, :C, :D,  8,  6, 0x006fa87e4f, 4, :buf)); /* 57 */
    D = (select res from md5_F(:D, :A, :B, :C, 15, 10, 0x00fe2ce6e0, 4, :buf)); /* 58 */
    C = (select res from md5_F(:C, :D, :A, :B,  6, 15, 0x00a3014314, 4, :buf)); /* 59 */
    B = (select res from md5_F(:B, :C, :D, :A, 13, 21, 0x004e0811a1, 4, :buf)); /* 60 */
    A = (select res from md5_F(:A, :B, :C, :D,  4,  6, 0x00f7537e82, 4, :buf)); /* 61 */
    D = (select res from md5_F(:D, :A, :B, :C, 11, 10, 0x00bd3af235, 4, :buf)); /* 62 */
    C = (select res from md5_F(:C, :D, :A, :B,  2, 15, 0x002ad7d2bb, 4, :buf)); /* 63 */
    B = (select res from md5_F(:B, :C, :D, :A,  9, 21, 0x00eb86d391, 4, :buf)); /* 64 */

    A = bin_and(0x00FFFFFFFF, AA + A);
    B = bin_and(0x00FFFFFFFF, BB + B);
    C = bin_and(0x00FFFFFFFF, CC + C);
    D = bin_and(0x00FFFFFFFF, DD + D);
    n = n + 1;
  end

  res =
    (select res from md5_IntToHex(:a))||
    (select res from md5_IntToHex(:b))||
    (select res from md5_IntToHex(:c))||
    (select res from md5_IntToHex(:d));
    suspend;
end;


CREATE OR ALTER PROCEDURE MD5_F (
    A BIGINT,
    B BIGINT,
    C BIGINT,
    D BIGINT,
    K INTEGER,
    S INTEGER,
    T BIGINT,
    P INTEGER,
    V CHAR(64) CHARACTER SET OCTETS)
RETURNS (
    RES BIGINT)
AS
declare variable FF bigint;
declare variable R bigint;
declare variable X bigint;
begin
  X = bin_or(ascii_val(substring(V from k*4 + 1 for 1)),
             bin_shl(ascii_val(substring(V from k*4 + 2 for 1)), 8),
             bin_shl(ascii_val(substring(V from k*4 + 3 for 1)),16),
             bin_shl(ascii_val(substring(V from k*4 + 4 for 1)),24));

  if (p = 1) then /* f */
    ff = bin_or(bin_and(b, c), bin_and(bin_not(b), d));
  if (p = 2) then /* g */
    ff = bin_or(bin_and(b, d), bin_and(bin_not(d), c));
  if (p = 3) then /* h */
    ff = bin_xor(b, c, d);
  if (p = 4) then /* i */
    ff = bin_xor(c, bin_or(bin_not(d), b));

  r = bin_and(0x00FFFFFFFF, a + ff + x + t);
  r = bin_and(0x00FFFFFFFF, b + bin_or(bin_shl(r, s), bin_shr(r, 32 - s)));
  res = r;
  suspend;
end;


CREATE OR ALTER PROCEDURE MD5_INTTOCHAR4 (
    V BIGINT)
RETURNS (
    RES CHAR(4) CHARACTER SET OCTETS)
AS
begin
  res =  ascii_char(bin_and(0xFF, V))||
         ascii_char(bin_and(0xFF, bin_shr(V, 8)))||
         ascii_char(bin_and(0xFF, bin_shr(V, 16)))||
         ascii_char(bin_and(0xFF, bin_shr(V, 24)));
  suspend;
end;


CREATE OR ALTER PROCEDURE MD5_INTTOHEX (
    V BIGINT)
RETURNS (
    RES CHAR(8) CHARACTER SET OCTETS)
AS
declare variable H char(16) = '0123456789ABCDEF';
begin
  res = substring(h from bin_and(0x0F, bin_shr(V, 4))+1 for 1) ||
         substring(h from bin_and(0x0F, V)+1  for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 12))+1 for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 8))+1 for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 20))+1 for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 16))+1 for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 28))+1 for 1)||
         substring(h from bin_and(0x0F, bin_shr(V, 24))+1 for 1);
  suspend;
end;


CREATE OR ALTER PROCEDURE MESSAGE_FOR_CUSTOMER (
    CUSTOMER_ID INT_NULL,
    MES_TYPE D_VARCHAR10,
    MES_HEAD D_VARCHAR255,
    MES_TEXT D_MESSAGE,
    MES_PRIOR D_INTEGER,
    EXT_ID D_VARCHAR50,
    MES_RESULT D_INTEGER = 0)
RETURNS (
    MES_ID D_INTEGER)
AS
declare variable RECIVER d_varchar255;
begin
  MES_ID = null;
  MES_TYPE = upper(MES_TYPE);
  if ((MES_TYPE = 'SMS')
      or
      (MES_TYPE = 'EMAIL')) then begin
    for select
            CC_VALUE
          from CUSTOMER_CONTACTS CC
          where CC.CC_NOTIFY = 1
                and ((CC.CC_TYPE = 1
                and :MES_TYPE = 'SMS')
                  or (CC.CC_TYPE = 2
                and :MES_TYPE = 'EMAIL'))
                and CC.CUSTOMER_ID = :CUSTOMER_ID
        into :RECIVER
    do begin
      insert into MESSAGES (CUSTOMER_ID, MES_TYPE, RECIVER, MES_HEAD, MES_TEXT, MES_PRIOR, EXT_ID, MES_RESULT)
      values (:CUSTOMER_ID, :MES_TYPE, :RECIVER, :MES_HEAD, :MES_TEXT, :MES_PRIOR, :EXT_ID, :MES_RESULT)
      returning MES_ID
      into :MES_ID;
    end
  end
  else begin
    if ((MES_TYPE = 'STB')
        or
        (MES_TYPE = 'OSD')) then begin
      for select
              DECODER_N
            from CUSTOMER_DECODERS CC
            where CC.CUSTOMER_ID = :CUSTOMER_ID
          into :RECIVER
      do begin
        insert into MESSAGES (CUSTOMER_ID, MES_TYPE, RECIVER, MES_HEAD, MES_TEXT, MES_PRIOR, EXT_ID, MES_RESULT)
        values (:CUSTOMER_ID, :MES_TYPE, :RECIVER, :MES_HEAD, :MES_TEXT, :MES_PRIOR, :EXT_ID, :MES_RESULT)
        returning MES_ID
        into :MES_ID;
      end
    end
    else begin
      if (MES_TYPE = 'PUSH') then begin
        for select
                CC_VALUE
              from CUSTOMER_CONTACTS CC
              where CC.CC_NOTIFY = 1
                    and CC.CC_TYPE in (5, 6)
                    and CC.CUSTOMER_ID = :CUSTOMER_ID
            into :RECIVER
        do begin
          insert into MESSAGES (CUSTOMER_ID, MES_TYPE, RECIVER, MES_HEAD, MES_TEXT, MES_PRIOR, EXT_ID, MES_RESULT)
          values (:CUSTOMER_ID, :MES_TYPE, :RECIVER, :MES_HEAD, :MES_TEXT, :MES_PRIOR, :EXT_ID, :MES_RESULT)
          returning MES_ID
          into :MES_ID;
        end
      end
      else
        insert into MESSAGES (CUSTOMER_ID, MES_TYPE, MES_HEAD, MES_TEXT, MES_PRIOR, EXT_ID, MES_RESULT)
        values (:CUSTOMER_ID, :MES_TYPE, :MES_HEAD, :MES_TEXT, :MES_PRIOR, :EXT_ID, :MES_RESULT)
        returning MES_ID
        into :MES_ID;
    end
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_ACCOUNT (
    P_ACCOUNT D_ACCOUNT,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
declare variable P_CUSTOMER_ID d_integer;
begin
    ERROR_CODE = 1;
    saldo = 0;
    
    select c.customer_id from customer c where UPPER(c.account_no) = UPPER(:P_ACCOUNT)
    into :p_customer_id;

    if (not p_customer_id is null)
    then begin
        select ERROR_CODE, SALDO
        from MIGRATE_SERVICE_BY_CUSTOMER_ID(:P_CUSTOMER_ID, :V_SERVICE_ID, :P_UNITS, :P_DATE)
        into :ERROR_CODE, :SALDO;
    end
    suspend;
end;


CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_BILL_ACCOUNT (
    P_ACCOUNT D_INTEGER,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
declare variable P_CUSTOMER_ID d_integer;
begin
    ERROR_CODE = 1;
    saldo = 0;
    
    select first 1 c.customer_id from BILLING c where ACCOUNT_ID = :P_ACCOUNT
    into :p_customer_id;

    if (not p_customer_id is null)
    then begin
        select ERROR_CODE, SALDO
        from MIGRATE_SERVICE_BY_CUSTOMER_ID(:P_CUSTOMER_ID, :V_SERVICE_ID, :P_UNITS, :P_DATE)
        into :ERROR_CODE, :SALDO;
    end
    suspend;
end;


CREATE OR ALTER PROCEDURE MIGRATE_SERVICE_BY_CUSTOMER_ID (
    P_CUSTOMER_ID TYPE OF UID,
    V_SERVICE_ID D_INTEGER,
    P_UNITS D_N15_2,
    P_DATE D_DATE)
RETURNS (
    ERROR_CODE D_INTEGER,
    SALDO D_N15_2)
AS
begin

  ERROR_CODE = 1;
  saldo = 0;

  if (not p_customer_id is null)
  then begin
    IF (EXISTS(SELECT ss.SINGLE_SERVICE_ID FROM SINGLE_SERV ss
              WHERE ss.CUSTOMER_ID = :P_CUSTOMER_ID
                and ss.SERVICE_ID = :V_SERVICE_ID
                and ss.SERV_DATE = :P_DATE))
    THEN begin
      UPDATE SINGLE_SERV ss
      SET UNITS = :P_UNITS
      WHERE ss.CUSTOMER_ID = :P_CUSTOMER_ID
        and ss.SERVICE_ID = :V_SERVICE_ID
        and ss.SERV_DATE = :P_DATE;

      UPDATE MONTHLY_FEE mf
         set mf.fee = :P_UNITS
       where mf.CUSTOMER_ID = :P_CUSTOMER_ID
         and mf.SERVICE_ID = :V_SERVICE_ID
         and mf.MONTH_ID = :P_DATE;
    end
    ELSE begin
      INSERT INTO SINGLE_SERV(CUSTOMER_ID, SERVICE_ID, SERV_DATE, UNITS)
      VALUES (:P_CUSTOMER_ID, :V_SERVICE_ID, :P_DATE, :P_UNITS);

      insert into MONTHLY_FEE(MONTH_ID, CUSTOMER_ID, SERVICE_ID, UNITS, FEE)
      values (:P_DATE, :P_CUSTOMER_ID, :V_SERVICE_ID, 1, :P_UNITS);
    end

    select c.debt_sum - coalesce(c.prepay,0)
    from customer c where c.customer_id = :p_customer_id
    into :SALDO;

    ERROR_CODE = 0;
  end
  suspend;
end;


CREATE OR ALTER PROCEDURE OBJECTS_IUD (
    P_ACTION D_INTEGER,
    O_TYPE D_INTEGER,
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR500 = null,
    O_DESCRIPTION D_NOTICE = null,
    O_DIMENSION D_VARCHAR50 = null,
    O_DELETED D_INTEGER = 0,
    O_CHARFIELD D_VARCHAR1000 = null,
    O_NUMERICFIELD D_N15_3 = null,
    O_DATEFILED D_DATE = null,
    O_DATEEND D_DATE = null,
    O_CHECK D_VARCHAR255 = null)
AS
begin
  -- P_ACTION -0 insert 1-update 2-delete
  if ((P_ACTION = 1)
      or
      (P_ACTION = 0)) then begin
    update or insert into Objects (O_Id, O_Type, O_Name, O_Description, O_Deleted, O_Dimension, O_Charfield, O_Numericfield, O_Datefiled, O_Dateend, O_Check)
    values (:O_Id, :O_Type, :O_Name, :O_Description, :O_Deleted, :O_Dimension, :O_Charfield, :O_Numericfield, :O_Datefiled, :O_Dateend, :O_Check)
    matching (O_Id, O_Type);
  end
  else begin
    if (P_ACTION = 2) then
      update OBJECTS
      set O_DELETED = 1
      where (O_ID = :O_ID
            and O_TYPE = :O_TYPE);
  end
end;


CREATE OR ALTER PROCEDURE ONOFF_SERVICE (
    P_CUSTOMER_ID TYPE OF UID,
    P_SUBSCR_SERV_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1,
    ADD_SGL D_IBOOLEAN = 1)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable Fromd         D_Date;
declare variable Id            D_Integer;
declare variable Business_Type D_Integer;
declare variable H_Id          D_Integer;
declare variable D_Act         D_Integer;
declare variable Act_Timestamp type of D_Timestamp;
begin
  Result = 0;
  RECALC = coalesce(RECALC, 1);
  select
      SS.SERV_ID
    , S.BUSINESS_TYPE
    from SUBSCR_SERV SS
         inner join SERVICES S on (S.SERVICE_ID = SS.SERV_ID)
    where SS.CUSTOMER_ID = :P_CUSTOMER_ID
          and SS.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
  into :ID, :BUSINESS_TYPE;

  -- отключаем услугу
  if (P_OFF = 1) then begin
    select first 1
        SH.DATE_FROM
      from SUBSCR_HIST SH
      where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
            and SH.DISACT_SERV_ID = -1
    into :FROMD;

    if (not FROMD is null) then begin

      if (FROMD <= P_DATE) then begin

        update SUBSCR_HIST SH
        set SH.DATE_TO = (:P_DATE - 1),
            SH.DISACT_SERV_ID = :P_ACTSERVICE
        where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
              and SH.DISACT_SERV_ID = -1;

        update SUBSCR_SERV
        set STATE_SGN = 0,
            NOTICE = :P_NOTICE,
            STATE_DATE = :P_DATE,
            STATE_SRV = :P_ACTSERVICE
        where SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

      end
      else
        Result = -1; -- E_WRONG_DATE;
    end
    else begin
      /* проверим, может услуга в блокировке */
      select
          SH.Subscr_Hist_Id
        , sh.Date_To
        from SUBSCR_HIST SH
        where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
              and SH.DISACT_SERV_ID = -3
              and sh.Subscr_Hist_Id = (select
                                           max(so.Subscr_Hist_Id)
                                         from SUBSCR_HIST so
                                         where SO.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID)
      into :H_ID, :Act_Timestamp;

      if (not H_ID is null) then begin
        P_DATE = dateadd(day, 1, cast(:Act_Timestamp as date));
        update SUBSCR_HIST SH
        set SH.DISACT_SERV_ID = :P_ACTSERVICE
        where SH.Subscr_Hist_Id = :H_ID;
        update SUBSCR_SERV
        set STATE_SGN = 0,
            NOTICE = :P_NOTICE,
            STATE_DATE = :P_DATE,
            STATE_SRV = :P_ACTSERVICE
        where SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;
      end
      else begin
        /* проверим, может отключена позднее чем текущее отключение. если да. то сменим на текущее */
        select first 1
            max(SH.Date_To)
          from SUBSCR_HIST SH
          where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
        into :FROMD;
        if (not FROMD is null) then begin

          if (FROMD > P_DATE) then begin
            -- найдему услугу отключения и удалим ее.
            H_ID = null;
            select
                sh.Subscr_Hist_Id
              , sh.Disact_Serv_Id
              from SUBSCR_HIST SH
              where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
                    and SH.Date_To = :FROMD
            into :H_ID, :D_Act;
            if (not H_ID is null) then begin
              delete from Single_Serv ss
                  where ss.Customer_Id = :P_CUSTOMER_ID
                        and ss.Service_Id = :D_ACT
                        and ss.History_Id = :H_ID
                        and ss.Serv_Date = dateadd(day, 1, :FROMD);
            end
            D_Act = null;

            update SUBSCR_HIST SH
            set SH.DATE_TO = (:P_DATE - 1),
                SH.DISACT_SERV_ID = :P_ACTSERVICE
            where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
                  and SH.Date_To = :FROMD;

            update SUBSCR_SERV
            set STATE_SGN = 0,
                NOTICE = :P_NOTICE,
                STATE_DATE = :P_DATE,
                STATE_SRV = :P_ACTSERVICE
            where SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

          end
        end
      end
    end

    H_ID = P_SUBSCR_SERV_ID;
  end

  else begin -- включим услугу
    select
        max(SH.DATE_TO)
      from SUBSCR_HIST SH
      where SH.SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID
    into :FROMD;
    if (FROMD < P_DATE) then begin
      update SUBSCR_SERV
      set STATE_SGN = 1,
          NOTICE = :P_NOTICE,
          STATE_DATE = :P_DATE,
          STATE_SRV = :P_ACTSERVICE
      where CUSTOMER_ID = :P_CUSTOMER_ID
            and SUBSCR_SERV_ID = :P_SUBSCR_SERV_ID;

      H_ID = gen_id(GEN_OPERATIONS_UID, 1);

      insert into SUBSCR_HIST (SUBSCR_HIST_ID, CUSTOMER_ID, SERV_ID, SUBSCR_SERV_ID, DATE_FROM, DATE_TO, ACT_SERV_ID, DISACT_SERV_ID)
      values (:H_ID, :P_CUSTOMER_ID, :ID, :P_SUBSCR_SERV_ID, :P_DATE, '2100-01-01', :P_ACTSERVICE, -1);
    end
    else
      result = -2; -- E_WRONG_ONDATE;
  end

  if (Result >= 0) then begin
    if (ADD_SGL = 1) then begin
      execute procedure ADD_SINGLE_SERVICE(:P_CUSTOMER_ID, :P_ACTSERVICE, :P_UNITS, :P_DATE, :P_NOTICE, :H_ID, :RECALC);
    end
    else if (RECALC = 1) then begin
      execute procedure FULL_RECALC_CUSTOMER(:P_CUSTOMER_ID, :P_DATE);
    end

    if (BUSINESS_TYPE >= 2) then begin
      if (P_OFF = 1) then
        D_ACT = 2;
      else
        D_ACT = 1;
      if (P_DATE < localtimestamp) then
        ACT_TIMESTAMP = localtimestamp;
      else
        ACT_TIMESTAMP = P_DATE;
      execute procedure DIGITAL_EVENT(:D_ACT, :P_CUSTOMER_ID, null, :ID, :ACT_TIMESTAMP, null);
    end
  end
end;


CREATE OR ALTER PROCEDURE ONOFF_SERVICE_BY_ID (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1,
    ADD_SGL D_IBOOLEAN = 1)
AS
declare p_subscr_serv_id type of UID;
declare variable vResult          D_INTEGER;
begin
  select
      subscr_serv_id
    from subscr_serv
    where customer_id = :P_CUSTOMER_ID
          and serv_id = :P_SERVICE_ID
  into :p_subscr_serv_id;

  if (not p_subscr_serv_id is null) then
    execute procedure onoff_service(:p_customer_id, :p_subscr_serv_id, :p_actservice, :p_date, :p_off, :p_notice, :p_units, :RECALC, :ADD_SGL)
        returning_values :vResult;
  else
  if (p_off = 0) then
    execute procedure add_subscr_service(:p_customer_id, :P_SERVICE_ID, :p_actservice, :p_date, :p_notice, 1, null, null, :RECALC);
end;


CREATE OR ALTER PROCEDURE ONOFF_SERVICE_FOR_GROUP (
    P_CUSTOMER_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_ACTSERVICE TYPE OF UID,
    P_DATE D_DATE,
    P_OFF D_INTEGER,
    P_NOTICE D_NOTICE,
    P_UNITS D_N15_2,
    RECALC D_IBOOLEAN = 1)
AS
declare variable subscr_id type of UID;
declare variable vRESULT   D_INTEGER;
begin
  RECALC = coalesce(RECALC,1);
  for select
          ss.subscr_serv_id
        from subscr_serv ss
        where ss.customer_id = :P_CUSTOMER_ID
              and ss.serv_id = :P_SERVICE_ID
      into :subscr_id
  do begin
    execute procedure onoff_service(:p_customer_id, :subscr_id, :p_actservice, :p_date, :p_off, :p_notice, :p_units, :RECALC) returning_values :vResult;
  end
end;


CREATE OR ALTER PROCEDURE OPEN_MATERIAL_DOC (
    DOC_ID UID)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable M_Id       type of Uid;
declare variable Mi_Quant   type of D_N15_5;
declare variable Wh_Id      type of Uid;
declare variable from_Wh_Id type of Uid;
declare variable type_Id    type of Uid;
declare variable doc_date   D_DATE;
declare variable vCLOSED    D_INTEGER;
begin
  result = 1;

  select
      Wh_Id
    , Dt_Id
    , From_Wh
    , coalesce(d.Doc_Closed, 0)
    from material_docs d
    where doc_id = :Doc_Id
  into :Wh_Id, :type_Id, :from_Wh_Id, :vCLOSED;

  if (vCLOSED = 0) then begin
    suspend;
    exit;
  end

  if (type_Id is null) then begin
    result = 0;
    suspend;
    exit;
  end

  -- приход на склад, спишем
  if ((type_Id = 1) -- Приход материалов
      or
      (type_Id = 2) -- перемещение
      or
      (type_Id = 4)) -- Корректировка
  then begin
    for select
            M_Id
          , coalesce(M_Quant, 0)
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update Materials_Remain
        set MR_QUANT = MR_QUANT - :MI_QUANT
        where M_Id = :M_ID
              and Wh_Id = :WH_ID;
        if (row_count = 0) then -- если не нашли, вставим запись
          insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
          values (:M_Id, :Wh_Id, (-1 * :Mi_Quant));
      end
    end
  end

  -- оприходуем на склад
  if (type_Id = 5) -- инвинтаризация
  then begin
    for select
            M_Id
          , sum(B_Quant - M_Quant)
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
          group by M_Id
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update Materials_Remain
        set MR_QUANT = MR_QUANT + :MI_QUANT
        where M_Id = :M_ID
              and Wh_Id = :WH_ID;
        if (row_count = 0) then -- если не нашли, вставим запись
          insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
          values (:M_Id, :Wh_Id, :Mi_Quant);

        doc_date = null;
        select
            max(d.Doc_Date)
          from material_docs d
          where d.Dt_Id = 5
                and d.Doc_Id <> :Doc_Id
                and d.Doc_Closed = 1
                and d.Wh_Id = :Wh_Id
                and exists(select
                               md.Id
                             from Materials_In_Doc md
                             where md.Doc_Id = d.Doc_Id
                                   and md.M_Id = :M_ID)
        into :doc_date;

        update MATERIALS_REMAIN r
        set Inventory = :doc_date
        where WH_ID = :Wh_Id
              and M_ID = :M_ID;
      end
    end
  end

  -- списали со склада, вернем
  if ((type_Id = 2)) then begin -- перемещение
    for select
            M_Id
          , coalesce(M_Quant, 0)
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update MATERIALS_REMAIN r
        set MR_QUANT = MR_QUANT + :MI_QUANT
        where WH_ID = :from_Wh_Id
              and M_ID = :M_ID;
        if (row_count = 0) then -- если не нашли, вставим запись
          insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
          values (:M_Id, :from_Wh_Id, :Mi_Quant);
      end
    end
  end

  -- списали со склада, вернем
  if ((type_Id = 3)) then begin -- списание материалов
    for select
            M_Id
          , coalesce(M_Quant, 0)
          from Materials_In_Doc
          where Doc_Id = :DOC_ID
        into :M_Id, :MI_QUANT
    do begin
      if (MI_QUANT <> 0) then begin
        update MATERIALS_REMAIN r
        set MR_QUANT = MR_QUANT + :MI_QUANT
        where WH_ID = :Wh_Id
              and M_ID = :M_ID;
        if (row_count = 0) then -- если не нашли, вставим запись
          insert into Materials_Remain (M_Id, Wh_Id, Mr_Quant)
          values (:M_Id, :Wh_Id, :Mi_Quant);
      end
    end
  end

  delete from MATERIALS_REMAIN where MR_QUANT = 0;

  update material_docs
  set Doc_Closed = 0
  where doc_id = :DOC_ID;

  suspend;

end;


CREATE OR ALTER PROCEDURE PAYMENT_ADD_FROM_EXT_SYSTEMS (
    ACCOUNT_NO TYPE OF D_ACCOUNT,
    PAY_SUM D_N15_2,
    PAY_TIME D_DATETIME,
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50,
    NOTICE D_NOTICE,
    PAY_TYPE_STR D_VARCHAR30 = 'CASH',
    CMSN D_N15_2 = null)
RETURNS (
    PAYMENT_ID D_INTEGER,
    IS_DELETED D_IBOOLEAN)
AS
declare variable PAY_DOC_ID  D_integer;
declare variable CUSTOMER_ID D_integer;
declare variable PAY_DATE    D_DATE;
begin
  PAY_DATE = cast(PAY_TIME as date);
  PAYMENT_ID = null;
  select
      Customer_Id
    from customer c
    where c.Account_No = :Account_No
  into Customer_Id;

  if (not CUSTOMER_ID is null) then begin
    if (not Pay_sum is null) then begin

      select
          Payment_Id
        , IS_DELETED
        from Payment_Ext_State(:PAYSOURCE_ID, :EXT_SYSTEMS_ID)
      into :PAYMENT_ID, :IS_DELETED;
      if (PAYMENT_ID is null) then begin

        if (Paysource_Id is null) then
          Paysource_Id = 0;

        select
            Pay_Doc_Id
          from Get_Pay_Doc(:Paysource_Id, :Pay_Date, null)
        into :Pay_Doc_Id;

        PAYMENT_ID = gen_id(Gen_Payment, 1);

        insert into Payment (Payment_Id, Pay_Doc_Id, Customer_Id, Pay_Date, Pay_Sum, Notice, EXT_PAY_ID, PAY_DATETIME, PAY_TYPE_STR, CMSN)
        values (:Payment_Id, :Pay_Doc_Id, :Customer_Id, :Pay_Date, :Pay_Sum, :Notice, :Ext_Systems_Id, :PAY_TIME, :PAY_TYPE_STR, :CMSN);
        IS_DELETED = 0;
      end
    end
    else
      PAYMENT_ID = -2;
  end
  else
    PAYMENT_ID = -1;
  suspend;
end;


CREATE OR ALTER PROCEDURE PAYMENT_DEL_FROM_EXT_SYSTEMS (
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50)
RETURNS (
    RESULT_CODE D_INTEGER)
AS
declare variable vPayment type of Uid;
declare variable vDeleted type of Uid;
begin
  if (PAYSOURCE_ID is null) then
    PAYSOURCE_ID = -1;
  if (EXT_SYSTEMS_ID is null) then
    EXT_SYSTEMS_ID = '';

  if ((PAYSOURCE_ID >= 0) and (EXT_SYSTEMS_ID <> '')) then begin

    vDeleted = 0;

    select
        Payment_Id
      , Is_Deleted
      from Payment_Ext_State(:Paysource_Id, :Ext_Systems_Id)
    into :vPayment, :vDeleted;

    if (not vPayment is null) then begin
      /* если палтеж не удален, то пометим как удаленный */
      if (vDeleted = 0) then begin
        delete from payment where Payment_Id = :vPayment;
      end
      RESULT_CODE = vPayment;/* вернем номер платежа */
    end
    else
      RESULT_CODE = -2;/* не нашли платеж среди введенных или удаленных */
  end
  else
    RESULT_CODE = -1;/* не корректные входные данные */

  suspend;
end;


CREATE OR ALTER PROCEDURE PAYMENT_EXT_STATE (
    PAYSOURCE_ID D_INTEGER,
    EXT_SYSTEMS_ID TYPE OF D_VARCHAR50)
RETURNS (
    PAYMENT_ID D_INTEGER,
    PAY_DATETIME D_DATETIME,
    IS_DELETED D_IBOOLEAN)
AS
begin
  PAYMENT_ID = null;
  select
      PAYMENT_ID, PAY_DATETIME, 0
    from payment p
         inner join pay_doc pd on (p.pay_doc_id = pd.pay_doc_id)
    where pd.paysource_id = :PAYSOURCE_ID
          and p.ext_pay_id = :EXT_SYSTEMS_ID
  into :PAYMENT_ID, :PAY_DATETIME, :IS_DELETED;

  if (PAYMENT_ID is null) then
    select
        PAYMENT_ID, PAY_DATETIME, 1
      from Payment_Deleted p
           inner join pay_doc pd on (p.pay_doc_id = pd.pay_doc_id)
      where pd.paysource_id = :PAYSOURCE_ID
            and p.ext_pay_id = :EXT_SYSTEMS_ID
    into :PAYMENT_ID, :PAY_DATETIME, :IS_DELETED;

  suspend;
end;


CREATE OR ALTER PROCEDURE PAYMENT_INSERT (
    PAYMENT_ID TYPE OF UID,
    PAY_DOC_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE TYPE OF D_DATE,
    PAY_SUM TYPE OF D_N15_2,
    FINE_SUM TYPE OF D_N15_2,
    PAYMENT_TYPE TYPE OF D_UID_NULL,
    NOTICE TYPE OF D_NOTICE,
    PAYMENT_SRV TYPE OF D_UID_NULL,
    EXT_PAY_ID TYPE OF D_VARCHAR50,
    TAG TYPE OF D_INTEGER,
    PAY_DATETIME TYPE OF D_DATETIME,
    NEED_CHECK TYPE OF D_IBOOLEAN,
    CMSN D_N15_2 = null)
AS
declare variable need_split d_integer;
begin
  need_split = 0;
  if (PAYMENT_TYPE is null) then begin
    select
        s.Var_Value
      from settings s
      where s.Var_Name = 'PAYMENT_TYPE'
    into :need_split;
    need_split = coalesce(need_split, 0);
  end

  if (need_split = 0) then
    insert into Payment (Payment_Id, Pay_Doc_Id, Customer_Id, Pay_Date, Pay_Sum, Fine_Sum, Payment_Type, Notice, Payment_Srv, Ext_Pay_Id, Tag, Pay_Datetime, Need_Check, CMSN)
    values (:Payment_Id, :Pay_Doc_Id, :Customer_Id, :Pay_Date, :Pay_Sum, :Fine_Sum, :Payment_Type, :Notice, :Payment_Srv, :Ext_Pay_Id, :Tag, :Pay_Datetime, :Need_Check, :CMSN);
  else
    execute procedure Payment_Split_Insert(:Pay_Doc_Id, :Customer_Id, :Pay_Date, :Pay_Sum, :Notice, :Ext_Pay_Id, :Fine_Sum, :CMSN);
end;


CREATE OR ALTER PROCEDURE PAYMENT_SPLIT_INSERT (
    PAY_DOC_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID,
    PAY_DATE TYPE OF D_DATE,
    PAY_SUM TYPE OF D_N15_2,
    NOTICE TYPE OF D_NOTICE,
    EXT_PAY_ID TYPE OF D_VARCHAR50,
    FINE_SUM TYPE OF D_N15_2,
    CMSN D_N15_2 = null)
AS
declare variable EXP   D_N15_2;
declare variable PAY_1 D_N15_2;
declare variable PAY_2 D_N15_2;
declare variable TAR_1 D_N15_2;
declare variable TAR_2 D_N15_2;
begin
  if (PAY_SUM > 0) then begin
    -- выберем услуги которые гасятся в первую очередь (приоритет задаеться полем O_Numericfield)
    for select
            o.O_Id
          ,
            (select
                 sum(f.Fee)
               from Monthly_Fee f
                    inner join Services s on (f.Service_Id = s.Service_Id)
               where f.Customer_Id = :customer_id
                     and s.Expense_Type = o.O_Id)
          ,
            (select
                 sum(p.Pay_Sum)
               from payment p
               where p.Customer_Id = :customer_id
                     and p.Payment_Type = o.O_Id)
          from Objects o
          where o.O_Type = 2
                and not o.O_Numericfield is null
          order by o.O_Numericfield
        into :TAR_1, :EXP, :PAY_1
    do begin
      EXP = coalesce(EXP, 0) - coalesce(PAY_1, 0);
      if ((EXP > 0) and (PAY_SUM > 0)) then begin
        if (PAY_SUM > EXP) then begin
          execute procedure Add_Payment_Ext(:Pay_Doc_Id, :Customer_Id, :EXP, :PAY_DATE, :Notice, :Fine_Sum, :TAR_1, null, :Ext_Pay_Id, null, :CMSN)
              returning_values :TAR_1;
          PAY_SUM = PAY_SUM - EXP;
        end
        else begin
          execute procedure Add_Payment_Ext(:Pay_Doc_Id, :Customer_Id, :PAY_SUM, :PAY_DATE, :Notice, :Fine_Sum, :TAR_1, null, :Ext_Pay_Id, null, :CMSN)
              returning_values :TAR_1;
          PAY_SUM = 0;
        end
      end
      EXP = null;
      PAY_1 = null;
      TAR_1 = null;
    end

    if (PAY_SUM > 0) then begin
      PAY_1 = 0;
      PAY_2 = 0;
      select
          sum(T.TARIF_SUM)
        from SUBSCR_SERV SS
             inner join SERVICES S on (SS.SERV_ID = S.SERVICE_ID)
             inner join TARIF T on (T.SERVICE_ID = SS.SERV_ID and
                   :PAY_DATE between T.DATE_FROM and T.DATE_TO)
        where SS.STATE_SGN = 1
              and SS.CUSTOMER_ID = :CUSTOMER_ID
              and S.EXPENSE_TYPE = 0
      into :TAR_1;
      select
          sum(T.TARIF_SUM)
        from SUBSCR_SERV SS
             inner join SERVICES S on (SS.SERV_ID = S.SERVICE_ID)
             inner join TARIF T on (T.SERVICE_ID = SS.SERV_ID and
                   :PAY_DATE between T.DATE_FROM and T.DATE_TO)
        where SS.STATE_SGN = 1
              and SS.CUSTOMER_ID = :CUSTOMER_ID
              and S.EXPENSE_TYPE = 1
      into :TAR_2;
      TAR_1 = coalesce(TAR_1, 0);
      TAR_2 = coalesce(TAR_2, 0);
      EXP = TAR_1 + TAR_2;
      if (EXP > 0) then begin
        PAY_1 = round((PAY_SUM * TAR_1 / EXP), 2);
        PAY_2 = PAY_SUM - PAY_1;
        if (PAY_1 > 0) then
          execute procedure Add_Payment_Ext(:Pay_Doc_Id, :Customer_Id, :PAY_1, :PAY_DATE, :Notice, :Fine_Sum, 0, null, :Ext_Pay_Id, null, :CMSN)
              returning_values :EXP;
        if (PAY_2 > 0) then
          execute procedure Add_Payment_Ext(:Pay_Doc_Id, :Customer_Id, :PAY_2, :PAY_DATE, :Notice, :Fine_Sum, 1, null, :Ext_Pay_Id, null, :CMSN)
              returning_values :EXP;
      end
      else
        execute procedure Add_Payment_Ext(:Pay_Doc_Id, :Customer_Id, :PAY_SUM, :PAY_DATE, :Notice, :Fine_Sum, 0, null, :Ext_Pay_Id, null, :CMSN)
            returning_values :EXP;
    end
  end
end;


CREATE OR ALTER PROCEDURE PAYMENTTYPE_IUD (
    O_ID TYPE OF UID,
    O_NAME D_VARCHAR50,
    O_DESCRIPTION D_NOTICE,
    P_ACTION D_INTEGER)
AS
BEGIN
-- P_ACTION -0 insert 1-update 2-delete
  IF (P_ACTION = 1)
  THEN BEGIN
    UPDATE OBJECTS
    SET O_TYPE = 2,
        O_NAME = :O_NAME,
        O_DESCRIPTION = :O_DESCRIPTION
    WHERE (O_ID = :O_ID);
  END
  ELSE BEGIN
    IF (P_ACTION = 0)
    THEN BEGIN
      INSERT INTO OBJECTS(O_ID, O_TYPE, O_NAME, O_DESCRIPTION, O_DELETED)
      VALUES (:O_ID, 2, :O_NAME, :O_DESCRIPTION, 0);
    END
    ELSE
    UPDATE OBJECTS
    SET O_DELETED = 1
    WHERE (O_ID = :O_ID and O_TYPE = 2);
  end
end;


CREATE OR ALTER PROCEDURE PREPAYEXPIRE (
    DAYS D_INTEGER)
AS
declare variable v_customer_id UID;
begin
  if (DAYS is null) then begin
    select
        cast(s.var_value as integer)
      from settings s
      where s.var_name = 'PREPAYEXPIRE'
    into :DAYS;

    if (DAYS is null) then begin
      DAYS = 5;
      delete from settings s
          where s.var_name = 'PREPAYEXPIRE';
      insert into settings (var_name, var_value, var_notice)
      values ('PREPAYEXPIRE', :DAYS, 'Срок сгорания обещ. платежей (дней)');

    end
  end

  DAYS = -1 * DAYS;

  for select
          c.Customer_Id
        from CUSTOMER c
        where ((c.prepay_time < dateadd(:DAYS day to localtimestamp))
                or (c.prepay_time is null))
              and c.prepay > 0
      into :v_customer_id
  do
    execute procedure Set_Prepay(:v_customer_id, 0);
end;


CREATE OR ALTER PROCEDURE QUEUE_SWITCH (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID,
    SWITCH_SRV TYPE OF UID = null,
    UNITS D_N15_2 = 1,
    SWITCH_DATE D_DATE = current_date,
    NOTICE D_NOTICE = null)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable Add_Srv     type of Uid;
declare variable Switch_Time type of Uid;
declare variable Vautooff    D_Integer;
declare variable Vdate       type of D_Date;
begin
  if (Switch_Date is null) then
    Switch_Date = current_date;

  select first 1
      sl.Add_Srv, coalesce(sl.Switch_Time, 0),
      (select
           s.Autooff
         from services s
         where s.Service_Id = :FROM_SRV)
    from Services_Links sl
    where sl.Parent = :FROM_SRV
          and sl.Child = :TO_SRV
          and sl.Link_Type = 6
          and ((sl.Add_Srv = :SWITCH_SRV)
            or (:SWITCH_SRV is null))
  into :Add_Srv, :Switch_Time, :vAutoOff;

  if (Switch_Time = 1) then begin
    /* 1 - Начало суток */
    vDate = dateadd(day, 1, current_date);
    if (Switch_Date < vDate) then
      Switch_Date = vDate;
  end
  else begin
    if (Switch_Time = 2) then begin
      /* 2 - Начало месяца */
      vDate = dateadd(month, 1, (current_date - extract(day from current_date) + 1));
      if (Switch_Date < vDate) then
        Switch_Date = vDate;

    end
  end
  delete from QUEUE_SWITCH_SRV where Customer_Id = :Customer_Id and Srv_From = :FROM_SRV;

  update or insert into QUEUE_SWITCH_SRV (Customer_Id, Srv_From, Switch_Date, Srv_To, Srv_Act, COMPLETED)
  values (:Customer_Id, :FROM_SRV, :Switch_Date, :TO_SRV, :SWITCH_SRV, 0)
  matching (Customer_Id, Srv_From);
  Result = 0;
  -- если переключать в любой время, то сразу переключим
  if (Switch_Time = 0)
  then
    execute procedure Queue_Switch_Handle(:Customer_Id);

  suspend;
end;


CREATE OR ALTER PROCEDURE QUEUE_SWITCH_CANCEL (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID = null)
RETURNS (
    RESULT D_INTEGER)
AS
begin
  delete from QUEUE_SWITCH_SRV where Customer_Id = :customer_id
        and Srv_From = :FROM_SRV;
  RESULT = 0;
  suspend;
end;


CREATE OR ALTER PROCEDURE QUEUE_SWITCH_HANDLE (
    FOR_CUSTOMER_ID TYPE OF UID = null)
AS
declare variable Customer_Id type of Uid;
declare variable From_Srv    type of Uid;
declare variable To_Srv      type of Uid;
declare variable Switch_Srv  type of Uid;
declare variable Units       D_N15_2;
declare variable Switch_Date D_Date;
declare variable Notice      D_Notice;
declare variable Sw_Res      D_Integer;
declare variable Srv_Exists  D_Integer;
declare variable Srv_Sate    D_Integer;
declare variable Srv_SDate   D_Date;
begin
  UNITS = 0;
  SW_RES = 2;
  NOTICE = null;
  for select
          Customer_Id
        , Srv_From
        , Switch_Date
        , Srv_To
        , Srv_Act
        from Queue_Switch_Srv
        where Switch_Date = current_date
              and coalesce(COMPLETED, 0) = 0
              and ((:FOR_CUSTOMER_ID is null)
                or (Customer_Id = :FOR_CUSTOMER_ID))
      into :Customer_Id, :FROM_SRV, :SWITCH_DATE, :TO_SRV, :SWITCH_SRV
  do begin
    if (SWITCH_SRV is null) then begin
      select first 1
          sl.Add_Srv
        from Services_Links sl
        where sl.Parent = :FROM_SRV
              and sl.Child = :TO_SRV
              and sl.Link_Type = 6
      into :SWITCH_SRV;
    end
    if (SWITCH_SRV is not null) then begin
      /* Проверим статус услуги, и если она включена, то переключим иначе - нет */
      select
          ss.State_Srv
        , ss.State_Sgn
        , ss.State_Date
        from Subscr_Serv ss
        where ss.Customer_Id = :Customer_Id
              and ss.Serv_Id = :FROM_SRV
      into :SRV_EXISTS, :Srv_Sate, :Srv_SDate;

      Srv_SDate = coalesce(Srv_SDate, current_date);
      if (Srv_SDate <= current_date) then begin
        if (Srv_Sate = 1) then begin
          -- услуга активна, отключим ее
          execute procedure Onoff_Service_By_Id(:CUSTOMER_ID, :FROM_SRV, :SWITCH_SRV, :SWITCH_DATE, 1, :NOTICE, :UNITS, 0);
          Srv_Sate = -11; -- просто признак что можно отключать :)
        end
        else begin
          -- Автоблокировка
          if (SRV_EXISTS = -3) then begin
            -- сменим автоблокировку на постоянное отключение
            update SUBSCR_HIST SH
            set SH.DISACT_SERV_ID = :SWITCH_SRV
            where SH.Customer_Id = :Customer_Id
                  and sh.Serv_Id = :FROM_SRV
                  and SH.DISACT_SERV_ID = -3;

            update Subscr_Serv SS
            set SS.State_Srv = :SWITCH_SRV
            where SS.Customer_Id = :Customer_Id
                  and sS.Serv_Id = :FROM_SRV
                  and SS.State_Srv = -3;
            Srv_Sate = -11; -- просто признак что можно отключать :)
          end
          else begin
            if (Srv_Sate = 0) then
              SW_RES = 3;
          end
        end
      end
      else begin
        -- если подключен будущим числом, то отключим сегодняшним
        if ((Srv_Sate = 1) and (Srv_SDate > current_date)) then begin
          update SUBSCR_HIST SH
          set SH.DATE_TO = (current_date - 1),
              SH.DISACT_SERV_ID = :SWITCH_SRV
          where SH.Customer_Id = :Customer_Id
                and sh.Serv_Id = :FROM_SRV
                and SH.DISACT_SERV_ID = -1;

          update SUBSCR_SERV ss
          set STATE_SGN = 0,
              STATE_DATE = current_date,
              STATE_SRV = :SWITCH_SRV
          where ss.Customer_Id = :Customer_Id
                and ss.Serv_Id = :FROM_SRV
                and ss.STATE_SGN = 1;

          Srv_Sate = -11; -- просто признак что можно отключать :)
        end
        else -- нужно подумать что делать, если услуга отключена будущим числом
          SW_RES = 3; -- услуга отключена
      end

      if (Srv_Sate = -11) then begin -- если признак не установлен, то не переключаем
        SRV_EXISTS = null;
        select
            ss.State_Sgn
          from Subscr_Serv ss
          where ss.Customer_Id = :Customer_Id
                and ss.Serv_Id = :To_Srv
        into :SRV_EXISTS;

        /* если услуги у абонента нет, то добавим ее иначе просто включим */
        if (SRV_EXISTS is null) then
          execute procedure Add_Subscr_Service(:Customer_Id, :To_Srv, :SWITCH_SRV, :SWITCH_DATE, :NOTICE, :UNITS, null, null, 0);
        else
          execute procedure Onoff_Service_By_Id(:Customer_Id, :To_Srv, :SWITCH_SRV, :SWITCH_DATE, 0, :NOTICE, :UNITS, 0);

        -- execute procedure FULL_RECALC_CUSTOMER(:CUSTOMER_ID);
        SW_RES = 1;
      end
    end

    update Queue_Switch_Srv
    set Completed = :SW_RES
    where Customer_Id = :Customer_Id
          and Srv_From = :FROM_SRV
          and Switch_Date = :SWITCH_DATE;
  end
end;


CREATE OR ALTER PROCEDURE RECALCCUSTOMERDEBT (
    P_CUSTOMER_ID TYPE OF UID)
AS
declare variable FEE   D_N15_2;
declare variable OFE   D_N15_2;
declare variable PAY   D_N15_2;
declare variable BONUS D_N15_2;
begin
  FEE = 0;
  PAY = 0;
  OFE = 0;
  select
      sum(m.FEE)
    from MONTHLY_FEE m
    where m.CUSTOMER_ID = :P_CUSTOMER_ID
  into :FEE;

  select
      sum(m.FEE)
    from other_fee m
    where m.CUSTOMER_ID = :P_CUSTOMER_ID
  into :OFE;

  select
      sum(m.PAY_SUM)
    from PAYMENT m
    where m.CUSTOMER_ID = :P_CUSTOMER_ID
  into :PAY;

  select
      sum(m.Bonus)
    from Customer_Bonuses m
    where m.CUSTOMER_ID = :P_CUSTOMER_ID
  into :BONUS;

  if (FEE is null) then
    FEE = 0;
  if (OFE is null) then
    OFE = 0;
  if (PAY is null) then
    PAY = 0;
  if (BONUS is null) then
    BONUS = 0;

  FEE = FEE + OFE - PAY - BONUS;

  update CUSTOMER C
  set C.DEBT_SUM = coalesce(:FEE, 0)
  where C.CUSTOMER_ID = :P_CUSTOMER_ID;

end;


CREATE OR ALTER PROCEDURE REQUEST_ADD (
    RQ_TYPE UID,
    RQ_CUSTOMER D_UID_NULL,
    RQ_CONTENT D_NOTICE,
    RQ_NOTICE D_NOTICE,
    RQ_PLAN_DATE D_DATE_NOW,
    RQ_TIME_FROM D_TIME,
    RQ_TIME_TO D_TIME,
    HOUSE_ID UID,
    FLAT_NO D_FLAT,
    PORCH_N D_VARCHAR10,
    FLOOR_N D_VARCHAR10,
    PHONE D_VARCHAR50,
    RQTL_ID D_UID_NULL,
    DOOR_CODE D_VARCHAR20,
    ADD_INFO D_VARCHAR255,
    O_TYPE D_INTEGER = 0)
RETURNS (
    RQ_ID UID)
AS
declare variable v_Porch D_VARCHAR10;
declare variable v_Floor D_VARCHAR10;
declare variable node_id D_UID_NULL;
begin
  -- Если O_TYPE = 0 - абонента, 1 - узел
  if (O_TYPE = 1) then begin
    node_id = RQ_CUSTOMER;
    RQ_CUSTOMER = null;
  end

  RQ_ID = gen_id(gen_request, 1);

  insert into REQUEST (RQ_ID, RQ_TYPE, RQ_CUSTOMER, RQ_CONTENT, RQ_PLAN_DATE, RQ_TIME_FROM, RQ_TIME_TO, HOUSE_ID, FLAT_NO, PHONE, RQTL_ID, DOOR_CODE, ADD_INFO, RQ_NOTICE, porch_n, floor_n, node_id)
  values (:RQ_ID, :RQ_TYPE, :RQ_CUSTOMER, :RQ_CONTENT, :RQ_PLAN_DATE, :RQ_TIME_FROM, :RQ_TIME_TO, :HOUSE_ID, :FLAT_NO, :PHONE, :RQTL_ID, :DOOR_CODE, :ADD_INFO, :RQ_NOTICE, :porch_n, :floor_n, :node_id);

  if (coalesce(trim(Flat_No), '') <> '') then begin
    select
        Porch_N
      , Floor_N
      from HOUSEFLATS
      where House_Id = :House_Id
            and Flat_No = :Flat_No
    into :v_Porch, :v_Floor;

    if ((coalesce(v_Porch, '') <> coalesce(Porch_N, ''))
        or
        (coalesce(v_Floor, '') <> coalesce(Floor_N, ''))) then begin

      delete from HOUSEFLATS where house_id = :house_id
            and flat_no = :flat_no;

      insert into HOUSEFLATS (house_id, flat_no, porch_n, floor_n)
      values (:house_id, :flat_no, :porch_n, :floor_n);

    end
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_ADD_EXECUTORS (
    RQ_ID TYPE OF UID,
    W_ID TYPE OF UID,
    SELECTED D_INTEGER,
    NOTICE D_NOTICE,
    P_ACTION D_INTEGER)
AS
BEGIN
-- P_ACTION -0 insert 1-update 2-delete
  DELETE FROM request_executors e
  where e.RQ_ID = :RQ_ID
    and e.exec_id = :W_ID;
  if (SELECTED is null) then SELECTED = 0;
  IF ((P_Action <> 2) and (SELECTED<>0))
  THEN
    insert into request_executors (rq_id, exec_id, notice)
    values (:rq_id, :w_id, :notice);
END;


CREATE OR ALTER PROCEDURE REQUEST_CLOSE_AS (
    RQ_ID TYPE OF UID,
    AS_RQ_ID TYPE OF UID)
AS
declare variable rq_type      type of uid;
declare variable rq_defect    type of d_notice;
declare variable rq_exec_time type of d_datetime;
declare variable req_result   type of d_integer;
declare variable result_id    type of d_uid_null;
begin
  if (exists(select
                 RQ_TYPE
               from REQUEST rm
               where rm.rq_id = :AS_RQ_ID)) then begin

    -- перенесем материалы
    delete from REQUEST_MATERIALS rm where rm.rq_id = :RQ_ID;
    insert into REQUEST_MATERIALS (RQ_ID, M_ID, WH_ID, RM_QUANT, RM_COST, RM_NOTICE, NOT_CALC)
    select
        :RQ_ID, M_ID, WH_ID, RM_QUANT, RM_COST, RM_NOTICE, NOT_CALC
      from REQUEST_MATERIALS rm
      where rm.rq_id = :AS_RQ_ID;

    -- перенесем возврат материалов
    delete from Request_Materials_Return rr where rr.rq_id = :RQ_ID;
    insert into Request_Materials_Return (RQ_ID, M_ID, WH_ID, QUANT, NOTICE)
    select
        :RQ_ID, M_ID, WH_ID, QUANT, NOTICE
      from Request_Materials_Return rr
      where rr.rq_id = :AS_RQ_ID;

    -- Перенесем работы
    delete from REQUEST_WORKS where RQ_ID = :RQ_ID;
    insert into REQUEST_WORKS (RQ_ID, W_ID, W_TIME, W_QUANT, W_COST, NOTICE)
    select
        :RQ_ID, W_ID, W_TIME, W_QUANT, W_COST, NOTICE
      from REQUEST_WORKS rm
      where rm.rq_id = :AS_RQ_ID;

    -- Перенесем результат заявки
    select
        RQ_TYPE, RQ_DEFECT, REQ_RESULT, RQ_EXEC_TIME, RESULT_ID
      from REQUEST rm
      where rm.rq_id = :AS_RQ_ID
    into :RQ_TYPE, :RQ_DEFECT, :REQ_RESULT, :RQ_EXEC_TIME, :RESULT_ID;

    if (not((RQ_TYPE is null)
        or
        (REQ_RESULT is null)
        or
        (RESULT_ID is null))) then
      update REQUEST
      set RQ_TYPE = :RQ_TYPE,
          RQ_DEFECT = :RQ_DEFECT,
          RQ_EXEC_TIME = :RQ_EXEC_TIME,
          REQ_RESULT = :REQ_RESULT,
          RESULT_ID = :RESULT_ID
      where (RQ_ID = :RQ_ID);
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_CLOSE_PROCESS (
    RQ_ID UID)
AS
declare variable quant       d_n15_3;
declare variable act         d_smallint;
declare variable O_ID        d_uid_null;
declare variable customer_id d_uid_null;
declare variable notice      d_notice;
declare variable vDate       d_date;
begin
  -- Установим, удалим атрибуты
  for select
          m.w_quant
        , w.w_atr_ad
        , w.w_atr_id
        , rq.rq_customer
        , m.notice
        from WORKS w
             inner join request_works m on (w.w_id = m.w_id)
             inner join request rq on (m.rq_id = rq.rq_id)
        where m.rq_id = :RQ_ID
              and w.w_atr_ad in (1, 2)
              and (not w.w_atr_id is null)
      into :quant, :act, :O_ID, :customer_id, :notice
  do begin
    if (not customer_id is null) then begin
      if (act = 1) then
        if (not exists(select
                           CUSTOMER_ID
                         from CUSTOMER_ATTRIBUTES
                         where CUSTOMER_ID = :CUSTOMER_ID
                               and O_ID = :O_ID)) then
          insert into CUSTOMER_ATTRIBUTES (CUSTOMER_ID, O_ID, CA_VALUE, NOTICE, RQ_ID)
          values (:CUSTOMER_ID, :O_ID, cast(round(:quant, 0) as integer), :NOTICE, :RQ_ID);
        else
          delete from CUSTOMER_ATTRIBUTES
              where (CUSTOMER_ID = :CUSTOMER_ID)
                    and (O_ID = :O_ID);
    end
  end
  -- Установим разовые услуги
  vDate = null;
  for select
          m.w_quant
        , w.as_service
        , rq.rq_customer
        , w.Notice
        , rq.Rq_Exec_Time
        from WORKS w
             inner join request_works m on (w.w_id = m.w_id)
             inner join request rq on (m.rq_id = rq.rq_id)
        where m.rq_id = :RQ_ID
              and (not w.as_service is null)
              and (rq.Node_Id is null)
      into :quant, :O_ID, :customer_id, :notice, :vdate
  do begin
    if (not customer_id is null) then begin
      notice = coalesce(notice||' /','')||RQ_ID;
      insert into SINGLE_SERV (CUSTOMER_ID, SERVICE_ID, SERV_DATE, UNITS, NOTICE, HISTORY_ID, RQ_ID)
      values (:CUSTOMER_ID, :O_ID, :vDATE, :quant, :notice, null, :RQ_ID);
    end
  end
  -- начислим месяц
  if (not vDate is null) then begin
    vDate = vDate - extract(day from vDate) + 1;
    execute procedure Close_Month_Proc(:vDate, :CUSTOMER_ID);
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_CLOSE_ROLLBACK (
    RQ_ID TYPE OF UID,
    CUSTOMER_ID TYPE OF UID)
AS
begin
  if ((not CUSTOMER_ID is null)
     and (not RQ_ID is null))
  then begin
    delete from OTHER_FEE where CUSTOMER_ID = :CUSTOMER_ID and IN_REQUEST = :RQ_ID;
    delete from CUSTOMER_ATTRIBUTES where CUSTOMER_ID = :CUSTOMER_ID and RQ_ID = :RQ_ID;
    delete from SINGLE_SERV where CUSTOMER_ID = :CUSTOMER_ID and RQ_ID = :RQ_ID;
    execute procedure Full_Recalc_Customer(:Customer_Id);
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_MATERIALS_IUD (
    RM_ID TYPE OF UID,
    RQ_ID TYPE OF UID,
    M_ID TYPE OF UID,
    RM_QUANT D_N15_5,
    WH_ID TYPE OF UID,
    RM_COST D_N15_2,
    RM_NOTICE D_NOTICE,
    NOT_CALC D_IBOOLEAN,
    P_ACTION D_INTEGER)
AS
declare variable Quant type of D_N15_5;
begin
  -- P_ACTION -0 insert 1-update 2-delete

  delete from REQUEST_MATERIALS M
      where m.RM_ID = :RM_ID;

  if ((P_Action <> 2) and (RM_QUANT > 0)) then begin
    if (RM_QUANT is null) then
      RM_QUANT = 0;
    -- проверим есть ли нужно кол-во материала на складе
    if (RM_QUANT > 0) then begin
      select
          rm.Mr_Quant
        from Materials_Remain rm
        where rm.M_Id = :M_ID
              and rm.Wh_Id = :WH_ID
      into :Quant;
      Quant = coalesce(Quant, RM_QUANT - 1);
      if (Quant < RM_QUANT) then
        exception E_Mat_Quant_Less;
    end
    insert into REQUEST_MATERIALS (RQ_ID, M_ID, WH_ID, RM_QUANT, RM_COST, RM_NOTICE, NOT_CALC)
    values (:RQ_ID, :M_ID, :WH_ID, :RM_QUANT, :RM_COST, :RM_NOTICE, :NOT_CALC);
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_MATERIALS_RETURN_IUD (
    ID TYPE OF UID,
    RQ_ID TYPE OF UID,
    M_ID TYPE OF UID,
    QUANT D_N15_5,
    WH_ID TYPE OF UID,
    NOTICE D_NOTICE,
    P_ACTION D_INTEGER)
AS
begin
  -- P_ACTION -0 insert 1-update 2-delete

  delete from Request_Materials_Return M where m.Id = :ID;

  if ((P_Action <> 2) and (QUANT > 0)) then begin
    if (QUANT is null) then
      QUANT = 0;

    insert into Request_Materials_Return (Rq_Id, M_Id, Wh_Id, Quant, Notice)
    values (:Rq_Id, :M_Id, :Wh_Id, :Quant, :Notice);
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_RECREATE (
    FROM_REQUEST D_INTEGER)
AS
declare variable Rq_Type D_Integer;
declare variable Rqtl_Id D_Integer;
declare variable RQ_DAYS D_Integer;
declare variable NEW_ID  D_INTEGER;
begin
  select
      tl.Recreate_Days
    , r.Rq_Type
    , coalesce(tl.Recreate_Type, r.Rqtl_Id)
    from request r
         inner join Request_Templates tl on (r.Rqtl_Id = tl.Rqtl_Id)
    where r.rq_id = :from_request
  into :RQ_DAYS, :Rq_Type, :Rqtl_Id;

  if (not RQ_DAYS is null) then begin
    NEW_ID = gen_id(gen_request, 1);
    insert into Request (Rq_Id, Rq_Type, Rq_Customer, Rq_Content, Rq_Defect, Rq_Completed, Rq_Notice, Rq_Plan_Date, Rq_Time_From, Rq_Time_To, House_Id, Flat_No, Porch_N, Floor_N, Phone, Rq_Exec_Time, Req_Result, Rqtl_Id, Door_Code, Cause_Id, Result_Id, Tag, Node_Id, Parent_Rq)
    select
        :NEW_ID
      , :Rq_Type
      , Rq_Customer
      , Rq_Content
      , Rq_Defect
      , Rq_Completed
      , Rq_Notice
      , dateadd(day, :RQ_DAYS, RQ_PLAN_DATE)
      , Rq_Time_From
      , Rq_Time_To
      , House_Id
      , Flat_No
      , Porch_N
      , Floor_N
      , Phone
      , Rq_Exec_Time
      , Req_Result
      , :Rqtl_Id
      , Door_Code
      , Cause_Id
      , Result_Id
      , Tag
      , Node_Id
      , Parent_Rq
      from Request
      where rq_id = :from_request;
  end
end;


CREATE OR ALTER PROCEDURE REQUEST_SEND_SMS (
    REQUEST_ID TYPE OF UID,
    SMS D_VARCHAR1000)
AS
declare variable phone_list D_VARCHAR50;
declare variable phone      D_VARCHAR50;
begin
  if (SMS is null) then begin
    select
        s.street_name || ' ' || h.house_no || ' ' || r.Flat_No || ' ' || coalesce(tpl.Rq_Content || '.', '') || coalesce(r.rq_content, '') as rq_content
      from request r
           inner join house h on (r.house_id = h.house_id)
           inner join street s on (h.street_id = s.street_id)
           left outer join REQUEST_TYPES RT on (R.RQ_TYPE = RT.RT_ID)
           left outer join REQUEST_TEMPLATES TPL on (TPL.RQTL_ID = R.RQTL_ID)
      where r.rq_id = :REQUEST_ID
    into :SMS;
  end

  for select
          w.Phone_No
        from Worker w
             inner join Request_Executors e on (w.Worker_Id = e.Exec_Id)
        where e.Rq_Id = :REQUEST_ID
      into :phone_list
  do begin
    phone_list = REPLACE(phone_list, '-', '');
    phone_list = REPLACE(phone_list, ' ', ',');
    for select
            substring(Str from 1 for 50)
          from Explode_No_Empty(',', :phone_list)
        into :phone
    do begin
      insert into Messages (Mes_Type, Reciver, Mes_Text)
      values ('SMS', :phone, :SMS);
    end
  end

end;


CREATE OR ALTER PROCEDURE REQUEST_WORKS_IUD (
    RQ_ID UID,
    W_ID UID,
    W_QUANT D_N15_5,
    W_TIME D_N15_3,
    W_COST D_N15_3,
    NOTICE D_DESCRIPTION,
    P_ACTION D_SMALLINT)
AS
BEGIN
-- P_ACTION -0 insert 1-update 2-delete
  DELETE FROM request_works M
  where m.RQ_ID = :RQ_ID
    and m.W_ID = :W_ID;

  if (W_QUANT is null) then W_QUANT = 0;

  if (W_TIME is null)
  then
    select w.w_time from works w where w.w_id = :W_ID
      into :W_TIME;

  IF ((P_Action <> 2) and (W_QUANT<>0))
  THEN
    INSERT INTO request_works  (RQ_ID, w_id,w_quant, w_time, W_COST, NOTICE)
    VALUES (:RQ_ID,:W_ID,:W_QUANT, :W_TIME, :W_COST, :NOTICE);
END;


CREATE OR ALTER PROCEDURE REQUESTGIVE (
    P_REQUEST TYPE OF UID,
    P_DATE D_DATETIME,
    WORKGROUP D_UID_NULL,
    WORKERS D_VARCHAR1000,
    AGIVEAS D_INTEGER = 0)
AS
-- declare variable id D_Integer;
begin
  if (p_date is null) then
    p_date = localtimestamp;
  if (WORKERS is null) then
    WORKERS = '';
  if (aGiveAs is null) then
    aGiveAs = 0;

  update request r
  set r.req_result = 1,
      r.RQ_COMPLETED = :P_DATE,
      r.give_method = :aGiveAs,
      r.GIVE_BY = current_user
  where r.rq_id = :p_request
        and coalesce(r.req_result, 0) <= 1;

  delete from request_executors
      where rq_id = :p_request;

  if (not WORKGROUP is null) then begin
    insert into request_executors (rq_id, exec_id)
    select
        :p_request
      , w.worker_id
      from worker w
           inner join workgroups wg on (w.team = wg.name)
      where w.working = 1
            and w.in_request = 1
            and wg.wg_id = :WORKGROUP;
  end
  else begin
    if (WORKERS <> '') then begin
      insert into request_executors (rq_id, exec_id)
      select
          :p_request
        , w.Worker_Id
        from worker w
             inner join Split_Str_To_Rows(:WORKERS) wg on (w.Worker_Id = wg.ID)
        where w.working = 1
              and w.in_request = 1
              and not exists(select
                                 exec_id
                               from request_executors
                               where exec_id = wg.Id
                                     and rq_id = :p_request);
    end
    else begin
      -- если не задано ни группы ни исполнителей, то выдадим звену которое обслуживает дом
      insert into request_executors (rq_id, exec_id)
      select
          r.rq_id
        , w.worker_id
        from worker w
             inner join workgroups wg on (w.team = wg.name)
             inner join house h on (h.wg_id = wg.wg_id)
             inner join request r on (r.house_id = h.house_id)
        where w.working = 1
              and w.in_request = 1
              and r.rq_id = :p_request;
    end
  end
end;


CREATE OR ALTER PROCEDURE REQUESTMOVE (
    P_REQUEST TYPE OF UID,
    P_DATE D_DATETIME)
AS
declare variable rState d_integer;
begin
  select
      r.req_result
    from request r
    where r.rq_id = :p_request
  into :rState;

  if (rstate <= 2) then begin

    if (p_date is null) then
      p_date = localtimestamp;

    update request r
    set r.req_result = 0,
        r.rq_plan_date = :P_DATE,
        r.RQ_COMPLETED = null,
        r.rq_exec_time = null
    where r.rq_id = :p_request;

    delete from request_executors
        where rq_id = :p_request;

  end

end;


CREATE OR ALTER PROCEDURE SELECTONOFFSERVICE (
    ACUSTOMER_ID TYPE OF UID,
    ASERVICE_ID TYPE OF UID,
    ASUBSCR_SERV_ID TYPE OF UID,
    AOFF D_INTEGER)
RETURNS (
    ID TYPE OF UID,
    NAME TYPE OF D_SERVICE_NAME,
    DESCRIPTION D_VARCHAR1000,
    SERVICE_TYPE D_INTEGER)
AS
DECLARE VARIABLE I D_INTEGER;
begin
  if (aOff=0) then begin
    -- проверим было ли ранее подключение?
    if (ASUBSCR_SERV_ID is null)
    then i = 2; -- первичное подключение
    else i = 3;  -- повторное подключение

    for
      select
        s.SERVICE_ID,
        s.NAME,
        s.DESCRIPTION,
        s.srv_type_id
      from services s inner join services_links l on (s.SERVICE_ID = l.CHILD)
      where l.LINK_TYPE = :I
        and l.PARENT = :ASERVICE_ID
        order by s.NAME
       into  :ID, :NAME, :DESCRIPTION , :SERVICE_TYPE
    do suspend;
  end
  else begin
    for
      select
        s.SERVICE_ID,
        s.NAME,
        s.DESCRIPTION,
        s.srv_type_id
      from services s inner join services_links l on (s.SERVICE_ID = l.CHILD)
      where l.LINK_TYPE in (4,5) -- отключение
        and l.PARENT = :ASERVICE_ID
        order by s.NAME
       into  :ID, :NAME, :DESCRIPTION, :SERVICE_TYPE
    do suspend;
  end
end;


CREATE OR ALTER PROCEDURE SELECTPAYDOC (
    FORFORM VARCHAR(10) = null)
RETURNS (
    PAY_DOC_ID D_INTEGER)
AS
declare variable vPSID D_INTEGER;
begin
  vPSID = null;
  ForForm = coalesce(ForForm, '');
  if (ForForm <> '') then begin
    select first 1
        ps.Paysource_Id
      from paysource ps
      where position(:ForForm in ps.For_Form) > 0
      order by 1
    into :vPSID;
  end

  select
      Pay_Doc_Id
    from Get_Pay_Doc(:vPSID, null, null)
  into :Pay_Doc_Id;

  suspend;
end;


CREATE OR ALTER PROCEDURE SELECTSWITCHSERVICE (
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID)
RETURNS (
    ID TYPE OF UID,
    NAME TYPE OF D_NAME,
    DESCRIPTION D_VARCHAR100,
    SERVICE_TYPE D_INTEGER)
AS
begin
  for select
          s.SERVICE_ID, s.NAME, s.DESCRIPTION, s.srv_type_id
        from services s
             inner join services_links l on (s.SERVICE_ID = l.Add_Srv)
        where l.LINK_TYPE = 6 -- переключение
              and l.Parent = :From_Srv
              and l.Child = :To_Srv
        order by s.NAME
      into :ID, :NAME, :DESCRIPTION, :SERVICE_TYPE
  do
    suspend;
end;


CREATE OR ALTER PROCEDURE SERVICES_D (
    SERVICE_ID TYPE OF UID)
AS
declare variable i type of UID;
BEGIN
  SELECT SRV_TYPE_ID FROM SERVICES WHERE SERVICE_ID = :SERVICE_ID
  INTO :I;

  if (I=0)
  then
    select count(*) from SUBSCR_SERV where SERV_ID = :SERVICE_ID
    INTO :I;
  else
    select count(*) from SINGLE_SERV ss where ss.SERVICE_ID = :SERVICE_ID
    INTO :I;
  if (I=0)
  then begin
    DELETE FROM SERVICES
    WHERE (SERVICE_ID = :SERVICE_ID);

    delete from SERVICES_LINKS sl
    where sl.PARENT = :SERVICE_ID;

    delete from SERVICES_LINKS sl
    where sl.CHILD = :SERVICE_ID;
  end
  else exception E_CANNOT_DELETE ;
END;


CREATE OR ALTER PROCEDURE SERVICES_IU (
    SERVICE_ID UID,
    SRV_TYPE_ID UID,
    SHIFT_MONTHS D_INTEGER,
    NAME D_VARCHAR60,
    SHORTNAME D_VARCHAR10,
    CALC_TYPE D_INTEGER,
    DESCRIPTION D_NOTICE,
    DIMENSION D_VARCHAR5,
    SHOW_SERVICE D_INTEGER,
    EXPENSE_TYPE D_INTEGER,
    EXTRA D_INTEGER,
    EXTERNAL_ID D_VARCHAR100,
    INET_SRV D_IBOOLEAN,
    IP_BEGIN D_IP,
    IP_END D_IP,
    BUSINESS_TYPE D_INTEGER,
    AUTOOFF D_IBOOLEAN,
    POSITIVE_ONLY D_IBOOLEAN,
    PRIORITY D_INTEGER,
    ONLY_ONE D_IBOOLEAN,
    NOTE D_DESCRIPTION = '',
    TAG D_INTEGER = null,
    TAG_STR D_VARCHAR255 = '',
    OPENLY D_IBOOLEAN = 0,
    UNBL_METH D_INTEGER = 0)
AS
begin
  if (exists(select
                 SERVICE_ID
               from SERVICES
               where (SERVICE_ID = :SERVICE_ID)))

  then
    update Services s
    set Srv_Type_Id = :Srv_Type_Id,
        Shift_Months = :Shift_Months,
        Name = :Name,
        CALC_TYPE = :CALC_TYPE,
        Shortname = :Shortname,
        Description = :Description,
        Dimension = :Dimension,
        Expense_Type = :Expense_Type,
        Extra = :Extra,
        External_Id = :External_Id,
        Inet_Srv = :Inet_Srv,
        Ip_Begin = :Ip_Begin,
        Ip_End = :Ip_End,
        BUSINESS_TYPE = :BUSINESS_TYPE,
        AUTOOFF = :AUTOOFF,
        Positive_Only = :Positive_Only,
        PRIORITY = :PRIORITY,
        ONLY_ONE = :ONLY_ONE,
        NOTE = :NOTE,
        OPENLY = :OPENLY,
        TAG = :TAG,
        TAG_STR = :TAG_STR,
        Unbl_Meth = :Unbl_Meth
    where (Service_Id = :Service_Id);
  else
    insert into Services (Service_Id, Srv_Type_Id, Shift_Months, Name, CALC_TYPE, Shortname, Description, Dimension, Expense_Type, Extra, External_Id, Inet_Srv, Ip_Begin, Ip_End, BUSINESS_TYPE, AUTOOFF, Positive_Only, PRIORITY, ONLY_ONE, Note, Tag, Tag_Str, Openly, Unbl_Meth)
    values (:Service_Id, :Srv_Type_Id, :Shift_Months, :Name, :CALC_TYPE, :Shortname, :Description, :Dimension, :Expense_Type, :Extra, :External_Id, :Inet_Srv, :Ip_Begin, :Ip_End, :BUSINESS_TYPE, :AUTOOFF, :Positive_Only, :PRIORITY, :ONLY_ONE, :Note, :Tag, :Tag_Str, :Openly, :Unbl_Meth);

  -- если услугу можно добавлять абоненту
  -- то добавим ее в таблицу SERVICES_LINKS
  if (SHOW_SERVICE = 1) then begin
    -- проверим, может такая услуга уже есть в таблице связей
    if (not exists(select
                       sl.LINK_ID
                     from SERVICES_LINKS sl
                     where sl.PARENT is null
                           and sl.CHILD = :SERVICE_ID)) then begin
      if (SRV_TYPE_ID <> 0) then
        SRV_TYPE_ID = 1;

      insert into SERVICES_LINKS (LINK_ID, LINK_TYPE, PARENT, CHILD)
      values (gen_id(GEN_OPERATIONS_UID, 1), :SRV_TYPE_ID, null, :SERVICE_ID);
    end
  end
  else
    delete from SERVICES_LINKS sl
        where sl.PARENT is null
              and sl.CHILD = :SERVICE_ID;
end;


CREATE OR ALTER PROCEDURE SET_DISTRIB_REPORT (
    DISTRIB_ID D_INTEGER,
    PERIOD D_DATE,
    START_CNT D_INTEGER,
    END_CNT D_INTEGER,
    START_SUM D_N15_2,
    END_SUM D_N15_2,
    V_NUM D_N15_2,
    V_DATE D_DATE,
    V_TEXT D_VARCHAR255,
    NOTICE D_VARCHAR50,
    CONTRACT_ID D_INTEGER)
AS
begin
  Period = MONTH_FIRST_DAY(Period);
  for select
          Id
        from Distrib_Contracts dc
        where (((:period >= dc.C_Date
              and (dc.C_Date_Before is null
                or :period <= dc.C_Date_Before))
                or (:period = MONTH_FIRST_DAY(dc.C_Date)))
              and (:Distrib_Id is null))
                or (dc.Distributor_Id = :Distrib_Id)
      into :Contract_Id
  do begin
    update or insert into Distrib_Contract_Reports (Contract_Id, Period, Start_Cnt, End_Cnt, Start_Sum, End_Sum, V_Num, V_Date, V_Text, Notice)
    values (:Contract_Id, :Period, :Start_Cnt, :End_Cnt, :Start_Sum, :End_Sum, :V_Num, :V_Date, :V_Text, :Notice)
    matching (CONTRACT_ID, PERIOD);
  end
end;


CREATE OR ALTER PROCEDURE SET_DISTRIB_REPORT_AS_PERIOD (
    PERIOD D_DATE,
    DISTRIB_ID D_INTEGER = null,
    CONTRACT_ID D_INTEGER = null)
AS
declare variable prev D_Date;
begin
  Period = MONTH_FIRST_DAY(Period);
  prev = dateadd(month, -1, Period);

  -- если указан конкретный договор. то удалим все старые данные. иначе данные будем сохранять
  if (not CONTRACT_ID is null) then begin
    delete from Distrib_Contract_Reports where Period = :Period and Contract_Id = :Contract_Id;
    delete from Distrib_Contract_Reports_Ch where Period = :Period and Contract_Id = :Contract_Id;
    insert into Distrib_Contract_Reports (Contract_Id, Period, Start_Cnt, End_Cnt, Start_Sum, End_Sum, V_Num, V_Date, V_Text, Notice)
    select Contract_Id, :Period, End_Cnt, End_Cnt, End_Sum, End_Sum, V_Num, V_Date, V_Text, Notice
      from Distrib_Contract_Reports where Period = :prev and Contract_Id = :Contract_Id;

    insert into Distrib_Contract_Reports_Ch (Contract_Id, Period, Ch_Id, Start_Cnt, End_Cnt, Start_Sum, End_Sum, Notice)
    select Contract_Id, :Period, Ch_Id, End_Cnt, End_Cnt, End_Sum, End_Sum, Notice
      from Distrib_Contract_Reports_Ch
      where Period = :prev and Contract_Id = :Contract_Id;
  end
  else begin
    if (not DISTRIB_ID is null) then begin
      -- delete from Distrib_Contract_Reports where Period = :Period;
      -- delete from Distrib_Contract_Reports_Ch where Period = :Period;
      insert into Distrib_Contract_Reports (Contract_Id, Period, Start_Cnt, End_Cnt, Start_Sum, End_Sum, V_Num, V_Date, V_Text, Notice)
      select Contract_Id, :Period, End_Cnt, End_Cnt, End_Sum, End_Sum, V_Num, V_Date, V_Text, Notice
        from Distrib_Contract_Reports p
        where Period = :prev
          and (not exists(select i.Contract_Id from Distrib_Contract_Reports i where i.Contract_Id = p.Contract_Id  and i.Period = :Period));

      insert into Distrib_Contract_Reports_Ch (Contract_Id, Period, Ch_Id, Start_Cnt, End_Cnt, Start_Sum, End_Sum, Notice)
      select Contract_Id, :Period, Ch_Id, End_Cnt, End_Cnt, End_Sum, End_Sum, Notice
        from Distrib_Contract_Reports_Ch p
        where Period = :prev
          and (not exists(select i.Contract_Id from Distrib_Contract_Reports_Ch i where i.Contract_Id = p.Contract_Id  and i.Period = :Period));
    end
    else begin
      insert into Distrib_Contract_Reports (Contract_Id, Period, Start_Cnt, End_Cnt, Start_Sum, End_Sum, V_Num, V_Date, V_Text, Notice)
      select Contract_Id, :Period, End_Cnt, End_Cnt, End_Sum, End_Sum, V_Num, V_Date, V_Text, Notice
        from Distrib_Contract_Reports p
        where Period = :prev
          and exists( select d.Id from Distrib_Contracts d where d.Distributor_Id = :DISTRIB_ID and d.Id = p.Contract_Id )
          and (not exists(select i.Contract_Id from Distrib_Contract_Reports i where i.Contract_Id = p.Contract_Id  and i.Period = :Period));

      insert into Distrib_Contract_Reports_Ch (Contract_Id, Period, Ch_Id, Start_Cnt, End_Cnt, Start_Sum, End_Sum, Notice)
      select Contract_Id, :Period, Ch_Id, End_Cnt, End_Cnt, End_Sum, End_Sum, Notice
        from Distrib_Contract_Reports_Ch p
        where Period = :prev
          and exists( select d.Id from Distrib_Contracts d where d.Distributor_Id = :DISTRIB_ID and d.Id = p.Contract_Id )
          and (not exists(select i.Contract_Id from Distrib_Contract_Reports_Ch i where i.Contract_Id = p.Contract_Id  and i.Period = :Period));
    end
  end
end;


CREATE OR ALTER PROCEDURE SET_FLAT_PF (
    HOUSE_ID TYPE OF COLUMN HOUSEFLATS.HOUSE_ID,
    FLAT_NO TYPE OF COLUMN HOUSEFLATS.FLAT_NO,
    PORCH_N TYPE OF COLUMN HOUSEFLATS.PORCH_N,
    FLOOR_N TYPE OF COLUMN HOUSEFLATS.FLOOR_N)
AS
begin
  update Houseflats
  set PORCH_N = :PORCH_N,
      FLOOR_N = :FLOOR_N
  where House_Id = :HOUSE_ID
        and Flat_No = :FLAT_NO;

  if (row_count = 0) then begin
    insert into Houseflats (PORCH_N, FLOOR_N, FLAT_NO, HOUSE_ID)
    values (:PORCH_N, :FLOOR_N, :FLAT_NO, :HOUSE_ID);
  end
end;


CREATE OR ALTER PROCEDURE SET_PREPAY (
    CUSTOMER_ID UID,
    PREPAY_SUM D_N15_2)
AS
begin
  if (Prepay_Sum is null) then
    Prepay_Sum = 0;
  if (Prepay_Sum < 0) then
    Prepay_Sum = 0;

  if (Prepay_Sum = 0) then
    update CUSTOMER
    set PREPAY = 0, prepay_time = null
    where CUSTOMER_ID = :Customer_Id;
  else
    insert into PREPAY_DETAIL (CUSTOMER_ID, PPD_SUM)
    values (:Customer_Id, :Prepay_Sum);

  -- execute procedure CHECK_FOR_UNBLOCK(:Customer_Id); -- вызов в триггере
end;


CREATE OR ALTER PROCEDURE SET_SETTINGS (
    ANAME D_VARCHAR50,
    AVALUE D_VARCHAR1000)
AS
declare variable V D_VARCHAR1000;
begin
  ANAME = upper(:ANAME);
  select
      Var_Value
    from settings
    where var_name = :ANAME
  into :V;

  if (V is distinct from AVALUE) then
    update or insert into Settings (Var_Name, Var_Value)
    values (:ANAME, :AVALUE)
    matching (Var_Name);
end;


CREATE OR ALTER PROCEDURE SPLIT_STR_TO_ROWS (
    IDS D_VARCHAR1000)
RETURNS (
    ID D_INTEGER)
AS
declare variable i D_Integer = 1;
declare variable s D_Varchar100 = '';
declare variable n d_integer;
declare variable l d_integer;
declare variable c d_char1;
declare variable d D_Varchar100;
begin
  IDS = trim(IDS) || ',';
  while (I <= char_length(IDS)) do begin
    i = POSITION(',' IN IDS);
    if (i > 0) then begin
      s = substring(IDS from 1 for i-1);
      IDS = substring(IDS from i+1);
      if (s <> '') then begin
        l = char_length(s);
        n = 1;
        d = '';
        while (n <= l) do begin
          c = substring(s from n for 1);
          if (c between '0' and '9') then
            d = d || c;
          n = n + 1;
        end
        if (d <> '') then begin
          ID = d;
          suspend;
        end
      end
      i = 1;
    end
  end
end;


CREATE OR ALTER PROCEDURE SWITCH_CANCEL (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable SWITCH_SRV  type of UID;
declare variable UNITS       D_N15_2;
declare variable SWITCH_DATE D_DATE;
declare variable NOTICE      D_NOTICE;
declare variable Add_Srv     type of Uid;
declare variable Switch_Time type of Uid;
declare variable Vdate       type of D_Date;
declare variable i           D_Integer;
begin

  select
      ss.State_Date, ss.State_Srv
    from Subscr_Serv ss
    where ss.Customer_Id = :CUSTOMER_ID
          and ss.Serv_Id = :FROM_SRV
          and ss.State_Sgn = 0
  into :SWITCH_DATE, :SWITCH_SRV;

  /* Если дата переключения уже прошла, отмена невозможна */
  if ((coalesce(SWITCH_DATE, dateadd(day, -1, current_date)) >= current_date)
      and (not SWITCH_SRV is null)) then begin
    /* если услуга не определена, то найдем ее*/
    if (TO_SRV is null) then begin
      TO_SRV = null;
      /* если услуга отключена будем думать дальше */
      if (not SWITCH_SRV is null) then begin
        TO_SRV = null;
        select first 1
            ss.Serv_Id
          from Subscr_Serv ss
          where ss.Customer_Id = :CUSTOMER_ID
                and ss.State_Date = :SWITCH_DATE
                and ss.State_Srv = :SWITCH_SRV
                and ss.State_Sgn = 1
        into :TO_SRV;
      end
    end

    /* если известно на какую услугу переключали, то откатим все назад */
    if (not TO_SRV is null) then begin
      /* спачала отключим новую услугу */
      delete from SUBSCR_HIST s
      where CUSTOMER_ID = :CUSTOMER_ID
            and SERV_ID = :TO_SRV
            and DATE_FROM = :SWITCH_DATE
            and ACT_SERV_ID = :SWITCH_SRV
            and s.Disact_Serv_Id = -1;

      select
          count(*)
        from SUBSCR_HIST s
        where CUSTOMER_ID = :CUSTOMER_ID
              and SERV_ID = :TO_SRV
      into :i;
      if (i = 0) then begin
        delete from subscr_serv s
        where CUSTOMER_ID = :CUSTOMER_ID
              and SERV_ID = :TO_SRV;
      end
      else begin
        select first 1
            s.Disact_Serv_Id, s.Date_To
          from SUBSCR_HIST s
          where CUSTOMER_ID = :CUSTOMER_ID
                and SERV_ID = :TO_SRV
          order by s.Date_To desc
        into :i, :Vdate;

        update subscr_serv s
        set s.State_Sgn = 0,
            s.State_Date = dateadd(day, 1, :Vdate),
            s.State_Srv = :i
        where CUSTOMER_ID = :CUSTOMER_ID
              and SERV_ID = :TO_SRV;
      end
      /* теперь включим старую услугу */
      select first 1
          s.Date_To, s.Date_From, s.Act_Serv_Id
        from SUBSCR_HIST s
        where CUSTOMER_ID = :CUSTOMER_ID
              and SERV_ID = :FROM_SRV
        order by s.Date_To desc
      into :Vdate, :SWITCH_DATE, :i;

      update SUBSCR_HIST s
      set s.Date_To = '2100-1-1',
          s.Disact_Serv_Id = -1
      where CUSTOMER_ID = :CUSTOMER_ID
            and SERV_ID = :FROM_SRV
            and s.Date_To = :Vdate;

      update subscr_serv s
      set s.State_Sgn = 1,
          s.State_Date = :SWITCH_DATE,
          s.State_Srv = :i
      where CUSTOMER_ID = :CUSTOMER_ID
            and SERV_ID = :FROM_SRV;

    end
  end
end;


CREATE OR ALTER PROCEDURE SWITCH_SERVICE (
    CUSTOMER_ID TYPE OF UID,
    FROM_SRV TYPE OF UID,
    TO_SRV TYPE OF UID,
    SWITCH_SRV TYPE OF UID,
    UNITS D_N15_2,
    SWITCH_DATE D_DATE,
    NOTICE D_NOTICE)
RETURNS (
    RESULT D_INTEGER)
AS
declare variable Add_Srv     D_Uid_Null;
declare variable Switch_Time D_Uid_Null;
declare variable vDate       D_Date;
declare variable vBlance     D_N15_2;
declare variable vAutoOff    D_INTEGER;
declare variable vHand       D_INTEGER; -- declare variable vTarif      D_N15_2;
-- declare variable vDays       D_INTEGER;
begin
  if (Switch_Date is null) then
    Switch_Date = current_date;

  /* проверим, если услуга уже отключена, то ничего не делаем */
  select
      c.HAND_CONTROL
    ,
      (-1.00 * c.Debt_Sum + coalesce(c.Prepay, 0))
    , iif(exists(select
                     sh.Subscr_Serv_Id
                   from SUBSCR_SERV SH
                   where SH.Customer_Id = C.CUSTOMER_ID
                         and SH.Serv_Id = :FROM_SRV
                         and sh.State_Sgn = 0), 1, 0)
    from customer c
    where c.Customer_Id = :CUSTOMER_ID
  into :vHand, :vBlance, :Add_Srv;
  vHand = coalesce(vHand, 0);

  if (Add_Srv = 0) then begin

    UNITS = coalesce(UNITS, 0);

    /* получим услугу переключения и когда ее можно переключать */
    Add_Srv = null;
    Switch_Time = null;
    Result = 0;

    select first 1
        sl.Add_Srv
      , coalesce(sl.Switch_Time, 0)
      ,
        (select
             s.Autooff
           from services s
           where s.Service_Id = :FROM_SRV)
      from Services_Links sl
      where sl.Parent = :FROM_SRV
            and sl.Child = :TO_SRV
            and sl.Link_Type = 6
            and ((sl.Add_Srv = :SWITCH_SRV)
              or (:SWITCH_SRV is null))
    into :Add_Srv, :Switch_Time, :vAutoOff;

    vAutoOff = coalesce(vAutoOff, 0);

    if (Add_Srv is not null) then begin
      if (Switch_Time = 1) then begin
        /* 1 - Начало суток */
        vDate = dateadd(day, 1, current_date);
        if (Switch_Date < vDate) then
          Switch_Date = vDate;
      end
      else begin
        if (Switch_Time = 2) then begin
          /* 2 - Начало месяца */
          vDate = dateadd(month, 1, (current_date - extract(day from current_date) + 1));
          if (Switch_Date < vDate) then
            Switch_Date = vDate;
        end
      end

      if (1 = vAutoOff) then begin
        /*
        -- проверим, если хватает денег на остаток дней, то переключим

        select (-1.00 * c.Debt_Sum + coalesce(c.Prepay, 0) )
            ,
            (select
                 sum(iif(coalesce(c.Juridical, 0) = 0, t.Tarif_Sum, t.Tarif_Sum_Jur))
               from Subscr_Serv ss
                    inner join Tarif t on (ss.Serv_Id = t.Service_Id)
               where ss.State_Sgn = 1
                     and ss.Customer_Id = c.Customer_Id
                     and current_date between t.Date_From and t.Date_To)
          from customer c
          where c.Customer_Id = :CUSTOMER_ID
        into :vBlance, :vTarif;
        -- посчитаем сколько примерно в день абонплата
        vDays = extract(day from dateadd(-1 day to(dateadd(1 month to (current_date - extract(day from current_date) + 1)))));
        vTarif = coalesce(vTarif, 0) / vDays; -- в день
        vDays = datediff(day from current_date to Switch_Date);
        vTarif = vTarif * vDays; -- До конца месяца
        -- если не хватает, поставим признак
        if (vBlance < vTarif) then
          vAutoOff = -1;
        */

        -- если не ручное управление, переключаем только если положительный баланс
        if ((vHand = 0) and (vBlance < 0)) then
          vAutoOff = -1;
      end

      if (vAutoOff <> -1) then begin
        execute procedure Onoff_Service_By_Id(:CUSTOMER_ID, :FROM_SRV, :Add_Srv, :SWITCH_DATE, 1, :NOTICE, :UNITS, 0, 0);
        Switch_Time = null;
        select
            ss.State_Sgn
          , ss.State_Date
          from Subscr_Serv ss
          where ss.Customer_Id = :Customer_Id
                and ss.Serv_Id = :To_Srv
        into :Switch_Time, :vDate;
        /* если услуги у абонента нет, то добавим ее иначе просто включим */
        if (Switch_Time is null) then
          execute procedure Add_Subscr_Service(:Customer_Id, :To_Srv, :Add_Srv, :SWITCH_DATE, :NOTICE, :UNITS, null, null);
        else
          execute procedure Onoff_Service_By_Id(:Customer_Id, :To_Srv, :Add_Srv, :SWITCH_DATE, 0, :NOTICE, :UNITS);
      end
      else
        Result = -3;/* Нет денег на счете */
    end
    else
      Result = -1;/* Не настроена связка переключений услуг */
  end
  else
    Result = -2;/* Услуга уже отключена */

  suspend;
end;


CREATE OR ALTER PROCEDURE TARIF_IUD (
    P_TARIF_ID TYPE OF UID,
    P_SERVICE_ID TYPE OF UID,
    P_DATE_FROM D_DATE,
    P_DATE_TO D_DATE,
    P_TARIF_SUM D_N15_2,
    P_TARIF_JUR D_N15_2,
    P_ACTION D_INTEGER)
AS
declare variable v_tarif_id  type of UID;
declare variable v_date_to   d_date;
declare variable v_date_from d_date;
begin
  -- P_ACTION -0 insert 1-update 2-delete
  if (p_action = 0) then begin
    select
        count(*)
      from tarif t
      where t.service_id = :p_service_id
            and t.Date_From = :p_date_from
    into :v_tarif_id;
    if (v_tarif_id = 0) then begin
      select
          tarif_id
        from tarif t
        where t.service_id = :p_service_id
              and :p_date_from between t.date_from and t.date_to
      into :v_tarif_id;

      if (not v_tarif_id is null) then
        update tarif
        set date_to = (:p_date_from - 1)
        where (tarif_id = :v_tarif_id);
      p_date_to = '2100-01-01';
      insert into tarif (service_id, date_from, date_to, tarif_sum, tarif_sum_jur)
      values (:p_service_id, :p_date_from, :p_date_to, :p_tarif_sum, :P_TARIF_JUR);
    end
    else
      exception E_TARIF_EXISTS;
  end

  if (p_action = 1) then begin
    update tarif
    set tarif_sum = :p_tarif_sum
    where (tarif_id = :p_tarif_id);
  end

  if (P_ACTION = 2) then begin
    -- найдем предидущий тариф и заменим дату окончания, датой окончания удаляемого тарифа

    select
        t.date_from, t.date_to
      from tarif t
      where tarif_id = :p_tarif_id
    into :v_date_from, :v_date_to;

    select first 1
        tarif_id
      from tarif t
      where t.service_id = :p_service_id
            and t.date_to = (:v_date_from - 1)
    into :v_tarif_id;

    if (not v_tarif_id is null) then
      update tarif
      set date_to = :v_date_to
      where (tarif_id = :v_tarif_id);

    delete from tarif where (tarif_id = :p_tarif_id);
  end
end;


CREATE OR ALTER PROCEDURE UPDATE_SERVICES_TREE (
    CUSTOMER_ID TYPE OF UID,
    SERVICE_ID TYPE OF UID)
AS
declare variable B_ID D_INTEGER;
begin
  select
      s.business_type
    from services s
    where s.service_id = :service_id
  into :b_id;

  if (b_id = 1) then -- СЕТЬ
    update tv_lan l
    set l.last_update = localtimestamp
    where l.customer_id = :CUSTOMER_ID;
  else begin
    if (b_id >= 2) then -- ЦИФРА
      update customer_decoders l
      set l.last_update = localtimestamp
      where l.customer_id = :CUSTOMER_ID;
  end
end;


CREATE OR ALTER PROCEDURE UPDATECUSTOMERDEBT4PAY (
    P_CUSTOMER_ID UID,
    P_SUM D_N15_2)
AS
begin
  if (P_SUM > 0) then
    update CUSTOMER C
    set C.DEBT_SUM = coalesce(C.DEBT_SUM, 0) - :P_SUM,
        C.PREPAY = 0, -- iif(coalesce(C.PREPAY, 0) > :P_SUM, C.PREPAY - :P_SUM, 0),
        C.PREPAY_TIME = null -- iif(coalesce(C.PREPAY, 0) > :P_SUM, C.PREPAY_TIME, null)
    where C.CUSTOMER_ID = :P_CUSTOMER_ID;
  else
    update CUSTOMER C
    set C.DEBT_SUM = coalesce(C.DEBT_SUM, 0) - :P_SUM
    where C.CUSTOMER_ID = :P_CUSTOMER_ID;

  execute procedure CHECK_FOR_UNBLOCK(:P_CUSTOMER_ID);
end;


CREATE OR ALTER PROCEDURE WORKER_IUD (
    OPERATION D_INTEGER,
    WORKER_ID D_INTEGER,
    SURNAME D_VARCHAR30,
    FIRSTNAME D_VARCHAR30,
    MIDLENAME D_VARCHAR30,
    PHONE_NO D_VARCHAR30,
    NOTICE D_NOTICE,
    WORKING D_SMALLINT,
    IBNAME D_VARCHAR30,
    LOCKEDOUT D_INTEGER,
    ALL_AREAS D_SMALLINT)
AS
begin
  if (lockedout is null) then
    lockedout = 1;
  if (operation = 1) --  добавим
  then begin
    if (worker_id is null) then begin
      worker_id = gen_id(gen_operations_uid, 1);
      insert into worker (worker_id, surname, firstname, midlename, phone_no, notice, working, ibname)
      values (:worker_id, :surname, :firstname, :midlename, :phone_no, :notice, :working, :ibname);
    end
    else begin
      update WORKER
      set IBNAME = :ibname
      where (WORKER_ID = :worker_id);
    end
    if (IBNAME is not null) then
      update or insert into Sys$User (Id, Ibname, Lockedout, All_Areas)
      values (:worker_id, :Ibname, :Lockedout, :All_Areas)
      matching (Ibname);
  end

  if (operation = 2) --  обновим
  then begin
    update worker
    set surname = :surname,
        firstname = :firstname,
        midlename = :midlename,
        phone_no = :phone_no,
        notice = :notice,
        working = :working,
        ibname = :ibname
    where (worker_id = :worker_id);

    if (IBNAME is not null) then begin
      update or insert into Sys$User (Ibname, Lockedout, All_Areas)
      values (:Ibname, :Lockedout, :All_Areas)
      matching (Ibname);
    end
  end

  if (operation = 3) --  удалим
  then begin
    delete from worker where worker_id = :worker_id;
    delete from sys$user where id = :worker_id;
  end
end;


CREATE OR ALTER PROCEDURE YEARWEEK (
    D D_DATE)
RETURNS (
    WEEK_NO D_INTEGER)
AS
DECLARE VARIABLE W D_INTEGER;  /* week number */
BEGIN
  D = D - EXTRACT(WEEKDAY FROM D-1) + 3;  /* move to thursday */

  W = (EXTRACT(YEARDAY FROM D) - EXTRACT(WEEKDAY FROM D-1) + 7) / 7e0;

  WEEK_NO = W;

  SUSPEND;
END;


CREATE OR ALTER FUNCTION DISTANCE (
    LNG1 D_GEOPOINT,
    LAT1 D_GEOPOINT,
    LNG2 D_GEOPOINT,
    LAT2 D_GEOPOINT)
RETURNS D_INTEGER DETERMINISTIC
AS
DECLARE variable lat_1 FLOAT DEFAULT 0.0;
DECLARE variable lat_2 FLOAT DEFAULT 0.0;
DECLARE variable lng_1 FLOAT DEFAULT 0.0;
DECLARE variable lng_2 FLOAT DEFAULT 0.0;
DECLARE variable cl1 FLOAT DEFAULT 0.0;
DECLARE variable cl2 FLOAT DEFAULT 0.0;
DECLARE variable sl1 FLOAT DEFAULT 0.0;
DECLARE variable sl2 FLOAT DEFAULT 0.0;
DECLARE variable delta FLOAT DEFAULT 0.0;
DECLARE variable cdelta FLOAT DEFAULT 0.0;
DECLARE variable sdelta FLOAT DEFAULT 0.0;
DECLARE variable x FLOAT DEFAULT 0.0;
DECLARE variable y FLOAT DEFAULT 0.0;
DECLARE variable ad FLOAT DEFAULT 0.0;
DECLARE variable dist D_INTEGER DEFAULT 0;
DECLARE variable EARTH_RAD D_INTEGER DEFAULT 0;

BEGIN
    EARTH_RAD = 6372795;
    lat_1 = lat1 * PI() / 180.0;
    lat_2 = lat2 * PI() / 180.0;
    lng_1 = lng1 * PI() / 180.0;
    lng_2 = lng2 * PI() / 180.0;
    cl1 = COS(lat_1);
    cl2 = COS(lat_2);
    sl1 = SIN(lat_1);
    sl2 = SIN(lat_2);

    delta = lng_2 - lng_1;
    cdelta = COS(delta);
    sdelta = SIN(delta);

    y = SQRT(POWER(cl2 * sdelta, 2) + POWER(cl1 * sl2 - sl1 * cl2 * cdelta, 2));
    x = sl1 * sl2 + cl1 * cl2 * cdelta;

    ad = ATAN2(y, x);
    dist = ad * EARTH_RAD;
    RETURN dist;
END;


CREATE OR ALTER FUNCTION GET_JSON_VALUE (
    JSON D_PATH,
    PARAM D_VARCHAR50)
RETURNS D_VARCHAR255 DETERMINISTIC
AS
declare variable res D_Varchar255;
declare variable b   D_Integer;
declare variable e   D_Integer;
begin
  res = '"' || Param || '":';
  b = position(res, Json);
  if (b > 0) then begin
    b = b + char_length(res);
    e = position(',', Json, b);
    if (e = 0) then begin
      e = position('}', Json, b);
      if (e = 0) then begin
        e = position(']', Json, b);
        if (e = 0) then begin
          e = char_length(Json);
        end
      end
    end
    res = substring(Json from b for e - b);
  end
  else
    res = '';
  return res;
end;


CREATE OR ALTER FUNCTION GET_SRV_TARIF_FOR_CUSTOMER (
    CUSTOMER_ID UID,
    SERVICE_ID D_UID_NULL,
    FOR_DAY D_DATE = null,
    JUR D_INTEGER = null)
RETURNS D_N15_4
AS
declare variable Bus     D_Integer;
declare variable K       D_N15_4;
declare variable All_Sum D_N15_4;
begin
  For_Day = coalesce(For_Day, current_date);

  ALL_SUM = null;
  K = null;
  -- если есть персональный тариф, то дальш не смотрим
  select first 1
      p.Tarif_Sum
    from Personal_Tarif p
    where p.Customer_Id = :Customer_Id
          and p.Service_Id = :SERVICE_ID
          and :For_Day between p.Date_From and p.Date_To
  into :ALL_SUM;

  if (ALL_SUM is null) then begin
    select
        s.Business_Type
      from services s
      where s.service_id = :SERVICE_ID
    into :BUS;
    -- проверим есть ли скидка на услугу или тип услуги
    select first 1
        k.Factor_Value
      from Discount_Factor k
      where k.Customer_Id = :Customer_Id
            and :For_Day between k.Date_From and k.Date_To
            and ((k.Serv_Id = :SERVICE_ID)
              or (k.Serv_Id = -1))
            and ((k.Srv_Type = :BUS)
              or (k.Srv_Type = -1))
    into :K;
    K = coalesce(K, 1);
    if (k <> 0) then begin
      if (JUR is null) then begin
        select
            c.Juridical
          from customer c
          where c.Customer_Id = :Customer_Id
        into :JUR;
      end
      jur = coalesce(JUR, 0);
      -- тариф на услугу
      select
          iif(:JUR = 0, t.Tarif_Sum, t.Tarif_Sum_Jur)
        from Tarif t
        where t.Service_Id = :SERVICE_ID
              and :For_Day between t.Date_From and t.Date_To
      into :ALL_SUM;

      ALL_SUM = k * ALL_SUM;
    end
    else
      ALL_SUM = 0;
  end

  return ALL_SUM;
end;


CREATE OR ALTER FUNCTION INET_ATON (
    AIP D_IP)
RETURNS D_N10 DETERMINISTIC
AS
declare variable Ip1    D_Integer;
declare variable Ip2    D_Integer;
declare variable Ip3    D_Integer;
declare variable Ip4    D_Integer;
declare variable Vint   D_Integer;
declare variable Vpart  D_Ip;
declare variable Int_Ip D_N10;
begin
  INT_IP = null;
  if (not AIP is null) then begin
    AIP = trim(AIP);
    Ip1 = char_length(AIP);
    ip2 = char_length(replace(AIP, '.', ''));
    if ((ip1 - ip2) = 3) then begin
      ip2 = char_length(ONLY_DIGITS(:AIP));
      if ((ip1 - ip2) = 3) then begin -- проверим все нет ли букв в адресе
        vPart = aIP;
        vInt = position('.' in vPart);
        ip4 = cast(left(vPart, vInt - 1) as integer);

        vPart = substring(vPart from vInt + 1);
        vInt = position('.' in vPart);
        ip3 = cast(left(vPart, vInt - 1) as integer);

        vPart = substring(vPart from vInt + 1);
        vInt = position('.' in vPart);
        ip2 = cast(left(vPart, vInt - 1) as integer);

        vPart = substring(vPart from vInt + 1);
        ip1 = cast(vPart as integer);

        int_ip = ip4 * 16777216 + ip3 * 65536 + ip2 * 256 + ip1;
      end
    end
  end
  return :INT_IP;
end;


CREATE OR ALTER FUNCTION INET_NTOA (
    INT_IP D_N10)
RETURNS D_IP DETERMINISTIC
AS
declare variable Ip1 D_Integer;
declare variable Ip2 D_Integer;
declare variable Ip3 D_Integer;
declare variable Ip4 D_Integer;
begin
  ip4 = bin_and(Int_Ip, 4278190080) / 16777216;
  ip3 = bin_and(Int_Ip, 16711680) / 65536;
  ip2 = bin_and(Int_Ip, 65280) / 256;
  ip1 = bin_and(Int_Ip, 255);

  return ip4 || '.' || ip3 || '.' || ip2 || '.' || ip1;
end;


CREATE OR ALTER FUNCTION MONTH_FIRST_DAY (
    MON_DAY DATE)
RETURNS DATE DETERMINISTIC
AS
begin
  return mon_day - extract(day from mon_day) + 1;
end;


CREATE OR ALTER FUNCTION MONTH_LAST_DAY (
    MON_DAY D_DATE)
RETURNS D_DATE DETERMINISTIC
AS
begin
  return dateadd(-1 day to(dateadd(1 month to (MON_DAY - extract(day from MON_DAY) + 1))));
end;


CREATE OR ALTER FUNCTION ONLY_DIGITS (
    A_VALUE D_VARCHAR255)
RETURNS D_VARCHAR255 DETERMINISTIC
AS
declare variable i d_integer;
declare variable j d_integer;
declare variable d d_char1;
declare variable DIGITS D_VARCHAR255;
begin

  j = CHAR_LENGTH(a_value);
  i = 1;
  DIGITS = '';
  while (i <= j) do begin
    d = substring(a_value FROM i FOR 1);
    IF (d BETWEEN '0' AND '9')
    then DIGITS = DIGITS ||d;
    i = i + 1;
  end

  return DIGITS;
end;


CREATE ROLE ROLE_A4USER;
COMMENT ON DOMAIN D_UID_NULL IS
'Для полей ссылок которые могут содержать Null';

COMMENT ON DOMAIN UID IS
'FOR PRIMARY KEYS';

COMMENT ON TABLE ALL_USED_IP IS
'Список зарезервированных IP адресов, которые не выдаються абонентам и оборудованию.';

COMMENT ON TABLE APPLIANCE IS
'Список устройств/приборов в сети. Как операторские, так и абонентские';

COMMENT ON TABLE AREA IS
'Участки';

COMMENT ON TABLE ATTRIBUTE IS
'Универсальная таблица хранения атрибутов на объекты';

COMMENT ON TABLE BCISSUE IS
'Проблемы/Сбои вещания каналов';

COMMENT ON TABLE BCI_CHANNELS IS
'на каких каналах проблема';

COMMENT ON TABLE BILLING IS
'Параметры для интернет биллинга';

COMMENT ON TABLE BLB_GZIP IS
'Хранение сжатых бинарных файлов';

COMMENT ON TABLE BLOB_TBL IS
'Хранения бинарных данных';

COMMENT ON TABLE BONUS_RATE IS
'Таблица тарифов на бонусы';

COMMENT ON TABLE CARDS_PREPAY IS
'Карты оплаты';

COMMENT ON TABLE CARDS_SERIALS IS
'Серии кар оплат';

COMMENT ON TABLE CHANGELOG IS
'Журнал изменений';

COMMENT ON TABLE CHANNELS IS
'ТВ каналы';

COMMENT ON TABLE CHANNELS_IN_SERVCE IS
'Каналы в услуге';

COMMENT ON TABLE CHANNEL_SRC IS
'Источники сигнала каналов';

COMMENT ON TABLE CHANNEL_SRC_PARAM IS
'Параметры канала в источнике';

COMMENT ON TABLE CLIENT_FILES IS
'Файлы для обновления софта на клиенте';

COMMENT ON TABLE COMPANY IS
'Информация о фирме';

COMMENT ON TABLE CONNECT_LOG IS
'Журнал подключения к базе данных';

COMMENT ON TABLE CUSTLETTER IS
'Письма абонентам';

COMMENT ON TABLE CUSTOMER IS
'Таблица абонентов';

COMMENT ON TABLE CUSTOMER_ATTRIBUTES IS
'Атрибуты абонентов';

COMMENT ON TABLE CUSTOMER_BONUSES IS
'Таблица бонусов';

COMMENT ON TABLE CUSTOMER_CHANNELS IS
'Персональные каналы у абонентов';

COMMENT ON TABLE CUSTOMER_CONTACTS IS
'Таблица контактов абонента (телефон, емаил и т.д.)';

COMMENT ON TABLE CUSTOMER_DECODERS IS
'Связка абонент-декодер';

COMMENT ON TABLE CUSTOMER_EQUIPMENT IS
'Связка абонент-оборудование';

COMMENT ON TABLE CUSTOMER_FILES IS
'Документы абонента (сканы справок паспортов)';

COMMENT ON TABLE DAYS_TARIF IS
'Временная таблица для расчетов';

COMMENT ON TABLE DECODER_PACKETS IS
'Таблица пакетов для декодера (цифрового оборудования)';

COMMENT ON TABLE DEVICES IS
'будет удалена. Таблица для карты.';

COMMENT ON TABLE DEVPORTS IS
'будет удалена. Таблица для карты.';

COMMENT ON TABLE DEVPROFILES IS
'будет удалена. Таблица для карты.';

COMMENT ON TABLE DISCOUNT_FACTOR IS
'Таблица скидок для абонентов';

COMMENT ON TABLE DISTRIBUTOR IS
'ДИСТРИБЬЮТОР каналов';

COMMENT ON TABLE DISTRIB_CARDS IS
'Карты дистрибьютера';

COMMENT ON TABLE DISTRIB_CONTRACT_CH IS
'Каналы по договору';

COMMENT ON TABLE DVB_NETWORK IS
'Сети DVB';

COMMENT ON TABLE DVB_STREAMS IS
'Потоки (транспондеры) DVB';

COMMENT ON TABLE DVB_STREAM_CHANNELS IS
'Каналы в потоке (транспондере)';

COMMENT ON TABLE EPG IS
'программа передач';

COMMENT ON TABLE EPG_AD IS
'Таблица рекламных объявлений в EPG';

COMMENT ON TABLE EPG_AD_CHANNELS IS
'На каких каналах пускать объявления';

COMMENT ON TABLE EPG_GENRE IS
'Жанр программ передач';

COMMENT ON TABLE EPG_LOCAL IS
'EPG для локальных врезок, создает сам оператор';

COMMENT ON TABLE EPG_MAPPING IS
'Соответствие ID канала в a4on.tv и ID канала в загружаемом файле';

COMMENT ON TABLE EPG_MAPPING_GENRE IS
'Соответстиве жанра источника с жанром стандарта DVB';

COMMENT ON TABLE EPG_SOURCES IS
'Спсиок источников программ передач';

COMMENT ON TABLE EQUIPMENT IS
'Таблица сетевого оборудования';

COMMENT ON TABLE EQUIPMENT_ATTRIBUTES IS
'Атрибуты аоборудования';

COMMENT ON TABLE EQUIPMENT_CMD_GRP IS
'Связка КОММАНДА - ТИП ОБОРУДОВАНИЯ';

COMMENT ON TABLE EQUIPMENT_COVERAGE IS
'Зона обслуживания оборудования';

COMMENT ON TABLE EQUIPMENT_DVB IS
'Цифровое оборудование. карточки стб модули';

COMMENT ON TABLE EQUIPMENT_HISTORY IS
'Таблица истории смены статса оборудования';

COMMENT ON TABLE EQUIPMENT_LOG IS
'Журнал оборудования';

COMMENT ON TABLE EVENT_DETAIL IS
'Суммарная информация по событиям абонента (тарфика, вход, или еще что)';

COMMENT ON TABLE EXPORTTYPES IS
'Описание форматов экспорта данных';

COMMENT ON TABLE FREQPLAN IS
'Частоты и номера кабельных и телевизионных каналов';

COMMENT ON TABLE GPS_LOG IS
'Лог координат монтажников';

COMMENT ON TABLE HEADEND IS
'Головные станции';

COMMENT ON TABLE HEADEND_CHANNELS IS
'каналы головных станций';

COMMENT ON TABLE HOUSE IS
'Дома';

COMMENT ON TABLE HOUSEFLATS IS
'Карта дома квартира этаж подъезд';

COMMENT ON TABLE HOUSEFLOOR IS
'Этажи дома';

COMMENT ON TABLE HOUSEPORCH IS
'Подъезды дома';

COMMENT ON TABLE HOUSES_ATTRIBUTES IS
'Атрибуты домов';

COMMENT ON TABLE HOUSEWORKS IS
'Работы по дому';

COMMENT ON TABLE HOUSE_CIRCUIT IS
'Схемы для дома';

COMMENT ON TABLE INVENTORY IS
'таблица установленного оборудования/материалов в сети';

COMMENT ON TABLE IPTV_GROUP IS
'Групп для IPTV';

COMMENT ON TABLE IPTV_GROUP_ATTRIBUTES IS
'Атрибуты IPTV групп';

COMMENT ON TABLE IPTV_GROUP_CHANNELS IS
'Каналы в IPTV группе';

COMMENT ON TABLE JOURNAL IS
'Журнал (сообщения ошибки)';

COMMENT ON TABLE LETTERTYPE IS
'Вид печатных документов';

COMMENT ON TABLE MAP_LOG IS
'Журнал работы с картой';

COMMENT ON TABLE MATERIALS IS
'Таблица текущего кол-ва материала';

COMMENT ON TABLE MATERIALS_GROUP IS
'Группы материалов';

COMMENT ON TABLE MATERIALS_IN_DOC IS
'Материалы в документах прихода/расхода';

COMMENT ON TABLE MATERIALS_IN_DOC_UNIT IS
'Материалы в документах прихода/расхода поштучно';

COMMENT ON TABLE MATERIALS_REMAIN IS
'Остаток материалов на складах';

COMMENT ON TABLE MATERIAL_DOCS IS
'Документы';

COMMENT ON TABLE MATERIAL_UNIT IS
'Единичный учет материала/оборудования';

COMMENT ON TABLE MESSAGES IS
'Таблица рассылки сообщений (sms email digitaltv)';

COMMENT ON TABLE MESSAGE_TPL IS
'Шаблоны сообщений';

COMMENT ON TABLE MODULES IS
'Таблица модулей системы (меню Модули)';

COMMENT ON TABLE MONTHLY_FEE IS
'Месячные начисления';

COMMENT ON TABLE MONTHLY_FREEZE IS
'Заморозка начислений';

COMMENT ON TABLE MONTH_NAME IS
'Наименование месяцев';

COMMENT ON TABLE NODES IS
'Узлы/ящики где установлено оборудование';

COMMENT ON TABLE NODES_ATTRIBUTES IS
'Атрибуты услуг';

COMMENT ON TABLE NODE_FILES IS
'Документы узла';

COMMENT ON TABLE NODE_FLATS IS
'Квартиры узла';

COMMENT ON TABLE NODE_LAYOUT IS
'Схема расположения оборудования на узле';

COMMENT ON TABLE NPS IS
'Индекс потребительской лояльности';

COMMENT ON TABLE OBJECTS IS
'Тблица справочников';

COMMENT ON TABLE OBJECTS_COVERAGE IS
'Зона обслуживания для объектов (модемы зоны и прочее)';

COMMENT ON TABLE OBJECTS_TYPE IS
'Вид справочника';

COMMENT ON TABLE OPERATION_LOG IS
'Лог операций';

COMMENT ON TABLE ORDERS_TP IS
'сторонние заказы (third-party orders)';

COMMENT ON TABLE ORGANIZATION IS
'Обслуживающие организации';

COMMENT ON TABLE OTHER_FEE IS
'Прочие начисления абоненту';

COMMENT ON TABLE PAYMENT IS
'Таблица принятых платежей';

COMMENT ON TABLE PAYMENT_DELETED IS
'Удаленные платежи';

COMMENT ON TABLE PAYMENT_HOLD IS
'Платежи ожидающие обработку. например рассылка чеков с онлайн оплат';

COMMENT ON TABLE PAYSOURCE IS
'Источник платежа';

COMMENT ON TABLE PAY_DOC IS
'Список платежных документов (мемориалный оредер) документ с кодом (-1), реестр обещаных платежей';

COMMENT ON TABLE PAY_ERRORS IS
'Ошибки загрузчика платежей';

COMMENT ON TABLE PERSONAL_TARIF IS
'Таблица персональных тарифов';

COMMENT ON TABLE PERS_TARIF_TMP IS
'Временная таблица для расчетов';

COMMENT ON TABLE PORT IS
'Таблица портов оборудования сети';

COMMENT ON TABLE PREPAY_DETAIL IS
'История обещаных платежей';

COMMENT ON TABLE PROFILES IS
'Проифили загрузчика платежей и начислений';

COMMENT ON TABLE QRATING IS
'Таблица оценок
NPS - лояльность абонентов
BID - оценка выполнения заявок';

COMMENT ON TABLE QUEUE_SWITCH_SRV IS
'Очередь запланированного переключения услуг';

COMMENT ON TABLE RATES IS
'Курсы валют';

COMMENT ON TABLE RECOURSE IS
'Обращения абонентов (звонки)';

COMMENT ON TABLE RECOURSE_TEMPLATES IS
'Шаблонs обращений';

COMMENT ON TABLE REMINDER IS
'Напоминалка для пользователя';

COMMENT ON TABLE REPORTS IS
'Отчеты';

COMMENT ON TABLE REQUEST IS
'Заявки';

COMMENT ON TABLE REQUEST_EXECUTORS IS
'Исполнители заявок';

COMMENT ON TABLE REQUEST_MATERIALS IS
'Материалы для заявки';

COMMENT ON TABLE REQUEST_MATERIALS_RETURN IS
'возврат материалов с заявки';

COMMENT ON TABLE REQUEST_MSG IS
'Переписка по заявкам';

COMMENT ON TABLE REQUEST_PHOTOS IS
'Фотографии заявки';

COMMENT ON TABLE REQUEST_RESULTS IS
'Результат закрытия заявки';

COMMENT ON TABLE REQUEST_TEMPLATES IS
'Шаблоны заявок';

COMMENT ON TABLE REQUEST_TYPES IS
'Типы заявок';

COMMENT ON TABLE REQUEST_WORKS IS
'Работы по заявке';

COMMENT ON TABLE SERVICES IS
'Услуги';

COMMENT ON TABLE SERVICES_ATTRIBUTES IS
'Атрибуты услуг';

COMMENT ON TABLE SERVICES_CMPLX IS
'Таблица для комплексных услуг. Услуга которая состит из нескольких подразделов';

COMMENT ON TABLE SERVICES_LINKS IS
'Таблица связей услуг. включение отключение абонентский услуг';

COMMENT ON TABLE SERVICES_TYPE IS
'Вид услуг';

COMMENT ON TABLE SETTINGS IS
'Настройки';

COMMENT ON TABLE SINGLE_SERV IS
'Разовые услуги абоненту';

COMMENT ON TABLE STAT_IP IS
'Таблица статистики трафика по IP';

COMMENT ON TABLE STREET IS
'Справочник улиц';

COMMENT ON TABLE STREET_TYPE IS
'Сокращенное название улиц';

COMMENT ON TABLE SUBAREA IS
'Справочник участков';

COMMENT ON TABLE SUBDIVISIONS IS
'Участки (подразделения предприятия)';

COMMENT ON TABLE SUBSCR_HIST IS
'История подключений отключений';

COMMENT ON TABLE SUBSCR_SERV IS
'Подписанные услуги абоненту';

COMMENT ON TABLE SYS$GROUP IS
'Группы пользователей';

COMMENT ON TABLE SYS$GROUP_RIGHTS IS
'Права для груп пользователей';

COMMENT ON TABLE SYS$RIGHTS IS
'Права доступа сиситемы';

COMMENT ON TABLE SYS$USER IS
'Пользователи системы';

COMMENT ON TABLE SYS$USER_AREAS IS
'Связка пользователь-район';

COMMENT ON TABLE SYS$USER_GROUPS IS
'Связка пользователь-группа';

COMMENT ON TABLE SYS$USER_WH IS
'Разрешенные склады для пользователя';

COMMENT ON TABLE TARIF IS
'Тарифы на услуги и на НДС Object_TYPE = 13';

COMMENT ON TABLE TASKLIST IS
'Таблица задач сотрудников';

COMMENT ON TABLE TASKMSG IS
'Переписка по задачам';

COMMENT ON TABLE TASKUSER IS
'Таблица исполнителей задач';

COMMENT ON TABLE TMP_COL IS
'Временная таблица для внутренних целей';

COMMENT ON TABLE TQUEUE IS
'События цифрового ТВ';

COMMENT ON TABLE TV_LAN IS
'Настройки сети для абонента';

COMMENT ON TABLE TV_LAN_PACKETS IS
'Пакеты для сетевого оборудования';

COMMENT ON TABLE VLANS IS
'Подсети СПД';

COMMENT ON TABLE WIRE IS
'Кабельная инфраструктура';

COMMENT ON TABLE WORKAREA IS
'Участки обслуживания';

COMMENT ON TABLE WORKAREALIMIT IS
'Ограничение кол-во заявок на учатске по типу заявки';

COMMENT ON TABLE WORKER IS
'Работники организации (монтажники)';

COMMENT ON TABLE WORKGROUPS IS
'Звенья обслуживания';

COMMENT ON TABLE WORKS IS
'Работы для заявок';

COMMENT ON VIEW RAYON IS
'УДАЛИТЬ. непонтяно что это и кто создал. позже удалю';

COMMENT ON VIEW V_ALL_IP IS
'Все IP адреса системы';

COMMENT ON VIEW V_ALL_MAC IS
'Все MAC адреса системы';

COMMENT ON PROCEDURE ADD_FLAT_TO_HOUSE IS
'Добавим новую квартиру в дом';

COMMENT ON PROCEDURE ADD_OR_MOVE_PAYMENT IS
'Добавляет или перемещает в платежный документ платеж абонента';

COMMENT ON PROCEDURE ADD_PAYMENT IS
'Добавление платежа абоненту.
при этом создается новый платежный документ. если его не было ранее';

COMMENT ON PROCEDURE ADD_PAYMENT_BY_ACCOUNT IS
'Добавление платежа абоненту.
при этом создается новый платежный документ. если его не было ранее';

COMMENT ON PROCEDURE ADD_PAYMENT_BY_ACCOUNT_FINE IS
'Добавление платежа абоненту.
при этом создается новый платежный документ. если его не было ранее';

COMMENT ON PROCEDURE ADD_PAYMENT_BY_ACC_SUR IS
'Добавление платежа абоненту. Проверка по Фамилии и Лицевому
при этом создается новый платежный документ. если его не было ранее';

COMMENT ON PROCEDURE ADD_PAYMENT_EXT IS
'Добавление платежа абоненту.
Примечание (если используете в своих проектах, учтите то что процедура будет менятся согласно таблице PAYMENTS)
возвращает
-1 не найден абонент
-2 не указана сумма платежа
-3 не указан плат документ
>=0 ID платежа';

COMMENT ON PROCEDURE ADD_PAYMENT_FINE IS
'Добавление платежа абоненту.
при этом создается новый платежный документ. если его не было ранее';

COMMENT ON PROCEDURE ADD_PAYMENT_FROM_EXT_SYSTEMS IS
'Добавить платеж с внешних систем, такие как терминалы и прочие';

COMMENT ON PROCEDURE ADD_PAYMENT_SRC_ACCOUNT IS
'Добавляет платеж абоненту.
платеж заносится в платежный документ с источником src и датой платежа';

COMMENT ON PROCEDURE ADD_PAYMENT_SRC_CUSTID IS
'Добавление платежа абоненту.
Поиск абонента по его ID
добавляет в плат документ за дату платежа с кодом источника указанным при выполнении
возвращает
Если источник с кодом не найдем, создадим его
>=0 ID платежа';

COMMENT ON PROCEDURE ADD_PAYMENT_SRC_DOG_FIO IS
'Добавление платежа абоненту. Поиск по номеру договора и фамилии, если фио не указана не сравниваем
добавляет в плат документ за дату платежа с кодом источника указанным при выполнении
возвращает
-4 не найден абонент
-5 не совпадают фамилии
-6 не указан код источника
>=0 ID платежа';

COMMENT ON PROCEDURE ADD_SINGLE_SERVICE IS
'    P_CUSTOMER_ID  - абонент
P_SERVICE_ID   - услуга
P_UNITS        - кол-во
P_DATE         - дата
P_NOTICE       - примечание
P_HISTORY      - если эта услуга включения/отключения то тут храниться номер записи в таблице историй подключений SUBSCR_HIST';

COMMENT ON PROCEDURE ADD_SINGLE_SERVICE_VAT IS
'    P_CUSTOMER_ID  - абонент
P_SERVICE_ID   - услуга
P_UNITS        - кол-во
P_DATE         - дата
P_NOTICE       - примечание
P_HISTORY      - если эта услуга включения/отключения то тут храниться номер записи в таблице историй подключений SUBSCR_HIST';

COMMENT ON PROCEDURE ADD_SINGLE_SERVICE_WO_CALC IS
'Добавление разовой услуги без полного пересчета.';

COMMENT ON PROCEDURE ADD_STAT_IP IS
'Добавить трафик по IP   с учетом класса трафика';

COMMENT ON PROCEDURE ADD_SUBSCR_SERVICE IS
'Добавление периодической услуги абоненту';

COMMENT ON PROCEDURE ADD_SUBSCR_SERVICE_VAT IS
'Добавление периодической услуги абоненту с группой НДС';

COMMENT ON PROCEDURE API_GET_CUSTOMER_BALANCE IS
'получение детализации баланса абонента';

COMMENT ON PROCEDURE API_GET_CUSTOMER_SERVICES IS
'Процедура вывода доступных абоненту услуг для работы с API (ЛК)';

COMMENT ON PROCEDURE API_GET_CUSTOMER_SERVICES_NEW IS
'эту процедуру нужно удалить
Процедура вывода доступных абоненту услуг для работы с API (ЛК)';

COMMENT ON PROCEDURE API_GET_NEW_ACCOUNT IS
'Создание нового номера лицевого';

COMMENT ON PROCEDURE API_GET_SERVICES IS
'Процедура выборки доступных абоненту услуг

P_CUSTOMER_ID - код абонента
P_TYPE        - код услуг (абонентской -0 / разовой - 1)';

COMMENT ON PROCEDURE API_REMAIN_DAYS IS
'Процедура расчета на сколько примерно дней хватит текущего баланса';

COMMENT ON PROCEDURE API_REQUEST_CLOSE IS
'Закрытие заявки';

COMMENT ON PROCEDURE API_REQUEST_JOIN IS
'Добавить пользователя к заявке';

COMMENT ON PROCEDURE API_REQUEST_REFUSE IS
'отказаться от заявки
возвращаем
0 - не смогли отказаться
1 - все хорошо. отказались
2 - чужая';

COMMENT ON PROCEDURE API_REQUEST_TAKE IS
'Взять заявку
возвращаем
0 - не смогли взять
1 - все хорошо. взяли
2 - чужая';

COMMENT ON PROCEDURE API_SET_CUSTOMER_SERVICE IS
'Включить или выключить абоненту услугу через ЛК
услуги включения берутся из настроек service_link';

COMMENT ON PROCEDURE API_SET_PREPAY IS
'Добавим обещанный с проверкой суммы и вернем удачно или нет';

COMMENT ON PROCEDURE API_SET_SWITCH_QUEUE IS
'ставим в очередь переключения услуг';

COMMENT ON PROCEDURE ATRIBUTES_LINE IS
'Вывод всех атрибутов в строку';

COMMENT ON PROCEDURE ATTRIBUTES_IUD IS
'Процедура добавления/редактирования/удаления атрибутов абонента';

COMMENT ON PROCEDURE ATTRIBUTE_CHECK_UNIQ IS
'проверим на уникальность значение атрибута, если он есть у кого-то вернем его';

COMMENT ON PROCEDURE AUTO_OFF_SERVICE IS
'Авто блокировка услуги';

COMMENT ON PROCEDURE AUTO_ON_SERVICE IS
'Авто разблокировка услуги';

COMMENT ON PROCEDURE BCISSUECH_ID IS
'Добавляет.удаляет каналы с проблемы вещания';

COMMENT ON PROCEDURE BONUS_ADD_AFTER_PAYMENT IS
'Добавить бонус после оплаты суммы';

COMMENT ON PROCEDURE CALCULATE_SRV_TYPE_0 IS
'Расчт услуг с ежемесячными начислениям пропорционально дням';

COMMENT ON PROCEDURE CALC_DAY_INC_SRV_CUSTOMER IS
'расчет ежедневных начислений, если выключена в день включения - считаем';

COMMENT ON PROCEDURE CALC_DAY_SRV_CUSTOMER IS
'расчет ежедневных начислений';

COMMENT ON PROCEDURE CALC_DAY_TARIF IS
'Процедура заполнения таблицы тарифов по дням

P_SERV_ID  - код услуги
P_MONTH    - месяц';

COMMENT ON PROCEDURE CALC_DISCOUNT IS
'Расчет скидки за предоплату';

COMMENT ON PROCEDURE CALC_DISCOUNT_AFTER_PAY IS
'Расчет скидки на платеж';

COMMENT ON PROCEDURE CALC_KOEF_TARIF IS
'Процедура заполнения таблицы тарифа с учетом коэффициента абонента по дням';

COMMENT ON PROCEDURE CALC_MONTH_DAY_SRV_CUSTOMER IS
'начисления раз в месяц пропорционально дням';

COMMENT ON PROCEDURE CALC_MONTH_FIX_SRV_CUSTOMER IS
'если подключен хоть день, то снимаем полную абонплату';

COMMENT ON PROCEDURE CALC_MONTH_SRV_CUSTOMER IS
'начисления за полный/0 месяц';

COMMENT ON PROCEDURE CALC_PERS_TARIF IS
'Процедура заполнения таблицы персонального тарифа абонента по дням';

COMMENT ON PROCEDURE CANCEL_CONTRACT IS
'Процедура разрыва договора с абонентом';

COMMENT ON PROCEDURE CANCEL_LAST_SUBSCRIBE_ACTION IS
'Отмена последнего действия над подключеной услугой';

COMMENT ON PROCEDURE CAN_USER_VIEW_ADDRESS IS
'Проверка, видит ли пользователь адрес согласно принадлежнасти к участку';

COMMENT ON PROCEDURE CARDS_PREPAY_ACTIVATE IS
'Активация карты оплаты';

COMMENT ON PROCEDURE CARDS_PREPAY_GENERATE IS
'Генерация карт оплат';

COMMENT ON PROCEDURE CHANGE_AUTOBLOCK_OFF IS
'Замена услуги автоблокировка на другую услугу отключения';

COMMENT ON PROCEDURE CHANGE_CH_TO_CH IS
'Замена параметров одного канала на другой в указанных сетях';

COMMENT ON PROCEDURE CHANGE_TO_POSITIVE IS
'Выполняем когда у абонента сменился баланс на положительный';

COMMENT ON PROCEDURE CHANNELS_DEL IS
'Процедура удаления каналов. Не удаляет если канал где-то задйствован';

COMMENT ON PROCEDURE CHANNELS_FOR_ALL_CUSTOMER IS
'Выборка всех каналов всех декодеров на определенную дату';

COMMENT ON PROCEDURE CHECKCONTRACT IS
'Проверка на наличие договра в системе.
если есть то возвращает - 0, нет - 1';

COMMENT ON PROCEDURE CHECK_FOR_UNBLOCK IS
'Разблокировка автомтически заблокированных услуг
Проверим услуги абонента и если есть что включать включим';

COMMENT ON PROCEDURE CHECK_IN_BLOCK IS
'Прверяем. была ли услуга у абонента в блокировке на дату';

COMMENT ON PROCEDURE CHECK_IN_OFF IS
'Проверим. услуга отключена на дату? (не в блокировке, а отключена)';

COMMENT ON PROCEDURE CHECK_SRV_ACTIVE IS
'Процедура проверки активна ли услуга у абонента на дату.
если услуга не указана смотрим любую услугу';

COMMENT ON PROCEDURE CLOSE_DAY_PROC IS
'Процедура закрытия дня';

COMMENT ON PROCEDURE CLOSE_MATERIAL_DOC IS
'Процедура закрытия документа движения.';

COMMENT ON PROCEDURE CLOSE_MONTH_PROC IS
'Процедура расчета платы абонентов за месяц
с учетом предоплаты / постплаты ....

P_MONTH    - месяц расчета';

COMMENT ON PROCEDURE CLOSE_PERIOD_PROC IS
'Процедура расчета определенного периода

P_START_MONTH  - с первого числа месяца
P_END_MONTH    - по месяц (включительно)';

COMMENT ON PROCEDURE CURRENCY_TO_STR IS
'перевод чисел в строку, т.е. 100 - сто';

COMMENT ON PROCEDURE CUSTOMERS_SERVICES_STATE IS
'Обновление статуса для всех абонентов';

COMMENT ON PROCEDURE CUSTOMER_BALANCE IS
'Процедура выборки полного баланса абонента';

COMMENT ON PROCEDURE CUSTOMER_CONTACTS_IU IS
'Добавление или обновление контактов абонента';

COMMENT ON PROCEDURE CUSTOMER_SERVICES_STATE IS
'Обновление поля статус абонента';

COMMENT ON PROCEDURE DAY_TARIF_FOR_SRV IS
'Процедура заполнения таблицы тарифов по дням

P_SERV_ID  - код услуги
P_MONTH    - месяц';

COMMENT ON PROCEDURE DECL_OF_NUM IS
'Склонение размерности единиц измерения при числительных';

COMMENT ON PROCEDURE DELETE_CUSTOMER IS
'Удаление пользователя';

COMMENT ON PROCEDURE DELETE_CUSTOMER_DECODER IS
'Процедура удаления декодера у абонента и установка статуса декодеру';

COMMENT ON PROCEDURE DELETE_NODE IS
'Удаление узла';

COMMENT ON PROCEDURE DUBLICATE_REQUEST IS
'Дубликат заявки для пользователя';

COMMENT ON PROCEDURE EPG_ADD IS
'Добавление программы передач, с автоматической корректеровкой расписания';

COMMENT ON PROCEDURE EPG_ADD_BY_SC IS
'Добавим EPG по ID источника и коду канала из источника. так как одному коду может соответствовать несколько каналов';

COMMENT ON PROCEDURE EXPLODE IS
'Аналог функции EXPLODE PHP (разбивает строку 1,2,3 на записи три записи 1 2 3)';

COMMENT ON PROCEDURE EXPLODE_NO_EMPTY IS
'Аналог функции EXPLODE PHP но не возвращает пустые строки';

COMMENT ON PROCEDURE EXTRACT_NUMBER IS
'Извлекает из строки цифры до первого не цифрового символа.
например 17/2 - 17';

COMMENT ON PROCEDURE FIX_PORT_CONNECT IS
'исправляем иноформацию порта по подключению к абоненту/устройству';

COMMENT ON PROCEDURE FORMAT_DATE IS
'Вывод даты согласно формату:
D — день без лидирующего пробела
DD — день с лидирующим пробелом
DDD — день недели, краткое название
DDDD — день недели, длинное название
M — месяц без лидирующего пробела
MM — месяц с лидирующим пробелом
MMM — месяц, краткое название
MMMM — месяц, полное название
YY — год, 2 последние цифры
YYYY — год, 4 цифры.';

COMMENT ON PROCEDURE FORMAT_MAC IS
'приводим mac адрес к виду XX:XX:XX:XX:XX:XX';

COMMENT ON PROCEDURE FREELANEQUIPMENT IS
'очистить сетевые настройки абонента при откллючении';

COMMENT ON PROCEDURE FULL_RECALC_CUSTOMER IS
'Процедура полного пересчета абонента

P_CUSTOMER - код абонента';

COMMENT ON PROCEDURE GEN_PASSWORD IS
'Генератор паролей.';

COMMENT ON PROCEDURE GETSERVICES IS
'Процедура выборки доступных абоненту услуг

P_CUSTOMER_ID - код абонента
P_TYPE        - код услуг (абонентской -0 / разовой - 1)';

COMMENT ON PROCEDURE GETSERVICESTOSWITCH IS
'Устарела. будет удалена';

COMMENT ON PROCEDURE GET_ACTIVE_DAYS IS
'Получить количество активных дней абонента за период
либо для услуги, либо для типа услуг';

COMMENT ON PROCEDURE GET_ALL_REPORTS IS
'Выборка всех отчетов пользователя для построения меню';

COMMENT ON PROCEDURE GET_CONNECTED_DAYS IS
'Выдает количество подключенных дней абонента к услуге';

COMMENT ON PROCEDURE GET_CUSTOMER_CHANNELS IS
'Выборка всех каналов абонента на определенную дату';

COMMENT ON PROCEDURE GET_CUSTOMER_CURRENT_SRV IS
'Возвращает текущие услуги абонента (которые активны или в автоблокировке)';

COMMENT ON PROCEDURE GET_DAYS_TOTAL IS
'Получить количество дней когда абонент был подключен и с какой даты
и количество активных дней (дней без отключения)';

COMMENT ON PROCEDURE GET_DEBT_START_DATE IS
'Считаем с какого числа пошла задолженность у абонента';

COMMENT ON PROCEDURE GET_DEBT_START_DATE_CID IS
'Считаем с какого числа пошла задолженность у абонента';

COMMENT ON PROCEDURE GET_DISTANCE IS
'Позволяет вычислить расстояние в метрах между двумя геоточками WGS84';

COMMENT ON PROCEDURE GET_EPG IS
'Выборка EPG ult описание включает все поля';

COMMENT ON PROCEDURE GET_EPG_APART IS
'Выборка EPG раздельно по всем полям';

COMMENT ON PROCEDURE GET_FREE_INET_IP IS
'Выдает первый свободный IP для определенного тарифного плана';

COMMENT ON PROCEDURE GET_FREE_INET_IP_CUSTOMER IS
'Выборка всех IP адресов для услуг абонента';

COMMENT ON PROCEDURE GET_FREE_IP IS
'Выдает свободный IP. если задана маска ищем по ней, если не нашли. берем первый адрес по маске';

COMMENT ON PROCEDURE GET_FREE_VLAN_IP IS
'Выдает первый свободный IP для определенной подсети';

COMMENT ON PROCEDURE GET_FULLNAME_ALLREPORTS IS
'Выдает полное имя отчета включая все категории';

COMMENT ON PROCEDURE GET_FULLNAME_REPORT IS
'Выдает полное имя отчета включая все категории';

COMMENT ON PROCEDURE GET_MAT_FOR_NODE IS
'список оборудования/материалов для узла соглсно компановки, если она есть';

COMMENT ON PROCEDURE GET_MAT_FOR_REQUEST IS
'Вывод всех доступных материалов с количесвом потраченным на заявку';

COMMENT ON PROCEDURE GET_MAT_GIVE_OUT IS
'Материалы для заявки с учетом уже выданных';

COMMENT ON PROCEDURE GET_MAX_INET_IP IS
'Выдает max свободный IP для определенного тарифного плана';

COMMENT ON PROCEDURE GET_MODULES_FOR_MENU IS
'Выборка всех модулей пользователя для построения меню';

COMMENT ON PROCEDURE GET_NODE_FLAT_LVL IS
'Вывод списка квартир узла по уровням
уровни: 1 - подключен к узлу, 2 - к дочернему узлу, 3 дочернему дочернего узла...';

COMMENT ON PROCEDURE GET_PAY_DOC IS
'Возвращает ид платежного документа. если документа нет на эту дату, то создает его.';

COMMENT ON PROCEDURE GET_REPORT_ID IS
'Получить ID_REPORT по полному имени отчета (обратная GET_FULLNAME_REPORT)';

COMMENT ON PROCEDURE GET_REQUEST_BUSY_DAYS IS
'Возвращает занятые дни для принятия заявок по адресу';

COMMENT ON PROCEDURE GET_REQUEST_FREEDAY IS
'Возвращает первый свободные день для заявки';

COMMENT ON PROCEDURE GET_SERVICES_FOR_IP IS
'Возвращает услуги абонента по его IP';

COMMENT ON PROCEDURE GET_SERVICES_TO_SWITCH IS
'Получить список услуг на которые можно переключить услугу у абонента';

COMMENT ON PROCEDURE GET_STATISTICS IS
'Статистика по всем услугам за период';

COMMENT ON PROCEDURE GET_TARIF_SUM_CUSTOMER_SRV IS
'Получим тариф абонента на все услуги или выбранную в определенный день';

COMMENT ON PROCEDURE INT2IP IS
'переводит двоичное представление IP в строковое';

COMMENT ON PROCEDURE IP2INT IS
'переводит строковое представление IP  в двоичное';

COMMENT ON PROCEDURE MATERIAL_DOCS_DELETE IS
'Процедура удаления документа материалов';

COMMENT ON PROCEDURE MATERIAL_REMAIN_RECALC IS
'Процедура пересчета остатков материала на складах';

COMMENT ON PROCEDURE MAT_MOVE_DETAILS IS
'Процедура вывода детального лога перемещения материала';

COMMENT ON PROCEDURE MESSAGE_FOR_CUSTOMER IS
'Отправка сообщений абоненту';

COMMENT ON PROCEDURE MIGRATE_SERVICE_BY_ACCOUNT IS
'Добавление услуги, если услуга уже есть, то ее обновляет';

COMMENT ON PROCEDURE MIGRATE_SERVICE_BY_BILL_ACCOUNT IS
'Добавление услуги, если услуга уже есть, то ее обновляет
ищем абонента по аккаунту билинга';

COMMENT ON PROCEDURE MIGRATE_SERVICE_BY_CUSTOMER_ID IS
'Добавление услуги, если услуга уже есть, то ее обновляет';

COMMENT ON PROCEDURE OBJECTS_IUD IS
'Процедура работы с таблицей OBJECTS';

COMMENT ON PROCEDURE ONOFF_SERVICE IS
'Процедура подключения, отключения услуги';

COMMENT ON PROCEDURE ONOFF_SERVICE_BY_ID IS
'включение/отключение абоненту услуги по ее ID';

COMMENT ON PROCEDURE ONOFF_SERVICE_FOR_GROUP IS
'Процедура включения/отключения услуг. создана специально для групповых операций';

COMMENT ON PROCEDURE OPEN_MATERIAL_DOC IS
'Процедура отмены закрытия документа движения материалов.';

COMMENT ON PROCEDURE PAYMENT_ADD_FROM_EXT_SYSTEMS IS
'Добавить платеж из внешних источников с проверкой на существование этого номера';

COMMENT ON PROCEDURE PAYMENT_DEL_FROM_EXT_SYSTEMS IS
'Удаление платежей из внешних систем';

COMMENT ON PROCEDURE PAYMENT_EXT_STATE IS
'Возвращает статус платежа из внешних систем';

COMMENT ON PROCEDURE PAYMENT_SPLIT_INSERT IS
'разобьем платеж относительно  начислений
сначала вся оплата на
потом пропорционально между';

COMMENT ON PROCEDURE PREPAYEXPIRE IS
'Удаление просроченных обещанных платежей';

COMMENT ON PROCEDURE QUEUE_SWITCH IS
'Занесем информацию о смене тарифа в таблицу очереди';

COMMENT ON PROCEDURE QUEUE_SWITCH_CANCEL IS
'удаление из очереди смены тарифа';

COMMENT ON PROCEDURE QUEUE_SWITCH_HANDLE IS
'обработка очереди переключения услуг';

COMMENT ON PROCEDURE RECALCCUSTOMERDEBT IS
'обновление баланса. берем все начисления и вычитаем платежи и бонусы';

COMMENT ON PROCEDURE REQUESTGIVE IS
'Выдать  заявку звену';

COMMENT ON PROCEDURE REQUESTMOVE IS
'Перенести заявку на другой день';

COMMENT ON PROCEDURE REQUEST_ADD IS
'Процедура добавления заявки';

COMMENT ON PROCEDURE REQUEST_CLOSE_AS IS
'Закрыть заявку аналогично закрытой заявке';

COMMENT ON PROCEDURE REQUEST_CLOSE_PROCESS IS
'Добавление/удаление работ из заявки абоненту';

COMMENT ON PROCEDURE REQUEST_CLOSE_ROLLBACK IS
'Удалим начисления за заявку';

COMMENT ON PROCEDURE REQUEST_MATERIALS_IUD IS
'добавление.изменение.удаление материалов в заявке';

COMMENT ON PROCEDURE REQUEST_MATERIALS_RETURN_IUD IS
'добавление.изменение.удаление материалов в заявке';

COMMENT ON PROCEDURE REQUEST_RECREATE IS
'Пересоздать новую заявку черезХ дней согласно настроек типа заявки';

COMMENT ON PROCEDURE REQUEST_SEND_SMS IS
'Выслать sms исполнителям заявок';

COMMENT ON PROCEDURE SELECTONOFFSERVICE IS
'Процедура выборки разовых услуг включения / выключения
для абонентской услуги абонента

ACUSTOMER_ID - код абонента
ASERVICE_ID  - код услуги
AOFF         - включение (0) / выключение (1)';

COMMENT ON PROCEDURE SELECTSWITCHSERVICE IS
'Процедура выбора какой услугой переключить услугу на услугу';

COMMENT ON PROCEDURE SET_DISTRIB_REPORT IS
'Установка значений отчетов дистрибьютора за период';

COMMENT ON PROCEDURE SET_DISTRIB_REPORT_AS_PERIOD IS
'Установка значений отчетов дистрибьютора';

COMMENT ON PROCEDURE SET_FLAT_PF IS
'Установить подъезд / этаж для квартиры дома';

COMMENT ON PROCEDURE SET_PREPAY IS
'Внести обещанный платеж
если платеж <= 0, то анулируем платеж';

COMMENT ON PROCEDURE SET_SETTINGS IS
'Установка параметров системы, таблица SETTINGS';

COMMENT ON PROCEDURE SPLIT_STR_TO_ROWS IS
'Процедура которая разбивает строку на числа';

COMMENT ON PROCEDURE SWITCH_CANCEL IS
'Процедура отмены переключиния услуг';

COMMENT ON PROCEDURE SWITCH_SERVICE IS
'Процедура переключиния услуги на услугу. Не переключает если стоит автоблокировка и не хватает денег до смены';

COMMENT ON PROCEDURE UPDATECUSTOMERDEBT4PAY IS
'Обновим баланс абонента';

COMMENT ON PROCEDURE UPDATE_SERVICES_TREE IS
'Процедура обновляет дату последних изменений у зависящих от услуги сервисах';

COMMENT ON PROCEDURE YEARWEEK IS
'Процедура вычисления номера недели года';

COMMENT ON FUNCTION GET_JSON_VALUE IS
'Извлечь значение парматра из json строки';

COMMENT ON FUNCTION INET_ATON IS
'переводит строковое представление IPv4 в двоичное';

COMMENT ON FUNCTION INET_NTOA IS
'переводит двоичное представление IPv4 в строковое';

COMMENT ON FUNCTION MONTH_FIRST_DAY IS
'первое число месяца';

COMMENT ON FUNCTION MONTH_LAST_DAY IS
'Последнее число месяц';

COMMENT ON FUNCTION ONLY_DIGITS IS
'Возвращает только цифры из переданной строки, если цифр нет возвращает пустую строку';

COMMENT ON TRIGGER CUSTOMER_BU1 IS
'Триггер срабатывает при изменении баланса';

COMMENT ON TRIGGER TR_ON_CONNECT IS
'Выполняем при входе в систему пользователя';

COMMENT ON COLUMN ALL_USED_IP.IP IS
'IP адрес';

COMMENT ON COLUMN ALL_USED_IP.NOTICE IS
'Примечание';

COMMENT ON COLUMN APPLIANCE.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN APPLIANCE.A_TYPE IS
'Тип устройства. в справочнике Objects_type = 48';

COMMENT ON COLUMN APPLIANCE.OWN_ID IS
'ID владельца (абонента/узла)';

COMMENT ON COLUMN APPLIANCE.OWN_TYPE IS
'где установлен 0=абонента, 1=узел';

COMMENT ON COLUMN APPLIANCE.NAME IS
'Название';

COMMENT ON COLUMN APPLIANCE.NOTICE IS
'Примечание';

COMMENT ON COLUMN APPLIANCE.M_ID IS
'Ссылка на материал, если это собственность компании';

COMMENT ON COLUMN APPLIANCE.MAC IS
'MAC адрес устройства';

COMMENT ON COLUMN APPLIANCE.SN IS
'Серийный номер';

COMMENT ON COLUMN APPLIANCE.PROPERTY IS
'Собственность. 0-абонента. 1-компании. 2-рассрочка. 3-аренда.';

COMMENT ON COLUMN ATTRIBUTE.TYPE_ID IS
'Тип атрибута. соответствует типам с таблицу object_type
например:
32-Атрибуты IPTV групп, 6-Атрибуты ТВ оборудования,
4-Атрибуты абонента, 50-Атрибуты для типа, 37-Атрибуты домов,
5-Атрибуты сетевого оборудования, 39-Атрибуты узлов, 25-Атрибуты услуг';

COMMENT ON COLUMN ATTRIBUTE.OBJECT_ID IS
'Объект чей атрибут (ID абонент. ID заявка. ID заказа. ID задачи и т.д.)';

COMMENT ON COLUMN ATTRIBUTE.AID IS
'Значение из таблицы objects';

COMMENT ON COLUMN ATTRIBUTE.AVALUE IS
'Значение';

COMMENT ON COLUMN ATTRIBUTE.NOTICE IS
'Примечание';

COMMENT ON COLUMN ATTRIBUTE.ADELETED IS
'если 1, считаем, что атрибут удален';

COMMENT ON COLUMN ATTRIBUTE.OVALUE IS
'сохраним старое значение';

COMMENT ON COLUMN BCISSUE.BI_TYPE IS
'Тип сбоя';

COMMENT ON COLUMN BCISSUE.ISSUE IS
'Описание сбоя';

COMMENT ON COLUMN BCISSUE.DTV IS
'в цифре';

COMMENT ON COLUMN BCISSUE.ATV IS
'в аналоге';

COMMENT ON COLUMN BCISSUE.IPTV IS
'в iptv';

COMMENT ON COLUMN BCISSUE.OTT IS
'в ott';

COMMENT ON COLUMN BCISSUE.SOLUTION IS
'результат исправления';

COMMENT ON COLUMN BCISSUE.RESULT_TEXT IS
'Результат';

COMMENT ON COLUMN BCISSUE.RESULT_ON IS
'КОгда выполнено';

COMMENT ON COLUMN BCISSUE.ALTER_CONFIG IS
'Вносились ли исправления в конфиг ГС/системы';

COMMENT ON COLUMN BILLING.LOGIN IS
'Логин интернета';

COMMENT ON COLUMN BILLING.SECRET IS
'Пароль доступа к интернету';

COMMENT ON COLUMN BILLING.IP_INET IS
'IP интернета';

COMMENT ON COLUMN BILLING.SECRET_WEB IS
'Пароль доступа к странице статистики и настроек';

COMMENT ON COLUMN BILLING.VPN IS
'это VPN';

COMMENT ON COLUMN BLB_GZIP.BLB_ID IS
'-111 - Новая версия программы';

COMMENT ON COLUMN BLOB_TBL.BL_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN BLOB_TBL.BL_TYPE IS
'Object_type = 55. 1-абонент, 2-Заявка, 3-материальный документ ...';

COMMENT ON COLUMN BLOB_TBL.OWNER_ID IS
'ИД владельца блоба, относительно типа. ИД мат документа, ИД заявки и т.д.';

COMMENT ON COLUMN BONUS_RATE.BT_ID IS
'ID типа бонуса';

COMMENT ON COLUMN BONUS_RATE.DATE_FROM IS
'Действует с';

COMMENT ON COLUMN BONUS_RATE.DATE_TO IS
'Действует по';

COMMENT ON COLUMN BONUS_RATE.UNITS_FROM IS
'Бонус начинается с кол-ва (сумма платежа, кол-во месяцев и т.д.) больше или равно';

COMMENT ON COLUMN BONUS_RATE.UNITS_TO IS
'верхняя граница кол-ва (не включительно, т.е. должно быть меньше но не равно)';

COMMENT ON COLUMN BONUS_RATE.RATE IS
'сумма за это кол-во';

COMMENT ON COLUMN BONUS_RATE.NOTICE IS
'Примечание';

COMMENT ON COLUMN CARDS_PREPAY.EXPIRATION_DATE IS
'До какой даты действует';

COMMENT ON COLUMN CARDS_PREPAY.CARD_STATE IS
'0 - не активирована 1 - активирована -1 - аннулирована';

COMMENT ON COLUMN CARDS_SERIALS.CS_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CARDS_SERIALS.CS_SOURCE_ID IS
'Для полей ссылок которые могут содержать Null';

COMMENT ON COLUMN CHANGELOG.LOG_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CHANGELOG.OBJECT_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CHANNELS.CH_NUMBER IS
'номер в аналаге';

COMMENT ON COLUMN CHANNELS.CH_NAME IS
'название канала';

COMMENT ON COLUMN CHANNELS.CH_NOTICE IS
'Примечание';

COMMENT ON COLUMN CHANNELS.CH_FREQ IS
'Частота в аналоге';

COMMENT ON COLUMN CHANNELS.CH_CODED IS
'Кодирован ли канал в цифре';

COMMENT ON COLUMN CHANNELS.CH_TRUNK IS
'STVcrypt ствол';

COMMENT ON COLUMN CHANNELS.CH_TRUNK_NUMBER IS
'STVcrypt номер в стволе';

COMMENT ON COLUMN CHANNELS.DEFINITION IS
'SD HD 4k 3D';

COMMENT ON COLUMN CHANNELS.LANG IS
'Основной язык трансляции
ENGLISH ENG, RUSSIAN RUS, LATVIAN LAV, LITHUANIAN LIT, ESTONIAN EST, BELARUSIAN BEL, UKRAINIAN UKR, GERMAN DEU, FRENCH FRA';

COMMENT ON COLUMN CHANNELS.DVBGENRES IS
'основные жанры DVB для канала';

COMMENT ON COLUMN CHANNELS.MINAGE IS
'Минимальный возраст';

COMMENT ON COLUMN CHANNELS.ACCESS_ID IS
'Ключ доступа для систем кодирования CONAX И подообных';

COMMENT ON COLUMN CHANNELS.CONTRACT_ID IS
'договор с дистрибьютором';

COMMENT ON COLUMN CHANNELS.CH_LIC IS
'Лицензия';

COMMENT ON COLUMN CHANNELS.CH_CERT IS
'Свидетельство СМИ';

COMMENT ON COLUMN CHANNELS.CH_THEME IS
'Тематика';

COMMENT ON COLUMN CHANNELS_IN_SERVCE.SRV_ID IS
'Код услуги';

COMMENT ON COLUMN CHANNELS_IN_SERVCE.CH_ID IS
'Код канала';

COMMENT ON COLUMN CHANNELS_IN_SERVCE.ON_OFF IS
'1 - при включенной услуге
0 - при отключенной услуге';

COMMENT ON COLUMN CHANNEL_SRC.CS_ID IS
'ID источника';

COMMENT ON COLUMN CHANNEL_SRC.NAME IS
'Название';

COMMENT ON COLUMN CHANNEL_SRC.NOTICE IS
'Примечание';

COMMENT ON COLUMN CHANNEL_SRC.DEG IS
'Орбитальное положение';

COMMENT ON COLUMN CHANNEL_SRC.URL IS
'Ссылка на источник в интернете';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.CS_ID IS
'ID источника';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.CH_ID IS
'ID Канала';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.NOTICE IS
'Примечание';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.FREQ IS
'Частота / поляризация';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.SYMRATE IS
'Скорость';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.IP IS
'IP потока';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.V_CODEC IS
'Видео кодек';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.S_CRYPT IS
'Система кодирования сигнала';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.CS_SYSTEM IS
'Стандарт вещания';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.CARD_ID IS
'Номер карты/декодера';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.ON_ANALOG IS
'Основной для аналога';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.ON_DVB IS
'Основной для DVB';

COMMENT ON COLUMN CHANNEL_SRC_PARAM.ON_IPTV IS
'Основной для IPTV';

COMMENT ON COLUMN COMPANY.C_TYPE IS
'ftString, ftFixedChar, ftWideString,
ftSmallint, ftInteger, ftLargeint, ftWord, ftFloat, ftCurrency,
ftBoolean,
ftDate, ftTime, ftDateTime,
ftVariant,
ftGuid,
ftBlob';

COMMENT ON COLUMN CUSTOMER.CUSTOMER_ID IS
'уникальный код абонента. все таблицы ссылаются на этот код.';

COMMENT ON COLUMN CUSTOMER.CUST_CODE IS
'Код абонента';

COMMENT ON COLUMN CUSTOMER.HOUSE_ID IS
'Код дома таблица HOUSE';

COMMENT ON COLUMN CUSTOMER.ACCOUNT_NO IS
'Лиц. счет';

COMMENT ON COLUMN CUSTOMER.DOGOVOR_NO IS
'Номер договора';

COMMENT ON COLUMN CUSTOMER.SURNAME IS
'Фамилия';

COMMENT ON COLUMN CUSTOMER.FIRSTNAME IS
'Имя или форма собственности у ЮЛ';

COMMENT ON COLUMN CUSTOMER.MIDLENAME IS
'Отчество';

COMMENT ON COLUMN CUSTOMER.INITIALS IS
'Инициалы';

COMMENT ON COLUMN CUSTOMER.CONTRACT_DATE IS
'Дата договора';

COMMENT ON COLUMN CUSTOMER.ACTIVIZ_DATE IS
'Дата первого подключения';

COMMENT ON COLUMN CUSTOMER.PHONE_NO IS
'телефон';

COMMENT ON COLUMN CUSTOMER.NOTICE IS
'Примечание';

COMMENT ON COLUMN CUSTOMER.VALID_TO IS
'Договор до';

COMMENT ON COLUMN CUSTOMER.CUST_STATE IS
'Статус подключения если 0 то ни к одной услуге не подключен';

COMMENT ON COLUMN CUSTOMER.CUST_STATE_DESCR IS
'Статус подключения Код абонентской услуги и наименование услуги вкл./выкл.';

COMMENT ON COLUMN CUSTOMER.FLAT_NO IS
'Квартира';

COMMENT ON COLUMN CUSTOMER.DEBT_SUM IS
'Долг';

COMMENT ON COLUMN CUSTOMER.PASSPORT_NUMBER IS
'Паспорт';

COMMENT ON COLUMN CUSTOMER.PASSPORT_REGISTRATION IS
'кем и когда выдан';

COMMENT ON COLUMN CUSTOMER.PERSONAL_N IS
'Личный номер паспорта или БИК у ЮЛ';

COMMENT ON COLUMN CUSTOMER.MANAGER_ID IS
'Кто принял заказ  ссылка на таблицу Worker';

COMMENT ON COLUMN CUSTOMER.JURIDICAL IS
'Признак юр. лица';

COMMENT ON COLUMN CUSTOMER.JUR_INN IS
'ИНН юр. лица';

COMMENT ON COLUMN CUSTOMER.JUR_DIRECTOR IS
'ФИО директора';

COMMENT ON COLUMN CUSTOMER.JUR_BUH IS
'ФИО бухгалтера';

COMMENT ON COLUMN CUSTOMER.CGIS IS
'Поле может использоваться в своих целях';

COMMENT ON COLUMN CUSTOMER.MOBILE_PHONE IS
'Мобильный телефон';

COMMENT ON COLUMN CUSTOMER.HIS_COLOR IS
'цвет фона для абонента';

COMMENT ON COLUMN CUSTOMER.TIME_ON_MINUS IS
'Дата и время когда баланс стал отрицательным';

COMMENT ON COLUMN CUSTOMER.BIRTHDAY IS
'Дата рождения';

COMMENT ON COLUMN CUSTOMER.ADRES_REGISTR IS
'Адрес регистрации';

COMMENT ON COLUMN CUSTOMER.ORG_ID IS
'В какой организации обслуживается';

COMMENT ON COLUMN CUSTOMER.VATG_ID IS
'Группа НДС';

COMMENT ON COLUMN CUSTOMER.FLAT_DIGIT IS
'квартира. только цифры';

COMMENT ON COLUMN CUSTOMER.TAP IS
'Отвод';

COMMENT ON COLUMN CUSTOMER.PREPAY IS
'Обещанный платеж';

COMMENT ON COLUMN CUSTOMER.PREPAY_TIME IS
'Время внесения обещаного платежа';

COMMENT ON COLUMN CUSTOMER.ADDED_BY IS
'кто добавил';

COMMENT ON COLUMN CUSTOMER.ADDED_ON IS
'когда добавил';

COMMENT ON COLUMN CUSTOMER.EDIT_BY IS
'кто изменил';

COMMENT ON COLUMN CUSTOMER.EDIT_ON IS
'когда изменил';

COMMENT ON COLUMN CUSTOMER.HAND_CONTROL IS
'"ручное управление". т.е. услуги не отключать автоматом';

COMMENT ON COLUMN CUSTOMER.BANK IS
'Банковские реквизиты юр. лица';

COMMENT ON COLUMN CUSTOMER.BANK_ACCOUNT IS
'Рассчетный счет';

COMMENT ON COLUMN CUSTOMER.PASSPORT_VALID IS
'Проверен ли паспорт
null не проверен
0 - невалиден
1 - все ок';

COMMENT ON COLUMN CUSTOMER.CONTRACT_BASIS IS
'Для юр. лиц "В ЛИЦЕ... на основании" / Для физ. лица. "Место рождения"';

COMMENT ON COLUMN CUSTOMER.BANK_ID IS
'ид банка';

COMMENT ON COLUMN CUSTOMER_ATTRIBUTES.RQ_ID IS
'Какой заявкой был выставлен атрибут';

COMMENT ON COLUMN CUSTOMER_BONUSES.CUSTOMER_DEBT IS
'Баланс абонента в момент добавления бонуса';

COMMENT ON COLUMN CUSTOMER_BONUSES.BONUS_DATE IS
'Дата бонуса';

COMMENT ON COLUMN CUSTOMER_BONUSES.BT_ID IS
'За что бонус (оплата, акция. и прочее)';

COMMENT ON COLUMN CUSTOMER_BONUSES.UNITS IS
'Кол-во бонусов (единицы)';

COMMENT ON COLUMN CUSTOMER_BONUSES.BONUS IS
'Сумма бонусов (деньги)';

COMMENT ON COLUMN CUSTOMER_BONUSES.EXT_ID IS
'номер платежа или другой номер в зависимости от типа';

COMMENT ON COLUMN CUSTOMER_CHANNELS.CH_ID IS
'код канала';

COMMENT ON COLUMN CUSTOMER_CHANNELS.DATE_ON IS
'дата включения канала';

COMMENT ON COLUMN CUSTOMER_CHANNELS.DATE_OFF IS
'дата выключения канала';

COMMENT ON COLUMN CUSTOMER_CHANNELS.NOTICE IS
'Примечание';

COMMENT ON COLUMN CUSTOMER_CHANNELS.DECODER_ID IS
'код декодера абонента';

COMMENT ON COLUMN CUSTOMER_CONTACTS.CUSTOMER_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CUSTOMER_CONTACTS.CC_TYPE IS
'Тип контакта
0 - телефон
1 - мобильный телефон
2 - email
3 - skype
4 - icq
5 - ANDROID PUSH ID
6 - IOS PUSH ID';

COMMENT ON COLUMN CUSTOMER_CONTACTS.CC_NOTIFY IS
'контакт для уведомлений (смс, email)';

COMMENT ON COLUMN CUSTOMER_CONTACTS.CC_VAL_REVERSE IS
'реверс значения для поиска по телефону';

COMMENT ON COLUMN CUSTOMER_DECODERS.DEC_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CUSTOMER_DECODERS.CUSTOMER_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CUSTOMER_DECODERS.DECODER_N IS
'Номер декодера';

COMMENT ON COLUMN CUSTOMER_DECODERS.STB_N IS
'Номер приставки';

COMMENT ON COLUMN CUSTOMER_DECODERS.TV_MODEL IS
'Модель телевизора';

COMMENT ON COLUMN CUSTOMER_DECODERS.TV_SOFT IS
'версия софта телевизора';

COMMENT ON COLUMN CUSTOMER_DECODERS.PAIRING IS
'Связан ли декодер с устройством';

COMMENT ON COLUMN CUSTOMER_EQUIPMENT.CUSTOMER_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN CUSTOMER_EQUIPMENT.EQUIP_N IS
'Номер оборудования';

COMMENT ON COLUMN CUSTOMER_FILES.CF_ID IS
'ID файла';

COMMENT ON COLUMN CUSTOMER_FILES.CUSTOMER_ID IS
'ID абонента';

COMMENT ON COLUMN CUSTOMER_FILES.NAME IS
'название / номер документа';

COMMENT ON COLUMN CUSTOMER_FILES.CF_TYPE IS
'Тип документа';

COMMENT ON COLUMN CUSTOMER_FILES.DATE_FROM IS
'Дествует с';

COMMENT ON COLUMN CUSTOMER_FILES.DATE_TO IS
'Действует по';

COMMENT ON COLUMN CUSTOMER_FILES.FILENAME IS
'Имя файла';

COMMENT ON COLUMN CUSTOMER_FILES.NOTICE IS
'Примечание';

COMMENT ON COLUMN CUSTOMER_FILES.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN CUSTOMER_FILES.ADDED_ON IS
'Когда добавил';

COMMENT ON COLUMN CUSTOMER_FILES.EDIT_BY IS
'Кто изменил';

COMMENT ON COLUMN CUSTOMER_FILES.EDIT_ON IS
'Когда изменил';

COMMENT ON COLUMN CUSTOMER_FILES.ACT IS
'Рассмотрен / Обработан';

COMMENT ON COLUMN CUSTOMER_FILES.ANOTICE IS
'Комментарий к обработке';

COMMENT ON COLUMN DEVPORTS.ID IS
'будет удалена. Таблица для карты.';

COMMENT ON COLUMN DEVPORTS.LINK IS
'будет удалена. Таблица для карты.';

COMMENT ON COLUMN DISCOUNT_FACTOR.SRV_TYPE IS
'Если';

COMMENT ON COLUMN DISTRIBUTOR.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN DISTRIBUTOR.NAME IS
'ДИСТРИБЬЮТОР';

COMMENT ON COLUMN DISTRIBUTOR.ADDRESS IS
'Почтовый адрес';

COMMENT ON COLUMN DISTRIBUTOR.JADDRESS IS
'Юр. адрес';

COMMENT ON COLUMN DISTRIBUTOR.EMAIL IS
'емаил';

COMMENT ON COLUMN DISTRIBUTOR.PHONES IS
'телефоны';

COMMENT ON COLUMN DISTRIBUTOR.NOTICE IS
'Примечание';

COMMENT ON COLUMN DISTRIB_CONTRACTS.DISTRIBUTOR_ID IS
'ID дистрибьютора';

COMMENT ON COLUMN DISTRIB_CONTRACTS.C_NUMBER IS
'Номер договора';

COMMENT ON COLUMN DISTRIB_CONTRACTS.C_DATE IS
'Дата договора';

COMMENT ON COLUMN DISTRIB_CONTRACTS.C_DATE_BEFORE IS
'Договор до даты';

COMMENT ON COLUMN DISTRIB_CONTRACTS.REPORT_FRMT IS
'Формат доставки PDF DOC';

COMMENT ON COLUMN DISTRIB_CONTRACTS.DELIVERY IS
'Как доставлять 0-EMAIL 1-ОБЫЧНАЯ ПОЧТА';

COMMENT ON COLUMN DISTRIB_CONTRACTS.FINTERMS IS
'Финансовые условия по договору';

COMMENT ON COLUMN DISTRIB_CONTRACTS.MINTERMS IS
'Количество абонентов, чел';

COMMENT ON COLUMN DISTRIB_CONTRACTS.REPORT_ID IS
'ИД отчета';

COMMENT ON COLUMN DISTRIB_CONTRACTS.CTYPE IS
'Вид договора';

COMMENT ON COLUMN DISTRIB_CONTRACTS.NOTICE IS
'Примечание';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.CONTRACT_ID IS
'Договор';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.CH_ID IS
'Канал';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.COST IS
'Цена';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.CUST_COUNT IS
'Кол-во абонентов';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.DTV IS
'Канала в цифре';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.ATV IS
'Канала в аналоге';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.IPTV IS
'Канала в iptv';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.OTT IS
'Канала в ott';

COMMENT ON COLUMN DISTRIB_CONTRACT_CH.NOTICE IS
'Примечание';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.PERIOD IS
'за какой месяц отчет';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.START_CNT IS
'Цифра на начало периода';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.END_CNT IS
'Цифра на конец периода';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.START_SUM IS
'Сумма на начало';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.END_SUM IS
'Сумма на конец';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.V_NUM IS
'для личных нужд оператора';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.V_DATE IS
'для личных нужд оператора';

COMMENT ON COLUMN DISTRIB_CONTRACT_REPORTS.V_TEXT IS
'для личных нужд оператора';

COMMENT ON COLUMN DVB_NETWORK.DVBN_ID IS
'Уникальный ID сети';

COMMENT ON COLUMN DVB_NETWORK.NAME IS
'Название сети (Передается в NIT)';

COMMENT ON COLUMN DVB_NETWORK.NOTICE IS
'Примечание';

COMMENT ON COLUMN DVB_NETWORK.ONID IS
'ONID (Original Network ID) - Идентификатор оператора ТВ';

COMMENT ON COLUMN DVB_NETWORK.NID IS
'NID (Network ID) – Идентификатор цифровой сети.';

COMMENT ON COLUMN DVB_NETWORK.PIDS IS
'BAT - Bouquet Association Table
CAT - Conditional Access Table
CIT - Content Identifier Table
DIT - Discontinuity Information Table
EIT - Event Information Table
NIT - Network Information Table
PAT - Program Association Table
RNT - RAR Notification Table
RST - Running Status Table
SDT - Service Description Table
SIT - Selection Information Table
ST  - Stuffing Table
TDT - Time and Date Table
TOT - Time Offset Table
TSDT- Transport Stream Description Table';

COMMENT ON COLUMN DVB_NETWORK.DESCRIPTORS IS
' ExtendedEventDescriptor - расширеное описание
 ParentalRatingDescriptor - возрастной контроль
 ContentDescriptor - жанр';

COMMENT ON COLUMN DVB_NETWORK.TIMEOFFSET IS
'Сдвиг времени в минутах относительно UTC';

COMMENT ON COLUMN DVB_NETWORK.LANG IS
'Основной язык сети';

COMMENT ON COLUMN DVB_NETWORK.COUNTRY IS
'Страна ISO 3166 3-х буквенная';

COMMENT ON COLUMN DVB_NETWORK.EPG_UPDATED IS
'Дата последнего изменения телепрограммы';

COMMENT ON COLUMN DVB_NETWORK.AOSTRM IS
'Будет удалено';

COMMENT ON COLUMN DVB_STREAMS.DVBN_ID IS
'Network ID (Epg network)';

COMMENT ON COLUMN DVB_STREAMS.ES_IP IS
'IP приемника/мультипдлексора';

COMMENT ON COLUMN DVB_STREAMS.ES_PORT IS
'Порт приемника';

COMMENT ON COLUMN DVB_STREAMS.BITRATE IS
'Скорость потока Килобайт в секунду';

COMMENT ON COLUMN DVB_STREAMS.TSID IS
'TSID (Transport stream ID) – идентификатор транспортного потока';

COMMENT ON COLUMN DVB_STREAMS.QAM IS
'QAM, используется в NIT';

COMMENT ON COLUMN DVB_STREAMS.FREQ IS
'Частота, используется в NIT';

COMMENT ON COLUMN DVB_STREAMS.EPG_UPDATED IS
'Дата последнего изменения телепрограммы';

COMMENT ON COLUMN DVB_STREAMS.ONID IS
'ONID (Original Network ID) - Идентификатор оператора ТВ';

COMMENT ON COLUMN DVB_STREAMS.AOSTRM IS
'Если установлен, то передавать в EIT Actual\Other Stream  (для всех потоков),
иначе только для текущего потока';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.DVBS_ID IS
'ID потока';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.CH_ID IS
'ID кнала';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.SID IS
'номер SID в EPG';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.LCN IS
'номер канала LCN в EPG';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.NOTICE IS
'Примечание';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.VPID IS
'Выходной видео PID';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.APID IS
'Выходной аудио PID';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.A2PID IS
'Выходной аудио PID вторая дорожка';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.BITRATE IS
'Символьная скорость';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.CONID IS
'ONID для канала, если отличается от сети';

COMMENT ON COLUMN DVB_STREAM_CHANNELS.CNID IS
'NID для канала, если отличается от сети';

COMMENT ON COLUMN EPG.CH_ID IS
'Код канала';

COMMENT ON COLUMN EPG.EPG_DATE IS
'Дата события';

COMMENT ON COLUMN EPG.UTC_DATE IS
'День по UTC';

COMMENT ON COLUMN EPG.DATE_START IS
'Время начала';

COMMENT ON COLUMN EPG.DATE_STOP IS
'Время окончания';

COMMENT ON COLUMN EPG.UTC_START IS
'Дата и время по UTC';

COMMENT ON COLUMN EPG.UTC_STOP IS
'Окончание по UTC';

COMMENT ON COLUMN EPG.DURATION IS
'Продолжительность';

COMMENT ON COLUMN EPG.TITLE IS
'Название';

COMMENT ON COLUMN EPG.DESCRIPTION IS
'Описание';

COMMENT ON COLUMN EPG.GENRES IS
'Категории из источника';

COMMENT ON COLUMN EPG.DVBGENRES IS
'коды жанров DVB через ,';

COMMENT ON COLUMN EPG.MINAGE IS
'Ограничение по возрасту';

COMMENT ON COLUMN EPG.CREATE_YEAR IS
'Год создания';

COMMENT ON COLUMN EPG.ACTORS IS
'Актеры';

COMMENT ON COLUMN EPG.DIRECTED IS
'Режисер';

COMMENT ON COLUMN EPG.COUNTRY IS
'Страна производитель';

COMMENT ON COLUMN EPG_AD.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN EPG_AD.START_TIME IS
'Время начала';

COMMENT ON COLUMN EPG_AD.STOP_TIME IS
'Время окончания';

COMMENT ON COLUMN EPG_AD.AD_TITLE IS
'Что передавать в заголовке EPG';

COMMENT ON COLUMN EPG_AD.AD_DESCRIPTION IS
'Что передавать в описании.';

COMMENT ON COLUMN EPG_AD.ALL_CHAN IS
'Все каналы или нет';

COMMENT ON COLUMN EPG_AD.FOR_EMPTY IS
'Для каналов без расписания';

COMMENT ON COLUMN EPG_LOCAL.CH_ID IS
'Код канала';

COMMENT ON COLUMN EPG_LOCAL.DATE_START IS
'Время начала';

COMMENT ON COLUMN EPG_LOCAL.EPG_DATE IS
'Дата события';

COMMENT ON COLUMN EPG_LOCAL.TITLE IS
'Название';

COMMENT ON COLUMN EPG_LOCAL.DURATION IS
'Продолжительность';

COMMENT ON COLUMN EPG_LOCAL.DATE_STOP IS
'Время окончания';

COMMENT ON COLUMN EPG_LOCAL.DESCRIPTION IS
'Описание';

COMMENT ON COLUMN EPG_LOCAL.GENRES IS
'Категории из источника';

COMMENT ON COLUMN EPG_LOCAL.DVBGENRES IS
'коды жанров DVB через ,';

COMMENT ON COLUMN EPG_LOCAL.MINAGE IS
'Ограничение по возрасту';

COMMENT ON COLUMN EPG_LOCAL.CREATE_YEAR IS
'Год создания';

COMMENT ON COLUMN EPG_LOCAL.ACTORS IS
'Актеры';

COMMENT ON COLUMN EPG_LOCAL.DIRECTED IS
'Режисер';

COMMENT ON COLUMN EPG_LOCAL.COUNTRY IS
'Страна производитель';

COMMENT ON COLUMN EPG_LOCAL.UTC_DATE IS
'День по UTC';

COMMENT ON COLUMN EPG_LOCAL.UTC_START IS
'Дата и время по UTC';

COMMENT ON COLUMN EPG_LOCAL.UTC_STOP IS
'Окончание по UTC';

COMMENT ON COLUMN EPG_MAPPING.EPG_ID IS
'EPG_ID';

COMMENT ON COLUMN EPG_MAPPING.CH_ID IS
'Channel ID';

COMMENT ON COLUMN EPG_MAPPING.EPG_CODE IS
'Код канала в источнике EPG';

COMMENT ON COLUMN EPG_SOURCES.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN EPG_SOURCES.TIME_SHIFT IS
'Сдвиг времени в часах';

COMMENT ON COLUMN EPG_SOURCES.PARSEAS IS
'Алгоритм разбора файла';

COMMENT ON COLUMN EPG_SOURCES.LOCAL_TZONE IS
'Использовать локальный часовой пояс вместо указанного в файле';

COMMENT ON COLUMN EPG_SOURCES.LOCAL_FILE IS
'Локальный файл (какой файл открывать и в какой файл скачивать из интернета)';

COMMENT ON COLUMN EPG_SOURCES.HAND_ONLY IS
'Загрузка только в ручном режиме';

COMMENT ON COLUMN EQUIPMENT.IP IS
'IP сети';

COMMENT ON COLUMN EQUIPMENT.MAC IS
'MAC сети';

COMMENT ON COLUMN EQUIPMENT.EQ_TYPE IS
'Тип оборудования
1-LAN
2-TV
3-прочее';

COMMENT ON COLUMN EQUIPMENT.PORCH_N IS
'Подъезд';

COMMENT ON COLUMN EQUIPMENT.FLOOR_N IS
'Этаж';

COMMENT ON COLUMN EQUIPMENT.MASK IS
'Маска сети';

COMMENT ON COLUMN EQUIPMENT.VLAN_ID IS
'ID VLAN из справочника вланов';

COMMENT ON COLUMN EQUIPMENT.PARENT_ID IS
'Подключен к';

COMMENT ON COLUMN EQUIPMENT.PARENT_PORT IS
'Подключен к порту или гнезду';

COMMENT ON COLUMN EQUIPMENT.EQ_LINE IS
'Магистраль 0 - Внешняя 1 - Домовая';

COMMENT ON COLUMN EQUIPMENT.SIGNAL_IN IS
'Уровень входного сигнала';

COMMENT ON COLUMN EQUIPMENT.SIGNAL_OUT IS
'Уровень выходного сигнала';

COMMENT ON COLUMN EQUIPMENT.EQ_ACTIVE IS
'Активное - пассивное';

COMMENT ON COLUMN EQUIPMENT.EQ_DELIVERY_DATE IS
'Дата ввода в эксплуатацию';

COMMENT ON COLUMN EQUIPMENT.EQ_DELIVERY_COST IS
'Стоимость на момент ввода в эксплуатацию';

COMMENT ON COLUMN EQUIPMENT.EQ_REGNUBER IS
'Инвентарный номер';

COMMENT ON COLUMN EQUIPMENT.NODE_ID IS
'ID узла';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.EC_ID IS
'Код комманды';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.EG_ID IS
'Код группы оборудования или -1 = Все группы';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.NAME IS
'Название комманды';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.COMMAND IS
'сама комманда';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.CMD_TYPE IS
'0-телнет, 1-SNMP, 2-HTTP';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.IN_GUI IS
'Возможность исполнять из ПО';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.EOL_CHRS IS
'Символы конца строки';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.URL IS
'Ссылка HTTP или подобное';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.AUT_USER IS
'Авторизация пользователь (http basic например)';

COMMENT ON COLUMN EQUIPMENT_CMD_GRP.AUT_PSWD IS
'Авторизация пароль';

COMMENT ON COLUMN EQUIPMENT_COVERAGE.EID IS
'Код оборудования';

COMMENT ON COLUMN EQUIPMENT_COVERAGE.HOUSE_ID IS
'Код дома';

COMMENT ON COLUMN EQUIPMENT_DVB.EQ_TYPE IS
'OBJECT TYPE 19 0 - Карточка 1-приставка 2-модуль';

COMMENT ON COLUMN EQUIPMENT_DVB.EQ_N IS
'Номер';

COMMENT ON COLUMN EQUIPMENT_DVB.EQ_STATE IS
'0 - Удален
1 - На складе
2 - На руках
3 - Утерян/Списан
4 - Ремонт';

COMMENT ON COLUMN EQUIPMENT_DVB.EQ_MAN IS
'Производитель';

COMMENT ON COLUMN EQUIPMENT_DVB.NOTICE IS
'Примечание';

COMMENT ON COLUMN EQUIPMENT_DVB.TEXT_ENCODE IS
'Кодировка сообщений
ISO WIN UTF';

COMMENT ON COLUMN EQUIPMENT_DVB.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN EQUIPMENT_DVB.ADDED_ON IS
'Когда';

COMMENT ON COLUMN EQUIPMENT_HISTORY.EQ_STATE IS
'0-Удален 1-Возврат 2-Выдан 3-Утерян/Списан 4-В ремонте и Непонятки';

COMMENT ON COLUMN EVENT_DETAIL.E_DATE IS
'Дата';

COMMENT ON COLUMN EVENT_DETAIL.E_YEAR IS
'Год';

COMMENT ON COLUMN EVENT_DETAIL.E_MONTH IS
'Месяц';

COMMENT ON COLUMN EVENT_DETAIL.E_DAY IS
'Год';

COMMENT ON COLUMN EVENT_DETAIL.E_COUNT IS
'счетчик (потрачено байт или кол-во входов)';

COMMENT ON COLUMN EVENT_DETAIL.E_MONEY IS
'Выражено в деньгах';

COMMENT ON COLUMN FREQPLAN.WAVE IS
'Длина волны МВ ДМВ УКВ';

COMMENT ON COLUMN FREQPLAN.NAME IS
'Номер ТВ канала';

COMMENT ON COLUMN FREQPLAN.LOW_FQ IS
'нижняя  Частотные границы канала (полосы), МГц';

COMMENT ON COLUMN FREQPLAN.HIGH_FQ IS
'верхняя Частотные границы канала (полосы), МГц';

COMMENT ON COLUMN FREQPLAN.VIDEO IS
'Несущая частота изображения, МГц Аналоговое телевидение';

COMMENT ON COLUMN FREQPLAN.SOUND IS
'Несущая частота звука, МГц Аналоговое телевидение';

COMMENT ON COLUMN FREQPLAN.DTV IS
'Частота для настройки цифрового телевидения, МГц';

COMMENT ON COLUMN FREQPLAN.NOTICE IS
'Примечание / Диапазон';

COMMENT ON COLUMN HEADEND.HE_ID IS
'код';

COMMENT ON COLUMN HEADEND.HE_NAME IS
'Название';

COMMENT ON COLUMN HEADEND.HOUSE_ID IS
'код дома';

COMMENT ON COLUMN HEADEND.HE_PLACE IS
'место';

COMMENT ON COLUMN HEADEND.HE_TYPE IS
'Тип';

COMMENT ON COLUMN HEADEND.PARENT_ID IS
'К чему подключено';

COMMENT ON COLUMN HEADEND_CHANNELS.CH_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN HEADEND_CHANNELS.HE_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN HEADEND_CHANNELS.CH_FREQ IS
'Частота';

COMMENT ON COLUMN HEADEND_CHANNELS.CH_NUMBER IS
'Номер канала';

COMMENT ON COLUMN HOUSE.HOUSE_BLB IS
'Сссылка на таблицу BLOB_TBL (бинарные данные)';

COMMENT ON COLUMN HOUSE.MAP_FLATS IS
'Для карты. квартир в ряд';

COMMENT ON COLUMN HOUSE.MAP_WIDTH IS
'Для карты. ширина';

COMMENT ON COLUMN HOUSE.MAP_HEIGHT IS
'Для карты. высота';

COMMENT ON COLUMN HOUSE.HEADEND_ID IS
'Головная станция';

COMMENT ON COLUMN HOUSE.HOUSE_CODE IS
'Код дома';

COMMENT ON COLUMN HOUSE.EXIST_TV IS
'Доступно Аналоговое ТВ';

COMMENT ON COLUMN HOUSE.EXIST_LAN IS
'Доступна сеть передачи данных';

COMMENT ON COLUMN HOUSE.EXIST_DTV IS
'Доступно Цифровое ТВ';

COMMENT ON COLUMN HOUSE.WG_ID IS
'ID звена (рабочей группы)';

COMMENT ON COLUMN HOUSE.IN_DATE IS
'Дата вводв в экспл.';

COMMENT ON COLUMN HOUSE.REPAIR_DATE IS
'Дата последнего кап ремонта';

COMMENT ON COLUMN HOUSE.LATITUDE IS
'Широта (вертикаль)';

COMMENT ON COLUMN HOUSE.LONGITUDE IS
'Долгота (горизонталь)';

COMMENT ON COLUMN HOUSEFLOOR.FLATS IS
'Номера квартир, например 10-12,15 т.е. 10 11 12 15';

COMMENT ON COLUMN HOUSEPORCH.PORCH_ID IS
'код подъезда';

COMMENT ON COLUMN HOUSEPORCH.HOUSE_ID IS
'код дома';

COMMENT ON COLUMN HOUSEPORCH.PORCH_N IS
'Номер подъезда';

COMMENT ON COLUMN HOUSEPORCH.FLOORS IS
'Этажей';

COMMENT ON COLUMN HOUSEPORCH.GARRET IS
'Чердак';

COMMENT ON COLUMN HOUSEPORCH.CELLAR IS
'Подвал';

COMMENT ON COLUMN HOUSEPORCH.FLAT_FROM IS
'Квартиры с';

COMMENT ON COLUMN HOUSEPORCH.FLAT_TO IS
'Квартиры по';

COMMENT ON COLUMN HOUSES_ATTRIBUTES.HA_VALUE IS
'Значение атрибута';

COMMENT ON COLUMN INVENTORY.OWNER IS
'ID владелеца согласно типа';

COMMENT ON COLUMN INVENTORY.OWNER_TYPE IS
'Тип владелеца type=51 1-Абонент 2-Узел';

COMMENT ON COLUMN INVENTORY.M_ID IS
'Материал';

COMMENT ON COLUMN INVENTORY.SERIAL IS
'Серийник';

COMMENT ON COLUMN INVENTORY.OWNERSHIP IS
'Владелец. 0-предприятие. 1-продано клиенту. 2-оборудование клиента';

COMMENT ON COLUMN INVENTORY.QUANT IS
'Кол-во';

COMMENT ON COLUMN INVENTORY.NOTICE IS
'Примечание';

COMMENT ON COLUMN IPTV_GROUP.NAME IS
'Имя группы';

COMMENT ON COLUMN IPTV_GROUP.CODE IS
'Код';

COMMENT ON COLUMN IPTV_GROUP.URL IS
'URL';

COMMENT ON COLUMN IPTV_GROUP.DISABLED IS
'Признак что группа отключена';

COMMENT ON COLUMN IPTV_GROUP.NOTICE IS
'Примечание';

COMMENT ON COLUMN IPTV_GROUP_CHANNELS.IG_ID IS
'ID IPTV группы';

COMMENT ON COLUMN IPTV_GROUP_CHANNELS.CH_ID IS
'ID канала';

COMMENT ON COLUMN IPTV_GROUP_CHANNELS.LCN IS
'Номер в группе';

COMMENT ON COLUMN IPTV_GROUP_CHANNELS.CODE IS
'код в группе';

COMMENT ON COLUMN IPTV_GROUP_CHANNELS.URL IS
'url';

COMMENT ON COLUMN JOURNAL.J_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN LETTERTYPE.FILENAME IS
'имя файла письма';

COMMENT ON COLUMN LETTERTYPE.FOR_FORM IS
'Для какой формы документ
0 - Абоненты
1 - Заявки';

COMMENT ON COLUMN LETTERTYPE.SAVE_PDF IS
'Сохранять как PDF в базе';

COMMENT ON COLUMN MAP.O_TYPE IS
'Тип объекта на карте';

COMMENT ON COLUMN MAP.CONNECTED IS
'Подключен к';

COMMENT ON COLUMN MAP_LOG.UNIQUE_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN MATERIALS.M_ID IS
'ID метериала. наименование в таблице OBJECTS';

COMMENT ON COLUMN MATERIALS.DESCRIPTION IS
'Примечание';

COMMENT ON COLUMN MATERIALS.MG_ID IS
'Группа материала. Ссылка на MATERIALS_GROUP';

COMMENT ON COLUMN MATERIALS.M_NUMBER IS
'номенклатурный номер';

COMMENT ON COLUMN MATERIALS.ROUND_TO IS
'Округлять до';

COMMENT ON COLUMN MATERIALS.COST IS
'Цена материала';

COMMENT ON COLUMN MATERIALS.BEST_COST IS
'Лучшая цена поставщика';

COMMENT ON COLUMN MATERIALS.BEST_SHIPPER_ID IS
'Лучший поставщик';

COMMENT ON COLUMN MATERIALS.IS_UNIT IS
'штучный учет';

COMMENT ON COLUMN MATERIALS.IS_DIGIT IS
'для работы цифрового тв';

COMMENT ON COLUMN MATERIALS.IS_NET IS
'для работы в сети';

COMMENT ON COLUMN MATERIALS.M_TYPE IS
'Тип устройства. в справочнике Objects_type = 48';

COMMENT ON COLUMN MATERIALS_GROUP.MG_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN MATERIALS_GROUP.PARENT_ID IS
'Для полей ссылок которые могут содержать Null';

COMMENT ON COLUMN MATERIALS_IN_DOC.B_QUANT IS
'Количество до пересчета';

COMMENT ON COLUMN MATERIALS_IN_DOC.TTN IS
'Номер в ТТН (для сортировки)';

COMMENT ON COLUMN MATERIALS_REMAIN.M_ID IS
'ID материала';

COMMENT ON COLUMN MATERIALS_REMAIN.WH_ID IS
'ID склада';

COMMENT ON COLUMN MATERIALS_REMAIN.MR_QUANT IS
'Кол-во материала';

COMMENT ON COLUMN MATERIALS_REMAIN.MR_COST IS
'Цена материала';

COMMENT ON COLUMN MATERIALS_REMAIN.INVENTORY IS
'Дата последней инвентаризации';

COMMENT ON COLUMN MATERIAL_DOCS.DOC_ID IS
'ID документа';

COMMENT ON COLUMN MATERIAL_DOCS.DOC_N IS
'Номер документа';

COMMENT ON COLUMN MATERIAL_DOCS.DOC_DATE IS
'ДАТА доумента';

COMMENT ON COLUMN MATERIAL_DOCS.DT_ID IS
'Тип документа';

COMMENT ON COLUMN MATERIAL_DOCS.NOTICE IS
'ПРимечание';

COMMENT ON COLUMN MATERIAL_DOCS.WH_ID IS
'Склад прихода';

COMMENT ON COLUMN MATERIAL_DOCS.DOC_CLOSED IS
'1 = Документ закрыт (редактировать нельзя)';

COMMENT ON COLUMN MATERIAL_DOCS.EXT_ID IS
'Номер прихода во внешней системе';

COMMENT ON COLUMN MATERIAL_DOCS.FROM_WH IS
'С какого склада';

COMMENT ON COLUMN MATERIAL_DOCS.SHIPPER IS
'Поставщик';

COMMENT ON COLUMN MATERIAL_UNIT.SERIAL IS
'Серийный номер ИД оборудования/материала';

COMMENT ON COLUMN MATERIAL_UNIT.OWNER IS
'Владелец (0-склад, 1-абонент, 2-узел) OBJECTS_TYPE = 51';

COMMENT ON COLUMN MATERIAL_UNIT.OWNER_TYPE IS
'ID владельца';

COMMENT ON COLUMN MATERIAL_UNIT.STATE IS
'Статус. 0-на складе, 1-выдан, 2-в ремонте, 3-продан, 4- списан';

COMMENT ON COLUMN MATERIAL_UNIT.MAC IS
'MAC';

COMMENT ON COLUMN MATERIAL_UNIT.DOC_INCOME IS
'Первичный документ прихода';

COMMENT ON COLUMN MATERIAL_UNIT.COST IS
'Цена закупки';

COMMENT ON COLUMN MATERIAL_UNIT.S_VERSION IS
'Версия софта';

COMMENT ON COLUMN MESSAGES.MES_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN MESSAGES.CUSTOMER_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN MESSAGES.MES_TYPE IS
'Тип собщения
SMS, EMAIL, STB, OSD';

COMMENT ON COLUMN MESSAGES.RECIVER IS
'телефон, карта или адрес получателя. т.е. куда отправлять';

COMMENT ON COLUMN MESSAGES.MES_HEAD IS
'Тема сообщений';

COMMENT ON COLUMN MESSAGES.MES_TEXT IS
'Текст сообщений, для email может содержать имя формы отчета';

COMMENT ON COLUMN MESSAGES.MES_RESULT IS
'Результат
0 - добавлен
1 - в обработке
2 - обработан
с минусом - ошибки';

COMMENT ON COLUMN MESSAGES.SEND_DATE IS
'Дата отправки';

COMMENT ON COLUMN MESSAGES.ADDED_ON IS
'Когда добавили';

COMMENT ON COLUMN MESSAGES.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN MESSAGES.MES_PRIOR IS
'Приоритет сообщения, все что выше 0 отправляется вне зависимости от времени суток';

COMMENT ON COLUMN MESSAGES.EXT_ID IS
'ID сообщения во внешней сисеме';

COMMENT ON COLUMN MESSAGES.TPL_ID IS
'Тип сообщения';

COMMENT ON COLUMN MESSAGES.INFO_PERIOD IS
'Период, в течение которого, соблюдая интервал, отправляется сообщение Инфокас';

COMMENT ON COLUMN MESSAGES.INFO_INTERVAL IS
'Интервал отправки сообщения Инфокас';

COMMENT ON COLUMN MESSAGES.TAG IS
'пометка для аналитики. типа #ДОЛГ #ДР';

COMMENT ON COLUMN MESSAGE_TPL.MT_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN MESSAGE_TPL.MT_NAME IS
'название шаблона';

COMMENT ON COLUMN MESSAGE_TPL.MES_HEAD IS
'Заголовок';

COMMENT ON COLUMN MESSAGE_TPL.MES_TEXT IS
'Текст';

COMMENT ON COLUMN MESSAGE_TPL.MES_TYPE IS
'Тип сообщения';

COMMENT ON COLUMN MESSAGE_TPL.NOTICE IS
'Примечание';

COMMENT ON COLUMN MODULES.LANG IS
'0 Pascal, 1 C++, 2 JavaScript, 3 Basic';

COMMENT ON COLUMN MODULES.IN_MENU IS
'Отображать в меню';

COMMENT ON COLUMN MONTHLY_FEE.VAT_TAX IS
'Ставка НДС';

COMMENT ON COLUMN NODES.NODE_ID IS
'ID узла';

COMMENT ON COLUMN NODES.HOUSE_ID IS
'Ближайший дом';

COMMENT ON COLUMN NODES.TYPE_ID IS
'Тип узла OBJECTS_TYPE 38';

COMMENT ON COLUMN NODES.NAME IS
'Название узла';

COMMENT ON COLUMN NODES.NOTICE IS
'Примечание';

COMMENT ON COLUMN NODES.LAT IS
'Координаты. Широта';

COMMENT ON COLUMN NODES.LON IS
'Координаты. Долгота';

COMMENT ON COLUMN NODES.FLOOR_N IS
'этаж';

COMMENT ON COLUMN NODES.PORCH_N IS
'подъезд';

COMMENT ON COLUMN NODES.PLACE IS
'Место установки';

COMMENT ON COLUMN NODES.PARENT_ID IS
'К какому узлу подулючен узел';

COMMENT ON COLUMN NODES_ATTRIBUTES.NA_VALUE IS
'Значение атрибута';

COMMENT ON COLUMN NODE_FILES.NF_ID IS
'ID файла';

COMMENT ON COLUMN NODE_FILES.NODE_ID IS
'ID абонента';

COMMENT ON COLUMN NODE_FILES.NAME IS
'название / номер документа';

COMMENT ON COLUMN NODE_FILES.NF_TYPE IS
'Тип документа';

COMMENT ON COLUMN NODE_FILES.DATE_FROM IS
'Дествует с';

COMMENT ON COLUMN NODE_FILES.DATE_TO IS
'Действует по';

COMMENT ON COLUMN NODE_FILES.FILENAME IS
'Имя файла';

COMMENT ON COLUMN NODE_FILES.NOTICE IS
'Примечание';

COMMENT ON COLUMN NODE_FILES.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN NODE_FILES.ADDED_ON IS
'Когда добавил';

COMMENT ON COLUMN NODE_FILES.EDIT_BY IS
'Кто изменил';

COMMENT ON COLUMN NODE_FILES.EDIT_ON IS
'Когда изменил';

COMMENT ON COLUMN NODE_LAYOUT.NODE_ID IS
'Ид узла, если < 0, то это ид типа узла';

COMMENT ON COLUMN NODE_LAYOUT.M_TYPE IS
'Ид типа материала/оборудования';

COMMENT ON COLUMN NODE_LAYOUT.DEV_CNT IS
'Кол-во на узле';

COMMENT ON COLUMN NPS.NPS_DATE IS
'Дата проведения опроса';

COMMENT ON COLUMN NPS.CUSTOMER_ID IS
'Абонент';

COMMENT ON COLUMN NPS.RATING IS
'Оценка';

COMMENT ON COLUMN NPS.NOTICE IS
'Текст (почему)';

COMMENT ON COLUMN NPS.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN NPS.ADDED_ON IS
'Когда добавил';

COMMENT ON COLUMN NPS.EDIT_BY IS
'Кто изменил';

COMMENT ON COLUMN NPS.EDIT_ON IS
'Когда изменил';

COMMENT ON COLUMN OBJECTS.O_TYPE IS
'тип (вид) справочника (береться из таблицы OBJECTS_TYPE)';

COMMENT ON COLUMN OBJECTS.O_NAME IS
'Наименовние';

COMMENT ON COLUMN OBJECTS.O_DESCRIPTION IS
'Описание, примечание';

COMMENT ON COLUMN OBJECTS.O_DELETED IS
'Признак удаления, если 1-значит удалено';

COMMENT ON COLUMN OBJECTS.O_DIMENSION IS
'измерение  / Цвет для групп оборудования / и т.д. для каждого типа свое значение';

COMMENT ON COLUMN OBJECTS.O_CHARFIELD IS
'Поле для хранения текстовой информации';

COMMENT ON COLUMN OBJECTS.O_NUMERICFIELD IS
'Поле для хранения числовой информации';

COMMENT ON COLUMN OBJECTS.O_DATEFILED IS
'Поле для хранения данных типа Дата';

COMMENT ON COLUMN OBJECTS.O_CHECK IS
'Проверка значений / или другое. зависит от типа';

COMMENT ON COLUMN OBJECTS_COVERAGE.OC_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN OBJECTS_COVERAGE.OC_TYPE IS
'тип объектов
1 - модем
2 - IP зоны';

COMMENT ON COLUMN OBJECTS_COVERAGE.O_ID IS
'ID объекта (модема зоны или прочее)';

COMMENT ON COLUMN OBJECTS_COVERAGE.HOUSE_ID IS
'ID дома';

COMMENT ON COLUMN OBJECTS_TYPE.OT_ID IS
'ID типа';

COMMENT ON COLUMN OPERATION_LOG.OPER_TIME IS
'Время действия';

COMMENT ON COLUMN OPERATION_LOG.OPERATION IS
'какая операция
0 - удаление
1 - добавление
2 - изменение';

COMMENT ON COLUMN OPERATION_LOG.OPER_WHAT IS
'над чем операция (Абонент. платеж...)';

COMMENT ON COLUMN OPERATION_LOG.OPER_WHO IS
'Кто сделал';

COMMENT ON COLUMN OPERATION_LOG.OPER_NOTE IS
'что сделали с объектом';

COMMENT ON COLUMN OPERATION_LOG.FROM_ADDRESS IS
'с какого адреса прошло изменение';

COMMENT ON COLUMN ORDERS_TP.OTP_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN ORDERS_TP.OTTP_TYPE IS
'Тип заказа OBJECTS_TYPE = 22';

COMMENT ON COLUMN ORDERS_TP.OTP_NUMBER IS
'Номер заказа';

COMMENT ON COLUMN ORDERS_TP.OTP_DATE IS
'Дата';

COMMENT ON COLUMN ORDERS_TP.FIO IS
'ФИО закзачика';

COMMENT ON COLUMN ORDERS_TP.ADRESS IS
'адрес заказчика';

COMMENT ON COLUMN ORDERS_TP.PASSPORT IS
'паспорт заказчика';

COMMENT ON COLUMN ORDERS_TP.PHONE IS
'телефон заказчика';

COMMENT ON COLUMN ORDERS_TP.QUANT IS
'Количество единиц';

COMMENT ON COLUMN ORDERS_TP.PRICE IS
'Стомость единицы заказа';

COMMENT ON COLUMN ORDERS_TP.AMOUNT IS
'сумма заказа';

COMMENT ON COLUMN ORDERS_TP.PAY_DATE IS
'Дата оплаты';

COMMENT ON COLUMN ORDERS_TP.CUSTOMER_ID IS
'Если абонент, то его ID';

COMMENT ON COLUMN ORDERS_TP.DATE_FROM IS
'Дата начала';

COMMENT ON COLUMN ORDERS_TP.DATE_TO IS
'Дата Окончания';

COMMENT ON COLUMN ORDERS_TP.ADDONS IS
'Храним дополнительные параметры по начислениям заказа';

COMMENT ON COLUMN ORDERS_TP.CANCEL_TIME IS
'Время отмены';

COMMENT ON COLUMN ORDERS_TP.CANCEL_RESON IS
'Причина отмены';

COMMENT ON COLUMN PAYMENT.PAYMENT_ID IS
'ID Платежа';

COMMENT ON COLUMN PAYMENT.PAY_DOC_ID IS
'ID платежного документа';

COMMENT ON COLUMN PAYMENT.CUSTOMER_ID IS
'Абонент ID';

COMMENT ON COLUMN PAYMENT.PAY_DATE IS
'Дата платежа';

COMMENT ON COLUMN PAYMENT.PAY_DATETIME IS
'Дата и время платежа';

COMMENT ON COLUMN PAYMENT.PAY_SUM IS
'Сумма';

COMMENT ON COLUMN PAYMENT.FINE_SUM IS
'Сумма пения';

COMMENT ON COLUMN PAYMENT.NOTICE IS
'Примечание';

COMMENT ON COLUMN PAYMENT.PAYMENT_SRV IS
'Услуга за которую платит';

COMMENT ON COLUMN PAYMENT.PAYMENT_TYPE IS
'Тип платежа';

COMMENT ON COLUMN PAYMENT.EXT_PAY_ID IS
'Идентификатор платежа во внешних системах (терминалы и прочее)';

COMMENT ON COLUMN PAYMENT.TAG IS
'цифровое поле. для личных нужд';

COMMENT ON COLUMN PAYMENT.TAG_STR IS
'текстовое поле. для личных нужд';

COMMENT ON COLUMN PAYMENT.NEED_CHECK IS
'Признак нужна ли проверка платежа.
Нужно например для обработки реесстров платежей,
если реестр не итоговый ставим признак необходимости проверки.';

COMMENT ON COLUMN PAYMENT.ADDED_BY IS
'кто добавил';

COMMENT ON COLUMN PAYMENT.ADDED_ON IS
'когда добавил';

COMMENT ON COLUMN PAYMENT.EDIT_BY IS
'кто изменил';

COMMENT ON COLUMN PAYMENT.EDIT_ON IS
'когда изменил';

COMMENT ON COLUMN PAYMENT.PAY_TYPE_STR IS
'Способ оплаты CASH, CARD: XXX, WEB, и т.д.';

COMMENT ON COLUMN PAYMENT.FISCAL IS
'Пробит ли чек по данному платежу: 0 - нет, 1 - да';

COMMENT ON COLUMN PAYMENT.CMSN IS
'Коммиссия плат. агента';

COMMENT ON COLUMN PAYMENT_DELETED.PAY_DATETIME IS
'Дата и время платежа';

COMMENT ON COLUMN PAYSOURCE.PAYSOURCE_DESCR IS
'Название источника';

COMMENT ON COLUMN PAYSOURCE.CODE IS
'Код в платежны системах';

COMMENT ON COLUMN PAYSOURCE.FOR_FORM IS
'В этом поле будут служебные признаки. разделены ;
OTP - для сторонних заказов; CL - списко абонентов и т.д.';

COMMENT ON COLUMN PAY_DOC.PAY_DOC_ID IS
'внутренний код документа';

COMMENT ON COLUMN PAY_DOC.PAYSOURCE_ID IS
'код источника платежей (таблица PAYSOURCE)';

COMMENT ON COLUMN PAY_DOC.PAY_DOC_NO IS
'номер документа';

COMMENT ON COLUMN PAY_DOC.PAY_DOC_DATE IS
'Дата докумнта';

COMMENT ON COLUMN PAY_DOC.PAY_DOC_SUM IS
'Сумма документа';

COMMENT ON COLUMN PAY_DOC.NOTICE IS
'Примечание';

COMMENT ON COLUMN PERSONAL_TARIF.ADD_METHOD IS
'Как добавлен
 0 - руками через ПО
 1 - при расчете скидок
 2 - акция';

COMMENT ON COLUMN PORT.EID IS
'Устройство';

COMMENT ON COLUMN PORT.PORT IS
'Номер порта';

COMMENT ON COLUMN PORT.NOTICE IS
'Примечание';

COMMENT ON COLUMN PORT.P_TYPE IS
'Тип порта (OBJECT_TYPE 57)';

COMMENT ON COLUMN PORT.P_STATE IS
'Статус порта (OBJECT_TYPE 60)';

COMMENT ON COLUMN PORT.CON IS
'Тип подключения 0-оборудование, 1-абонент, 2-кабель и т.д.
ID оборудования/абонента в CON_ID';

COMMENT ON COLUMN PORT.CON_ID IS
'ID абонента/оборудования/кабеля подключения (ставить автоматом) или NULL Если нет подключения';

COMMENT ON COLUMN PORT.CON_PORT IS
'Подключен к порту оборудования (ставить автоматом)';

COMMENT ON COLUMN PORT.SPEED IS
'Скорость порта МБит';

COMMENT ON COLUMN PORT.VLAN_ID IS
'Влан на порту';

COMMENT ON COLUMN PORT.WID IS
'Линия связи/кабель на порту';

COMMENT ON COLUMN PORT.WLABEL IS
'Метка на кабеле (пучок/жила)';

COMMENT ON COLUMN PROFILES.PROFILE IS
'Название профиля';

COMMENT ON COLUMN PROFILES.PROFTYPE IS
'Если платежи = 0, начисления = 1';

COMMENT ON COLUMN PROFILES.FILETYPE IS
'Текст/DBF/EXCEL';

COMMENT ON COLUMN PROFILES.FILEEXT IS
'расширение файлов';

COMMENT ON COLUMN PROFILES.FILEDIR IS
'В каком каталоге файлы';

COMMENT ON COLUMN PROFILES.PAYMENTSRC IS
'Источник платежа';

COMMENT ON COLUMN PROFILES.CODEPAGE IS
'Кодировка файла (DOS/WIN/UTF)';

COMMENT ON COLUMN PROFILES.ARCHDIR IS
'Куда переносить файл после обработки';

COMMENT ON COLUMN PROFILES.KOPEYKI IS
'Сумма в копейках?';

COMMENT ON COLUMN PROFILES.DECIMALSPRT IS
'Разделитель десятичной части';

COMMENT ON COLUMN PROFILES.HEADSUMLINE IS
'строка суммы документа';

COMMENT ON COLUMN PROFILES.HEADSUMCOL IS
'колонка суммы документа';

COMMENT ON COLUMN PROFILES.HEADSPRT IS
'Разделитель колонок заголовка';

COMMENT ON COLUMN PROFILES.HEADREMCH IS
'Какие символы удалять из строк заголовка';

COMMENT ON COLUMN PROFILES.HEADNUMLINE IS
'строка номера документа';

COMMENT ON COLUMN PROFILES.HEADNUMCOL IS
'колонка номера документа';

COMMENT ON COLUMN PROFILES.HEADERTO IS
'Заголовок по строку';

COMMENT ON COLUMN PROFILES.HEADERFROM IS
'Заголовк  со строки ';

COMMENT ON COLUMN PROFILES.HEADEREXIST IS
'Есть ли заголовок';

COMMENT ON COLUMN PROFILES.HEADDATELINE IS
'строка даты документа';

COMMENT ON COLUMN PROFILES.HEADDATEFMT IS
'формат даты';

COMMENT ON COLUMN PROFILES.HEADDATECOL IS
'колонка даты документа';

COMMENT ON COLUMN PROFILES.DATAFROM IS
'С какой строки начинаются данные';

COMMENT ON COLUMN PROFILES.DATATO IS
'по какую строку данные';

COMMENT ON COLUMN PROFILES.DATASPRT IS
'разделитель столбцов данных';

COMMENT ON COLUMN PROFILES.DATAREMZERO IS
'Удалять ли 0 в начале строк';

COMMENT ON COLUMN PROFILES.DATAREMCH IS
'из данных удалять символы';

COMMENT ON COLUMN PROFILES.ACCOUNT IS
'лицевой';

COMMENT ON COLUMN PROFILES.FIO IS
'фио';

COMMENT ON COLUMN PROFILES.ADRES IS
'адрес';

COMMENT ON COLUMN PROFILES.HOUSE IS
'дом';

COMMENT ON COLUMN PROFILES.KORP IS
'корпус';

COMMENT ON COLUMN PROFILES.FLAT IS
'квартира';

COMMENT ON COLUMN PROFILES.DATADATE IS
'дата данных';

COMMENT ON COLUMN PROFILES.DATEFMT IS
'Формат даты в данных';

COMMENT ON COLUMN PROFILES.DATASUM IS
'сумма данных';

COMMENT ON COLUMN PROFILES.EXTID IS
'номер платежа';

COMMENT ON COLUMN PROFILES.NOTICE IS
'примечание 1';

COMMENT ON COLUMN PROFILES.NOTICE1 IS
'примечание 2';

COMMENT ON COLUMN QRATING.QR_TYPE IS
'Тип. NPS BID';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.CUSTOMER_ID IS
'Кому';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.SRV_FROM IS
'С какой услуги';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.SWITCH_DATE IS
'Дата переключения';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.SRV_TO IS
'на какую услугу';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.SRV_ACT IS
'какой услугой переключать';

COMMENT ON COLUMN QUEUE_SWITCH_SRV.COMPLETED IS
'1 - обработан удачно
2 - обработано с ошибкой
3 - просрочен или услуга была отключена';

COMMENT ON COLUMN RATES.RDATE IS
'Дата курса';

COMMENT ON COLUMN RATES.CUR IS
'Валюта';

COMMENT ON COLUMN RATES.USD IS
'Доллар';

COMMENT ON COLUMN RATES.EUR IS
'Евро';

COMMENT ON COLUMN RECOURSE.RC_ID IS
'ID обращения';

COMMENT ON COLUMN RECOURSE.RC_TYPE IS
'Тип обращения';

COMMENT ON COLUMN RECOURSE.CUSTOMER_ID IS
'Код абонента';

COMMENT ON COLUMN RECOURSE.HOUSE_ID IS
'Код дома';

COMMENT ON COLUMN RECOURSE.FLAT_NO IS
'Квартира';

COMMENT ON COLUMN RECOURSE.NOTICE IS
'Содержание';

COMMENT ON COLUMN RECOURSE.RQ_ID IS
'Заявка созданная обращением';

COMMENT ON COLUMN RECOURSE.CONTACT IS
'Контакт обращения';

COMMENT ON COLUMN RECOURSE.TAG IS
'Флаги. для поиска или фильтрации. используется по усмотрению оператора';

COMMENT ON COLUMN RECOURSE_TEMPLATES.RT_ID IS
'ID';

COMMENT ON COLUMN RECOURSE_TEMPLATES.TYPE_ID IS
'Тип';

COMMENT ON COLUMN RECOURSE_TEMPLATES.NAME IS
'название';

COMMENT ON COLUMN RECOURSE_TEMPLATES.NOTICE IS
'Описание';

COMMENT ON COLUMN RECOURSE_TEMPLATES.NEED_REQUEST IS
'Нужна заявка';

COMMENT ON COLUMN REMINDER.REM_USER IS
'Для кого напоминание';

COMMENT ON COLUMN REMINDER.REM_DATE IS
'Дата напоминания';

COMMENT ON COLUMN REMINDER.REM_NOTICE IS
'Что сделать';

COMMENT ON COLUMN REPORTS.ID_REPORT IS
'Идент. номер';

COMMENT ON COLUMN REPORTS.ID_PARENT IS
'Идент. номер группы';

COMMENT ON COLUMN REPORTS.REPORT_NAME IS
'Наименование отчета';

COMMENT ON COLUMN REPORTS.NO_VISIBLE IS
'Признак невидимости в главном окне';

COMMENT ON COLUMN REQUEST.RQ_ID IS
'уникальный номер заявки';

COMMENT ON COLUMN REQUEST.RQ_TYPE IS
'Тип заявки';

COMMENT ON COLUMN REQUEST.RQ_CUSTOMER IS
'Код абонента';

COMMENT ON COLUMN REQUEST.RQ_CONTENT IS
'содержание заявки';

COMMENT ON COLUMN REQUEST.RQ_DEFECT IS
'Выявленный дефект';

COMMENT ON COLUMN REQUEST.RQ_COMPLETED IS
'Дата и время выдачи';

COMMENT ON COLUMN REQUEST.RQ_NOTICE IS
'Заметки';

COMMENT ON COLUMN REQUEST.RQ_PLAN_DATE IS
'Плановая дата';

COMMENT ON COLUMN REQUEST.RQ_TIME_FROM IS
'время с';

COMMENT ON COLUMN REQUEST.RQ_TIME_TO IS
'время по';

COMMENT ON COLUMN REQUEST.HOUSE_ID IS
'ИД дома';

COMMENT ON COLUMN REQUEST.FLAT_NO IS
'Квартира';

COMMENT ON COLUMN REQUEST.PORCH_N IS
'Подъезд';

COMMENT ON COLUMN REQUEST.FLOOR_N IS
'Этаж';

COMMENT ON COLUMN REQUEST.PHONE IS
'Телефон';

COMMENT ON COLUMN REQUEST.RQ_EXEC_TIME IS
'Дата и Время выполнения';

COMMENT ON COLUMN REQUEST.GIVE_BY IS
'Кто выдал';

COMMENT ON COLUMN REQUEST.GIVE_METHOD IS
'Как выдал
0 - через программу
1 - через веб';

COMMENT ON COLUMN REQUEST.REQ_RESULT IS
'Принята 0
Выдана 1
Выполнена 2
Отменена абонентом 3
Невозможно выполнить 4';

COMMENT ON COLUMN REQUEST.RQTL_ID IS
'код шаблона заявки';

COMMENT ON COLUMN REQUEST.DOOR_CODE IS
'Код домофона';

COMMENT ON COLUMN REQUEST.CAUSE_ID IS
'Причина вызова';

COMMENT ON COLUMN REQUEST.RESULT_ID IS
'Сылка на результат операции';

COMMENT ON COLUMN REQUEST.RECEIPT IS
'Номер квитанции';

COMMENT ON COLUMN REQUEST.EXTEXECUTOR IS
'Другие исполнители';

COMMENT ON COLUMN REQUEST.ADD_INFO IS
'Поле с дополнительной информацией';

COMMENT ON COLUMN REQUEST.TAG IS
'Цифровое поле для собственных нужд';

COMMENT ON COLUMN REQUEST.ADDED_BY IS
'кто внес';

COMMENT ON COLUMN REQUEST.ADDED_ON IS
'Дата приема';

COMMENT ON COLUMN REQUEST.EDIT_BY IS
'Изменен пользователем';

COMMENT ON COLUMN REQUEST.EDIT_ON IS
'Дата изменения';

COMMENT ON COLUMN REQUEST.NODE_ID IS
'ID узла';

COMMENT ON COLUMN REQUEST.PARENT_RQ IS
'Заявка - родитель';

COMMENT ON COLUMN REQUEST_MATERIALS.M_ID IS
'Код материала';

COMMENT ON COLUMN REQUEST_MATERIALS.WH_ID IS
'Склад';

COMMENT ON COLUMN REQUEST_MATERIALS.RM_QUANT IS
'Количество';

COMMENT ON COLUMN REQUEST_MATERIALS.RM_COST IS
'Цена по которой списали';

COMMENT ON COLUMN REQUEST_MATERIALS.NOT_CALC IS
'Не начислять за этот материал абоненту';

COMMENT ON COLUMN REQUEST_MATERIALS.RM_NOTICE IS
'Примечание';

COMMENT ON COLUMN REQUEST_MATERIALS_RETURN.M_ID IS
'Код материала';

COMMENT ON COLUMN REQUEST_MATERIALS_RETURN.QUANT IS
'Количество';

COMMENT ON COLUMN REQUEST_MATERIALS_RETURN.NOTICE IS
'Примечание';

COMMENT ON COLUMN REQUEST_PHOTOS.ID IS
'ID фото';

COMMENT ON COLUMN REQUEST_PHOTOS.RQ_ID IS
'ID заявки';

COMMENT ON COLUMN REQUEST_PHOTOS.HOUSE_ID IS
'ID дома';

COMMENT ON COLUMN REQUEST_RESULTS.RR_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN REQUEST_RESULTS.RT_ID IS
'Тип заявки';

COMMENT ON COLUMN REQUEST_RESULTS.NAME IS
'Оисание результата';

COMMENT ON COLUMN REQUEST_RESULTS.FINISHED IS
'Признак того что заявка считается успешно выполненой';

COMMENT ON COLUMN REQUEST_RESULTS.NOTICE IS
'Примечание к результату';

COMMENT ON COLUMN REQUEST_RESULTS.DELETED IS
'Признак удаления';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQTL_ID IS
'код';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_TYPE IS
'Ссылка на тип работ REQUEST_TYPES';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_MAXTIME IS
'Максимальный срок выполнения или -1(без срока)';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_COLOR IS
'Цвет заявки';

COMMENT ON COLUMN REQUEST_TEMPLATES.ANALYSE_ID IS
'Признак группы анализа причины заявок';

COMMENT ON COLUMN REQUEST_TEMPLATES.ADD_WORK IS
'При выборе причины добавлять работу';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_ONOFF IS
'Заявка на вкл/отключение услуги';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_SRV IS
'Подключаемая/отключаемая услуга';

COMMENT ON COLUMN REQUEST_TEMPLATES.RQ_SRVONOFF IS
'Какой услугой подключать/отключать';

COMMENT ON COLUMN REQUEST_TEMPLATES.DELETED IS
'Признек удаления';

COMMENT ON COLUMN REQUEST_TEMPLATES.ADD_FIELD IS
'Дополнительное поле.
перечень признаков через ;
если есть обязательно для заполнения';

COMMENT ON COLUMN REQUEST_TEMPLATES.NEED_PHOTO IS
'Нужно фото при закрытии';

COMMENT ON COLUMN REQUEST_TEMPLATES.NEED_NODE_RQ IS
'Нужно ли создавать заявку на узел при создании заявки на абонента';

COMMENT ON COLUMN REQUEST_TEMPLATES.RECREATE_DAYS IS
'Если не null, то создать заявку типа через Х дней';

COMMENT ON COLUMN REQUEST_TEMPLATES.RECREATE_TYPE IS
'Пересоздавтаь с новым типом заявки или, если пусто, таким же';

COMMENT ON COLUMN REQUEST_TEMPLATES.SMS_CREATE IS
'Текст SMS абоненту при создании заявки';

COMMENT ON COLUMN REQUEST_TEMPLATES.SMS_CLOSE IS
'Текст SMS абоненту после закрытия заявки';

COMMENT ON COLUMN REQUEST_TYPES.RT_ID IS
'код';

COMMENT ON COLUMN REQUEST_TYPES.RT_NAME IS
'Наименование';

COMMENT ON COLUMN REQUEST_TYPES.RT_TYPE IS
'ППР или обслуживание абонентов';

COMMENT ON COLUMN REQUEST_TYPES.RT_NOTICE IS
'Примеание';

COMMENT ON COLUMN REQUEST_TYPES.RT_PRINTFORM IS
'Печатная форма';

COMMENT ON COLUMN REQUEST_TYPES.RT_DELETED IS
'1 = удалена';

COMMENT ON COLUMN REQUEST_TYPES.RT_COLOR IS
'Цвет в таблице заявок';

COMMENT ON COLUMN REQUEST_TYPES.RT_DEFAULT IS
'В новую заявку по умолчанию';

COMMENT ON COLUMN REQUEST_TYPES.CAUSE_NEED IS
'Обязательна ли причина вызова для типа заявки';

COMMENT ON COLUMN REQUEST_TYPES.RT_HC_NEED IS
'Только для домов введенных в эксплуатацию (стоит дата IN_DATE в доме)';

COMMENT ON COLUMN REQUEST_TYPES.RECREATE_DAYS IS
'Если не null, то создать копию заявки через Х дней';

COMMENT ON COLUMN REQUEST_TYPES.RECREATE_TYPE IS
'Пересоздавтаь с новым типом заявки или, если пусто, таким же';

COMMENT ON COLUMN REQUEST_WORKS.W_TIME IS
'Время выполнения факт';

COMMENT ON COLUMN REQUEST_WORKS.W_QUANT IS
'Колв-во';

COMMENT ON COLUMN REQUEST_WORKS.W_COST IS
'Стоимость работ';

COMMENT ON COLUMN SERVICES.SRV_TYPE_ID IS
'0 - переодическая услуга (по кол-ву дней)
1 - разовая услуга
2 - услуга по факту';

COMMENT ON COLUMN SERVICES.SHIFT_MONTHS IS
'Смещение начислений относительно активного месяца в программе
например -1 месяц назад. 1 месяц вперед';

COMMENT ON COLUMN SERVICES.NAME IS
'Название';

COMMENT ON COLUMN SERVICES.SHORTNAME IS
'Код';

COMMENT ON COLUMN SERVICES.DESCRIPTION IS
'Описание услуги (для абонента)';

COMMENT ON COLUMN SERVICES.DIMENSION IS
'ед. измерения';

COMMENT ON COLUMN SERVICES.EXTRA IS
'Поле для доп. признаков:
-колво дней, чтоб считать месяц полным для услуг с неполным месяцем';

COMMENT ON COLUMN SERVICES.EXTERNAL_ID IS
'Код услуги во внешней системе';

COMMENT ON COLUMN SERVICES.INET_SRV IS
'Признак того что это интернет тариф';

COMMENT ON COLUMN SERVICES.IP_BEGIN IS
'Начало диапазона IP зоны (сделано для связки с UTM)';

COMMENT ON COLUMN SERVICES.IP_END IS
'Конец диапазона IP зоны (сделано для связки с UTM)';

COMMENT ON COLUMN SERVICES.BUSINESS_TYPE IS
'Управление услугами (в таблице OBJECTS O_TYPE = 15)
0 - общая услуга
1 - Сеть передачи данных
все что больше или = 2 - Цифровое ТВ';

COMMENT ON COLUMN SERVICES.CALC_TYPE IS
'Поле способа расчета.
0 - раз в месяц, пропорционально кол-ву дней в месяце
1 - раз в месяц, полный/неполный месяц
2 - ежедневное начисление
3 - Фиксированная сумма
4 - Доначисления. Проверяем разовую услуги и если она меньше тарифа, доначислим разницу.
5 - ежедневное начисление. С учетом дня включения, т.е. если выключена в день включения - считаем.';

COMMENT ON COLUMN SERVICES.USAGE IS
'Частота использования услуги';

COMMENT ON COLUMN SERVICES.AUTOOFF IS
'Отключать ли услугу при недостатке средств';

COMMENT ON COLUMN SERVICES.EXPENSE_TYPE IS
'Начисления абонплата - 0, подключение - 1';

COMMENT ON COLUMN SERVICES.POSITIVE_ONLY IS
'Не допускать минус на балансе, т.е. отключать услугу если у абонента не хватает денег на оплату в расчетном периоде.';

COMMENT ON COLUMN SERVICES.PRIORITY IS
'Приоритет услуг.';

COMMENT ON COLUMN SERVICES.ONLY_ONE IS
'Для цифровых услуг, можно ли услугу привязывать к нескольким картам или нет. по умолчанию null или 0 - можно, 1 - нет';

COMMENT ON COLUMN SERVICES.NOTE IS
'Примечание';

COMMENT ON COLUMN SERVICES.TAG IS
'Цифровое поле для свих нужд';

COMMENT ON COLUMN SERVICES.TAG_STR IS
'Текстовое поле для свих нужд';

COMMENT ON COLUMN SERVICES.OPENLY IS
'Показывать абоненту в ЛК или мобильном приложении';

COMMENT ON COLUMN SERVICES.UNBL_METH IS
'Снять блок при
0 - любом плюсе
1 - дневной тариф
2 - месячный тариф';

COMMENT ON COLUMN SERVICES_ATTRIBUTES.SA_VALUE IS
'Значение атрибута';

COMMENT ON COLUMN SERVICES_CMPLX.SERVICE_ID IS
'ИД услуги';

COMMENT ON COLUMN SERVICES_CMPLX.NAME IS
'Название подраздела';

COMMENT ON COLUMN SERVICES_CMPLX."PERCENT" IS
'% от начислений услуги';

COMMENT ON COLUMN SERVICES_CMPLX.DATE_FROM IS
'% действует с даты';

COMMENT ON COLUMN SERVICES_CMPLX.DATE_TO IS
'% действует по дату';

COMMENT ON COLUMN SERVICES_CMPLX.NOTICE IS
'Примечание';

COMMENT ON COLUMN SERVICES_LINKS.LINK_TYPE IS
'0 абонентская
1 разовая
2 подключение 
3 повт. подключение 
4 откл. по заявке 
5 откл. за неуплату 
6 Переключение на тариф
7 Включение через WEB
8 Выключение через WEB';

COMMENT ON COLUMN SERVICES_LINKS.PARENT IS
'если тип 6 то с какой услуги переключать';

COMMENT ON COLUMN SERVICES_LINKS.CHILD IS
'если тип 6 то на какую услугу переключать';

COMMENT ON COLUMN SERVICES_LINKS.ADD_SRV IS
'если тип 6 то какой услугой переключать';

COMMENT ON COLUMN SERVICES_LINKS.SWITCH_TIME IS
'Когда переключать
-1- при Автоблокировке/разблокировке
0 - В любое время
1 - Начало суток
2 - Начало месяца';

COMMENT ON COLUMN SETTINGS.VAR_TYPE IS
'ftString, ftFixedChar, ftWideString,
ftSmallint, ftInteger, ftLargeint, ftWord, ftFloat, ftCurrency,
ftBoolean,
ftDate, ftTime, ftDateTime,
ftVariant,
ftGuid,
ftBlob';

COMMENT ON COLUMN SINGLE_SERV.PAID IS
'Оплачена ли услуга
0-нет
1-частично
2-да';

COMMENT ON COLUMN SINGLE_SERV.VATG_ID IS
'Группа НДС';

COMMENT ON COLUMN SINGLE_SERV.RQ_ID IS
'Заявка через которую добавили работу';

COMMENT ON COLUMN SINGLE_SERV.TAG IS
'Цифровое поле, используеться оператором как угодно';

COMMENT ON COLUMN STAT_IP.TC_ID IS
'Класс трафика';

COMMENT ON COLUMN STAT_IP.BYTES IS
'Кол-во байт за час для IP';

COMMENT ON COLUMN STAT_IP.GRP_LVL IS
'Уровень группировки H - час D - день W - неделя M - месяц Y - Год';

COMMENT ON COLUMN SUBDIVISIONS.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN SUBDIVISIONS.ID_PARENT IS
'Для полей ссылок которые могут содержать Null';

COMMENT ON COLUMN SUBSCR_HIST.CUSTOMER_ID IS
'Абонент';

COMMENT ON COLUMN SUBSCR_HIST.SERV_ID IS
'Услуга';

COMMENT ON COLUMN SUBSCR_HIST.SUBSCR_SERV_ID IS
'Ссылка на таблицу subscr_serv';

COMMENT ON COLUMN SUBSCR_HIST.DATE_FROM IS
'Дата начала услуги';

COMMENT ON COLUMN SUBSCR_HIST.DATE_TO IS
'Дата окончания услуги';

COMMENT ON COLUMN SUBSCR_HIST.ACT_SERV_ID IS
'Какой услугой включили';

COMMENT ON COLUMN SUBSCR_HIST.DISACT_SERV_ID IS
'Какой услугой выключили';

COMMENT ON COLUMN SUBSCR_HIST.ACT_WORKER_ID IS
'Кто включил';

COMMENT ON COLUMN SUBSCR_HIST.DISACT_WORKER_ID IS
'Кто отключил';

COMMENT ON COLUMN SUBSCR_HIST.ADDED_BY IS
'Кто добавил услугу';

COMMENT ON COLUMN SUBSCR_HIST.ADDED_ON IS
'Время добавления';

COMMENT ON COLUMN SUBSCR_HIST.CLOSED_BY IS
'Кем закрыта';

COMMENT ON COLUMN SUBSCR_HIST.CLOSED_ON IS
'Когда закрыта';

COMMENT ON COLUMN SUBSCR_SERV.CUSTOMER_ID IS
'Абонент';

COMMENT ON COLUMN SUBSCR_SERV.SERV_ID IS
'Код услуги';

COMMENT ON COLUMN SUBSCR_SERV.STATE_SGN IS
'Статус услуги 1-включена 0 - выключена';

COMMENT ON COLUMN SUBSCR_SERV.STATE_DATE IS
'Дата установки статуса';

COMMENT ON COLUMN SUBSCR_SERV.STATE_SRV IS
'какая услуга включила или отключения';

COMMENT ON COLUMN SUBSCR_SERV.STATE_CHANGE_BY IS
'Кто последний менял статус';

COMMENT ON COLUMN SUBSCR_SERV.STATE_CHANGE_ON IS
'когда изменился статус';

COMMENT ON COLUMN SUBSCR_SERV.CONTRACT IS
'Номер договора';

COMMENT ON COLUMN SUBSCR_SERV.CONTRACT_DATE IS
'Дата договора';

COMMENT ON COLUMN SUBSCR_SERV.VATG_ID IS
'Группа НДС';

COMMENT ON COLUMN SYS$GROUP.ALL_REPORTS IS
'Доступ ко всем отчетам';

COMMENT ON COLUMN SYS$GROUP.ALL_MODULES IS
'Доступ ко всем модулям';

COMMENT ON COLUMN SYS$GROUP_RIGHTS.RIGHTS_TYPE IS
'0-разрешение 1-отчет 2-модуль';

COMMENT ON COLUMN SYS$GROUP_RIGHTS.RIGHT_ID IS
'ИД разрешения или отчета или модуля';

COMMENT ON COLUMN SYS$USER.IBNAME IS
'Firebird логин пользователя';

COMMENT ON COLUMN SYS$USER.LOCKEDOUT IS
'Блокирован или нет';

COMMENT ON COLUMN SYS$USER.ALL_AREAS IS
'Если 1 то пользователь видит все районы';

COMMENT ON COLUMN SYS$USER.LAST_LOGGED IS
'Дата последнего входа';

COMMENT ON COLUMN SYS$USER.PSWD_CHANGED IS
'Когда менялся пароль';

COMMENT ON COLUMN SYS$USER_WH.USER_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN SYS$USER_WH.WH_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN TARIF.TARIF_SUM_JUR IS
'Тариф юр. лицам';

COMMENT ON COLUMN TASKLIST.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN TASKLIST.TITLE IS
'Задача';

COMMENT ON COLUMN TASKLIST.NOTICE IS
'Описание';

COMMENT ON COLUMN TASKLIST.PLAN_DATE IS
'Плановая дата';

COMMENT ON COLUMN TASKLIST.EXEC_DATE IS
'Фактическая дата выполнения';

COMMENT ON COLUMN TASKLIST.ADDED_BY IS
'Владелец';

COMMENT ON COLUMN TASKLIST.ADDED_ON IS
'Когда создал';

COMMENT ON COLUMN TASKMSG.TASK_ID IS
'ID задачи';

COMMENT ON COLUMN TASKMSG.ADDED_ON IS
'Время сообщения';

COMMENT ON COLUMN TASKMSG.ADDED_BY IS
'Кто написал';

COMMENT ON COLUMN TASKMSG.TEXT IS
'Что написал';

COMMENT ON COLUMN TASKMSG.OBJ_TYPE IS
'Тип A - абонент, P - платеж, R - заявка';

COMMENT ON COLUMN TASKMSG.OBJ_ID IS
'Лицевой, номер заявки или другой ид объекта';

COMMENT ON COLUMN TASKUSER.TASK_ID IS
'ID задачи';

COMMENT ON COLUMN TASKUSER.FORUSER IS
'Кому назначена. ALL - всем';

COMMENT ON COLUMN TQUEUE.ID IS
'Порядковый номер запроса (не должен повторяться)';

COMMENT ON COLUMN TQUEUE.CLASS_ID IS
'Класс который активируется';

COMMENT ON COLUMN TQUEUE.HARDWARE_ID IS
'ID устройства DRE Crypt';

COMMENT ON COLUMN TQUEUE.STATUS IS
'Статус обработки. 
Для новых запросов должен быть выставлен в 0, далее в процессе обработки обновляется сервером SMS. 
Список кодов ответов SMS см. ниже.
0  Ожидает обработки
1  Обработка на SMS
2  ОК (обработано без ошибок)
3  Ошибка: ID устройства (Hardware_ID) не зарегистрирован в системе SMS
4  Ошибка: неверный класс подписки (Class_ID) 
5  Ошибка: использован ID заблокированного устройства
6  Ошибка: номер карты (Card_ID) не зарегистрирован в системе SMS
7  Ошибка: карта уже была использована или заблокирована (Crad_ID)
8  Ошибка: невозможно добавить подписку (внутренняя ошибка SMS)
9   Ошибка: не найдено ни одной подписки для удаления
10   Ошибка: перенос подписок невозможен т.к. на устройстве доноре нет ни одной подписки
11  Ошибка: пользователь с номером (User_ID) не зарегистрирован в системе SMS
12  Ошибка: указанный диапазон карт не зарегистрирован в системе SMS
13  Ошибка: неверная команда (Action)
14  Ошибка: неверная команда (Action)
15  Ошибка: внутренняя ошибка в обработке
16  Ошибка: истек срок активации карты
17   Ошибка: модель устройства  не зарегистрирован в системе SMS
18   Ошибка: достигнуто максимальное количество устройств лицензии
19   Ошибка: неверная длинна номер устройства (Hardware_ID)
20   Ошибка: некорректный номер устройства (Hardware_ID)
21   Ошибка: номер устройства (Hardware_ID) первой версии cas
22   Ошибка: указаны одинаковые номера устройств
23   Ошибка: указанное устройство уже зарегистрировано на другого пользователя 
24   Ошибка: карта оплаты заблокирована
25   Ошибка: неверная контрольная сумма';

COMMENT ON COLUMN TQUEUE.DATEADDED IS
'Дата добавления запроса на WS';

COMMENT ON COLUMN TQUEUE.TRANSACTIONNUM IS
'Номер транзакции оплаты услуг';

COMMENT ON COLUMN TQUEUE."ACTION" IS
'Тип команды запроса
-1 - сбросить PIN
-2 - pairing где в HARDWARE_ID - номер карточки, CARD_NUM_FIRST указываем номер приставки';

COMMENT ON COLUMN TQUEUE.DATETIME IS
'Дата используется в зависимости от типа команды описание см. ниже';

COMMENT ON COLUMN TQUEUE.DAYCOUNT IS
'Количество дней активации пакета каналов';

COMMENT ON COLUMN TQUEUE.USER_ID IS
'Уникальный номер пользователя в системе SMS';

COMMENT ON COLUMN TQUEUE.EMAIL IS
'Email пользователя ';

COMMENT ON COLUMN TQUEUE.SNAME IS
'Фамилия пользователя';

COMMENT ON COLUMN TQUEUE.FNAME IS
'Имя пользователя ';

COMMENT ON COLUMN TQUEUE.PNAME IS
'Отчество пользователя';

COMMENT ON COLUMN TQUEUE.PHONE IS
'Номер телефона пользователя';

COMMENT ON COLUMN TQUEUE.CARD_NUM_FIRST IS
'Номер первой карты оплаты';

COMMENT ON COLUMN TQUEUE.CARD_NUM_LAST IS
'Номер последней карты оплаты';

COMMENT ON COLUMN TQUEUE.CARD_ID IS
'Секретный код карты оплаты';

COMMENT ON COLUMN TQUEUE.HARDWARE_ID_CH IS
'ID устройства DRE Crypt';

COMMENT ON COLUMN TQUEUE.DEVICE_MODEL_ID IS
'Номер модели устройства DRE Crypt, знаю что 2 - смарткарта';

COMMENT ON COLUMN TQUEUE.INFOCAS_PERIOD IS
'Период в течении которого соблюдая интервал отправляется инфокас сообщение';

COMMENT ON COLUMN TQUEUE.INFOCAS_INTERVAL IS
'Интервал отправки инфокас сообщения';

COMMENT ON COLUMN TQUEUE.INFOCAS_MESSAGE_TEXT IS
'Текст инфокас сообщения';

COMMENT ON COLUMN TQUEUE.INFOCAS_MESSAGE_ID IS
'Номер инфокас сообщения в системе SMS';

COMMENT ON COLUMN TQUEUE.COUNTER IS
'Значение счетчика для подписки';

COMMENT ON COLUMN TQUEUE.COUNTERUNIT IS
' Единица  измерения  для  счетчика  подписки  (0  –  часы,  1  -минуты, 3 – дни)';

COMMENT ON COLUMN TQUEUE.GEOCODE IS
'Значение  геокода  (Значения:  Геокод  1  –  1,  Геокод  2  –  2, Геокод  3  –  4,  Геокод  4  –  8,  Геокод  5  –  16,  Геокод  6  –  32,  Геокод  7  –  64,  Геокод  8  –  128,  Геокод  9  –  256,  удал?н  –  0.  При  использовании  нескольких  геокодов  зада?тся  их сумма)';

COMMENT ON COLUMN TQUEUE.ENDDATE IS
'Дата окончания подписки';

COMMENT ON COLUMN TQUEUE.GEOCODE_HEX IS
'Шестнадцетиричное  представление  геокода.  Поля GEOCODE  и  GEOCODE_HEX  взаимоисключающие,  т.е.  если одно заполнено, другое – NULL.';

COMMENT ON COLUMN TV_LAN.CUSTOMER_ID IS
'код абонента';

COMMENT ON COLUMN TV_LAN.IP IS
'IP абонента';

COMMENT ON COLUMN TV_LAN.MAC IS
'MAC абонента';

COMMENT ON COLUMN TV_LAN.IP_ADD IS
'IP дополнительное (например адрес маршрутизатора)';

COMMENT ON COLUMN TV_LAN.PORT IS
'порт маршрутизатора';

COMMENT ON COLUMN TV_LAN.NOTICE IS
'примечание';

COMMENT ON COLUMN TV_LAN.IP_BIN IS
'двоичный формат';

COMMENT ON COLUMN TV_LAN.IP_ADD_BIN IS
'двоичный формат';

COMMENT ON COLUMN TV_LAN.EQ_ID IS
'Ссылка на коммутатор из справочника EQUIPMENT';

COMMENT ON COLUMN TV_LAN.VLAN_ID IS
'Ссылка на влан из справочника VLANS';

COMMENT ON COLUMN TV_LAN.HOUSE_ID IS
'Дом регистрации этого IP (если отличается от адреса абонента)';

COMMENT ON COLUMN TV_LAN.PLACE IS
'место регистрации этого IP (если отличается от адреса абонента)';

COMMENT ON COLUMN TV_LAN.LAST_UPDATE IS
'Дата последнего изменения записи';

COMMENT ON COLUMN TV_LAN.ADDED_BY IS
'Кто добавил';

COMMENT ON COLUMN TV_LAN.ADDED_ON IS
'Когда добавил';

COMMENT ON COLUMN TV_LAN.EDIT_BY IS
'Кто изменил';

COMMENT ON COLUMN TV_LAN.EDIT_ON IS
'Когда изменил';

COMMENT ON COLUMN VLANS.V_ID IS
'VLAN ID';

COMMENT ON COLUMN VLANS.NAME IS
'название';

COMMENT ON COLUMN VLANS.IP_BEGIN IS
'Первый IP';

COMMENT ON COLUMN VLANS.IP_END IS
'последний IP';

COMMENT ON COLUMN VLANS.MASK IS
'Маска плана';

COMMENT ON COLUMN VLANS.GATEWAY IS
'Шлюз';

COMMENT ON COLUMN VLANS.CONFIG_FILE IS
'Конфиг файл для модемов';

COMMENT ON COLUMN VLANS.FOR_OBJECTS IS
'Для кого эта зона
всех - 0
абонентов - 1
оборудования - 2
как информационное поле - -1';

COMMENT ON COLUMN VLANS.VLAN_NUM IS
'Номер сети на коммутаторе';

COMMENT ON COLUMN VLANS.DNS IS
'DNS сервер для сети';

COMMENT ON COLUMN VPN_SESSIONS.ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN VPN_SESSIONS.CLASS IS
'Тип сессии: IPoE или VPN';

COMMENT ON COLUMN VPN_SESSIONS.ACCOUNT_NO IS
'Номер лицевого счёта';

COMMENT ON COLUMN VPN_SESSIONS.BEGIN_DATE IS
'Время начала сессии';

COMMENT ON COLUMN VPN_SESSIONS.END_DATE IS
'Время окончания сессии';

COMMENT ON COLUMN VPN_SESSIONS.IP IS
'Локальный IP-адрес или IP-адрес IPoE';

COMMENT ON COLUMN VPN_SESSIONS.IP_VPN IS
'IP-адрес VPN';

COMMENT ON COLUMN VPN_SESSIONS.USERNAME IS
'Имя пользователя VPN';

COMMENT ON COLUMN VPN_SESSIONS.INTERFACE IS
'Имя интерфейса на VPN-сервере ppp*';

COMMENT ON COLUMN VPN_SESSIONS.SERVER IS
'IP-адрес VPN-сервера';

COMMENT ON COLUMN VPN_SESSIONS.STATUS IS
'Статус сессии: Открыта, Закрыта, Открыта автоматически, Закрыта автоматически';

COMMENT ON COLUMN WIRE.WID IS
'ID кабеля';

COMMENT ON COLUMN WIRE.WTYPE IS
'Тип кабеля OBJECTS_TYPE = 56';

COMMENT ON COLUMN WIRE.NAME IS
'Название/номер';

COMMENT ON COLUMN WIRE.METERS IS
'Длина в метрах';

COMMENT ON COLUMN WIRE.STOCK IS
'Запас кабеля';

COMMENT ON COLUMN WIRE.POINT_S IS
'Подключен к узлу';

COMMENT ON COLUMN WIRE.POINT_E IS
'Подключен к узлу';

COMMENT ON COLUMN WIRE.NOTICE IS
'Примечание';

COMMENT ON COLUMN WIRE.PATH IS
'Координаты для отображения на карте';

COMMENT ON COLUMN WIRE.CAPACITY IS
'Кол-во жил';

COMMENT ON COLUMN WIRE.M_ID IS
'ID Материала';

COMMENT ON COLUMN WIRE.LABELS IS
'метки на кабеле. через ;';

COMMENT ON COLUMN WORKAREA.REQ_LIMIT IS
'Ограничение заявок на участок. -1 не ограничивать';

COMMENT ON COLUMN WORKAREA.WH_ID IS
'Склад участка';

COMMENT ON COLUMN WORKAREA.BOSS IS
'Начальник';

COMMENT ON COLUMN WORKAREA.FOREMAN IS
'Мастер';

COMMENT ON COLUMN WORKAREA.PHONE IS
'Телефон';

COMMENT ON COLUMN WORKAREA.ADRES IS
'Адрес';

COMMENT ON COLUMN WORKAREALIMIT.WA_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN WORKAREALIMIT.W_ID IS
'FOR PRIMARY KEYS';

COMMENT ON COLUMN WORKER.IN_DOGOVOR IS
'Выводить в списке "Договор составил"';

COMMENT ON COLUMN WORKER.IN_REQUEST IS
'Выводить в списке Монтажников';

COMMENT ON COLUMN WORKER.DEPARTMENT IS
'Подразделение';

COMMENT ON COLUMN WORKER.POST IS
'Должность';

COMMENT ON COLUMN WORKER.BIRTHDAY IS
'День рождения';

COMMENT ON COLUMN WORKER.TEAM IS
'Звено';

COMMENT ON COLUMN WORKER.WA_ID IS
'Участок пользователя';

COMMENT ON COLUMN WORKER.PRINT_FIO IS
'Фио в родительном падеже';

COMMENT ON COLUMN WORKER.PRINT_TEXT IS
'Доп поле для печать в документах';

COMMENT ON COLUMN WORKER.H_RATE IS
'часовая ставка';

COMMENT ON COLUMN WORKER.MESSENGER IS
'Telega/Viber/WhatsApp/Skype и т.д.';

COMMENT ON COLUMN WORKGROUPS.RQ_LIMIT IS
'Ограничение заявок на участок. -1 не ограничивать';

COMMENT ON COLUMN WORKS.W_ID IS
' ID';

COMMENT ON COLUMN WORKS.RQ_TYPE IS
'Тип заявки';

COMMENT ON COLUMN WORKS.WG_ID IS
'Группа работ';

COMMENT ON COLUMN WORKS.NAME IS
'Названеи';

COMMENT ON COLUMN WORKS.NOTICE IS
'Примечание';

COMMENT ON COLUMN WORKS.W_TIME IS
'Время выполнения, часов';

COMMENT ON COLUMN WORKS.W_COST IS
'Стоимость работ';

COMMENT ON COLUMN WORKS.W_ONOFF IS
'Данная работа подключает услугу 1
отключет услугу 2
ничего не делает 0';

COMMENT ON COLUMN WORKS.W_SRV IS
'Какую услуг подключать/отключать';

COMMENT ON COLUMN WORKS.W_SRVONOFF IS
'Какой услугой подкл./откл.
если 0 - то выбор услуги при откл/подкл.';

COMMENT ON COLUMN WORKS.W_ATR_AD IS
'1 - Добавить атрибут
2 - Удалить атрибут
иначе ничего не делаем';

COMMENT ON COLUMN WORKS.W_ATR_ID IS
'ID добавляемого атрибута';

COMMENT ON COLUMN WORKS.AS_SERVICE IS
'Работа равна услуге.
т.е. добавляет абоненту разовую услугу';

COMMENT ON COLUMN WORKS.ON_DEFAULT IS
'при выбое типа заявок, добавлять работу в заявку';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.ACCOUNT_NO IS 
'Лицевой';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.EXT_SYSTEMS_ID IS 
'ИД платежа во внешней системе';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.NOTICE IS 
'Примечание';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.PAYSOURCE_ID IS 
'Источник платежа';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.PAY_SUM IS 
'Сумма';

COMMENT ON PROCEDURE PARAMETER ADD_PAYMENT_FROM_EXT_SYSTEMS.PAY_TIME IS 
'Дата и время платежа';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.CUSTOMER_ID IS 
'ID абонента';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.FOR_DATE IS 
'на какую дату';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.CAN_OFF IS 
'1 - Выключать в ЛК';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.CAN_ON IS 
'1 - Включать в ЛК';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.SERVICE_ID IS 
'ID Услуги';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.STATE IS 
'Статус -1 не предоставлялась, 0 - отключена, 1 подключена, 2 - автоблокировка';

COMMENT ON PROCEDURE PARAMETER API_GET_CUSTOMER_SERVICES.STATE_DATE IS 
'Дата установки статуса или null если не предоставлялась';

COMMENT ON PROCEDURE PARAMETER API_SET_CUSTOMER_SERVICE.CUSTOMER_ID IS 
'ID абонента';

COMMENT ON PROCEDURE PARAMETER API_SET_CUSTOMER_SERVICE.SERVICE_ID IS 
'ID услуги';

COMMENT ON PROCEDURE PARAMETER API_SET_CUSTOMER_SERVICE.SET_DATE IS 
'когда это сделать';

COMMENT ON PROCEDURE PARAMETER API_SET_CUSTOMER_SERVICE.SET_ON IS 
'1 - Включить / 0 - Выключить';

COMMENT ON PROCEDURE PARAMETER CANCEL_CONTRACT.PCANCEL_DATE IS 
'Дата отключения';

COMMENT ON PROCEDURE PARAMETER CANCEL_CONTRACT.PCUSTOMER_ID IS 
'ID абонента';

COMMENT ON PROCEDURE PARAMETER CANCEL_CONTRACT.POFF_SRV_ID IS 
'Услуга отключения';

COMMENT ON PROCEDURE PARAMETER CAN_USER_VIEW_ADDRESS.HOUSE_ID IS 
'ID дома';

COMMENT ON PROCEDURE PARAMETER CAN_USER_VIEW_ADDRESS.STREET_ID IS 
'ID улицы';

COMMENT ON PROCEDURE PARAMETER CAN_USER_VIEW_ADDRESS.USER_NAME IS 
'пользователь';

COMMENT ON PROCEDURE PARAMETER CAN_USER_VIEW_ADDRESS.CAN_VIEW IS 
'1 - видит, 0 - нет';

COMMENT ON PROCEDURE PARAMETER CUSTOMER_BALANCE.FROM_DATE IS 
'дата c которой нужна детализация';

COMMENT ON PROCEDURE PARAMETER CUSTOMER_BALANCE.P_CUSTOMER_ID IS 
'ID абонента';

COMMENT ON PROCEDURE PARAMETER CUSTOMER_BALANCE.SUM_TYPE IS 
'Тип суммы. список в таблице OBJECTS тип 49';

COMMENT ON PROCEDURE PARAMETER DECL_OF_NUM.NUM IS 
'число';

COMMENT ON PROCEDURE PARAMETER DECL_OF_NUM.TITLE0 IS 
'именительный падеж размерности, единственное число (например, «рубль», «день»)';

COMMENT ON PROCEDURE PARAMETER DECL_OF_NUM.TITLE1 IS 
'родительный падеж размерности, единственное число (например, «рубля», «дня»)';

COMMENT ON PROCEDURE PARAMETER DECL_OF_NUM.TITLE2 IS 
'родительный падеж размерности, множественное число (например, «рублей», «дней»)';

COMMENT ON PROCEDURE PARAMETER DUBLICATE_REQUEST.FOR_CUSTOMER IS 
'для абонента. или если для узла, то квартира';

COMMENT ON PROCEDURE PARAMETER DUBLICATE_REQUEST.FOR_NODE IS 
'если 1, то продублируем для узла';

COMMENT ON PROCEDURE PARAMETER DUBLICATE_REQUEST.FROM_REQUEST IS 
'с какой заявки';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.A_DATE IS 
'дата';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.FORMAT IS 
'строка, содержащая шаблон форматирования даты. Заменяются следующие комбинации символов:';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.LONG_DAY_NAMES IS 
'полные названия дней недели через запятую (с понедельника по воскресенье)';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.LONG_MONTH_NAMES IS 
'полные названия месяцев через запятую';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.SHORT_DAY_NAMES IS 
'сокращённые названия дней недели через запятую';

COMMENT ON PROCEDURE PARAMETER FORMAT_DATE.SHORT_MONTH_NAMES IS 
'сокращённые названия месяцев через запятую';

COMMENT ON PROCEDURE PARAMETER GET_DEBT_START_DATE.DEBT IS 
'Долг на дату начала';

COMMENT ON PROCEDURE PARAMETER GET_DEBT_START_DATE.DEBT_DATE IS 
'Дата начала дога';

COMMENT ON PROCEDURE PARAMETER GET_DEBT_START_DATE_CID.DEBT IS 
'Долг на дату начала дога';

COMMENT ON PROCEDURE PARAMETER GET_DEBT_START_DATE_CID.DEBT_DATE IS 
'Дата начала дога';

COMMENT ON PROCEDURE PARAMETER GET_DISTANCE.DISTANCE_METER IS 
'Дистанция в метрах';

COMMENT ON PROCEDURE PARAMETER GET_MAT_GIVE_OUT.FOR_RQ IS 
'Номер заявки';

COMMENT ON PROCEDURE PARAMETER GET_MAT_GIVE_OUT.MG_ID IS 
'-1 - все без учета группы или ид группы материалов';

COMMENT ON PROCEDURE PARAMETER GET_MAT_GIVE_OUT.RQ_OWNER IS 
'Списать со склада монтажника заявки';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.CUSTOMER_ID IS 
'абонент';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.E_BLOCK IS 
'в блоке на конец';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.E_ON IS 
'подключен на конец';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.P_NEW IS 
'подключился за период';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.P_OFF IS 
'отключился за период';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.P_RETURN IS 
'вернулся за период';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.P_SWITCH IS 
'переключился за период';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.SERVICE_ID IS 
'услуга';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.S_BLOCK IS 
'в блоке на начало';

COMMENT ON PROCEDURE PARAMETER GET_STATISTICS.S_ON IS 
'включен на начало';

COMMENT ON PROCEDURE PARAMETER MATERIAL_REMAIN_RECALC.FOR_WH IS 
'Пересчитаем все или конкретный склад';

COMMENT ON PROCEDURE PARAMETER MATERIAL_REMAIN_RECALC.M_ID IS 
'Какой материал пересчитаем';

COMMENT ON PROCEDURE PARAMETER MAT_MOVE_DETAILS.KEEP IS 
'остатки после операции';

COMMENT ON PROCEDURE PARAMETER MIGRATE_SERVICE_BY_ACCOUNT.P_ACCOUNT IS 
'Лицевой';

COMMENT ON PROCEDURE PARAMETER MIGRATE_SERVICE_BY_ACCOUNT.P_DATE IS 
'дата';

COMMENT ON PROCEDURE PARAMETER MIGRATE_SERVICE_BY_ACCOUNT.P_UNITS IS 
'Кол-во';

COMMENT ON PROCEDURE PARAMETER MIGRATE_SERVICE_BY_ACCOUNT.V_SERVICE_ID IS 
'Услуга';

COMMENT ON PROCEDURE PARAMETER MIGRATE_SERVICE_BY_ACCOUNT.SALDO IS 
'сальдо после добавления';

COMMENT ON PROCEDURE PARAMETER ONOFF_SERVICE.ADD_SGL IS 
'Добавлять ли разовую услугу абоненту';

COMMENT ON PROCEDURE PARAMETER ONOFF_SERVICE.RECALC IS 
'Пересчитывать ли абонента после добавления';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.CUSTOMER_ID IS 
'ID абонента';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.FROM_SRV IS 
'ID c какой услунги переключимся';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.NOTICE IS 
'примечаение';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.SWITCH_DATE IS 
'когда переключим';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.SWITCH_SRV IS 
'ID услуги переключения';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.TO_SRV IS 
'ID на какую услугу';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH.UNITS IS 
'кол-во для начислений';

COMMENT ON PROCEDURE PARAMETER QUEUE_SWITCH_HANDLE.FOR_CUSTOMER_ID IS 
'Если ID указан, то обработаем только этого абонента, иначе - всех';

